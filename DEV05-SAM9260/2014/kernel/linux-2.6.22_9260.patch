diff -uNrbBw linux-2.6.22/9260_configs_2014 linux-2.6.22_9260/9260_configs_2014
--- linux-2.6.22/9260_configs_2014	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/9260_configs_2014	2011-08-30 15:35:48.000000000 +0800
@@ -0,0 +1,1352 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22.1
+# Wed May 18 15:21:01 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+CONFIG_LSF=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_AT91=y
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Atmel AT91 System-on-Chip
+#
+# CONFIG_ARCH_AT91RM9200 is not set
+CONFIG_ARCH_AT91SAM9260=y
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+# CONFIG_ARCH_AT91SAM9RL is not set
+
+#
+# AT91SAM9260 Variants
+#
+# CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+
+#
+# AT91SAM9260 / AT91SAM9XE Board Type
+#
+CONFIG_MACH_AT91SAM9260EK=y
+# CONFIG_MACH_CAM60 is not set
+
+#
+# AT91 Board Options
+#
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+# CONFIG_MTD_NAND_AT91_BUSWIDTH_16 is not set
+
+#
+# AT91 Feature Selections
+#
+# CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="initrd=0x21100040,5242880 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IP_VS=y
+CONFIG_IP_VS_DEBUG=y
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=y
+CONFIG_IP_VS_WRR=y
+CONFIG_IP_VS_LC=y
+CONFIG_IP_VS_WLC=y
+CONFIG_IP_VS_LBLC=y
+CONFIG_IP_VS_LBLCR=y
+CONFIG_IP_VS_DH=y
+CONFIG_IP_VS_SH=y
+CONFIG_IP_VS_SED=y
+CONFIG_IP_VS_NQ=y
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK_ENABLED=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE_EBT_T_FILTER=y
+CONFIG_BRIDGE_EBT_T_NAT=y
+CONFIG_BRIDGE_EBT_802_3=y
+CONFIG_BRIDGE_EBT_AMONG=y
+CONFIG_BRIDGE_EBT_ARP=y
+CONFIG_BRIDGE_EBT_IP=y
+CONFIG_BRIDGE_EBT_LIMIT=y
+CONFIG_BRIDGE_EBT_MARK=y
+CONFIG_BRIDGE_EBT_PKTTYPE=y
+CONFIG_BRIDGE_EBT_STP=y
+CONFIG_BRIDGE_EBT_VLAN=y
+CONFIG_BRIDGE_EBT_ARPREPLY=y
+CONFIG_BRIDGE_EBT_DNAT=y
+CONFIG_BRIDGE_EBT_MARK_T=y
+CONFIG_BRIDGE_EBT_REDIRECT=y
+CONFIG_BRIDGE_EBT_SNAT=y
+CONFIG_BRIDGE_EBT_LOG=y
+CONFIG_BRIDGE_EBT_ULOG=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+
+#
+# Wireless
+#
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+CONFIG_IEEE80211_CRYPT_TKIP=y
+# CONFIG_IEEE80211_SOFTMAC is not set
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_AT91=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_UB=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=y
+CONFIG_SCSI_SAS_ATTRS=y
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+CONFIG_MACB_TX_SRAM=y
+CONFIG_SMC91X=y
+CONFIG_DM9000=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+CONFIG_WLAN_PRE80211=y
+# CONFIG_STRIP is not set
+CONFIG_WLAN_80211=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET_MII is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=8
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+# CONFIG_HWMON is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+# CONFIG_HID is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_AT91=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -uNrbBw linux-2.6.22/arch/arm/boot/compressed/head-at91rm9200.S linux-2.6.22_9260/arch/arm/boot/compressed/head-at91rm9200.S
--- linux-2.6.22/arch/arm/boot/compressed/head-at91rm9200.S	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/boot/compressed/head-at91rm9200.S	2014-08-26 16:22:54.398403639 +0800
@@ -73,6 +73,12 @@
 		cmp	r7, r3
 		beq	99f
 
+		@ Promwad Chub : 1181
+		mov	r3,	#(MACH_TYPE_CHUB & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CHUB & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
 		@ Unknown board, use the AT91RM9200DK board
 		@ mov	r7, #MACH_TYPE_AT91RM9200
 		mov	r7,	#(MACH_TYPE_AT91RM9200DK & 0xff)
diff -uNrbBw linux-2.6.22/arch/arm/boot/compressed/misc.c linux-2.6.22_9260/arch/arm/boot/compressed/misc.c
--- linux-2.6.22/arch/arm/boot/compressed/misc.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/boot/compressed/misc.c	2014-08-26 16:23:29.790389852 +0800
@@ -71,7 +71,7 @@
 
 static void putstr(const char *ptr)
 {
-	char c;
+/*	char c;
 
 	while ((c = *ptr++) != '\0') {
 		if (c == '\n')
@@ -79,7 +79,7 @@
 		putc(c);
 	}
 
-	flush();
+	flush();*/
 }
 
 #endif
diff -uNrbBw linux-2.6.22/arch/arm/configs/at91sam9260ek_defconfig linux-2.6.22_9260/arch/arm/configs/at91sam9260ek_defconfig
--- linux-2.6.22/arch/arm/configs/at91sam9260ek_defconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/configs/at91sam9260ek_defconfig	2014-08-26 16:22:54.440385277 +0800
@@ -1,18 +1,24 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.19-rc6
-# Fri Nov 17 18:42:21 2006
+# Linux kernel version: 2.6.21
+# Mon May  7 11:42:02 2007
 #
 CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
 # CONFIG_GENERIC_TIME is not set
 CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
@@ -31,13 +37,16 @@
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
 # CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_UTS_NS is not set
 # CONFIG_AUDIT is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
@@ -76,7 +85,9 @@
 # Block layer
 #
 CONFIG_BLOCK=y
+# CONFIG_LBD is not set
 # CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
 
 #
 # IO Schedulers
@@ -110,10 +121,12 @@
 # CONFIG_ARCH_IMX is not set
 # CONFIG_ARCH_IOP32X is not set
 # CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
 # CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
@@ -129,21 +142,29 @@
 # CONFIG_ARCH_AT91RM9200 is not set
 CONFIG_ARCH_AT91SAM9260=y
 # CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+
+#
+# AT91SAM9260 Variants
+#
+# CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
 
 #
-# AT91SAM9260 Board Type
+# AT91SAM9260 / AT91SAM9XE Board Type
 #
 CONFIG_MACH_AT91SAM9260EK=y
 
 #
 # AT91 Board Options
 #
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
 # CONFIG_MTD_NAND_AT91_BUSWIDTH_16 is not set
 
 #
 # AT91 Feature Selections
 #
 # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
 
 #
 # Processor Type
@@ -166,6 +187,7 @@
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
 
 #
 # Bus support
@@ -193,6 +215,7 @@
 # CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SPLIT_PTLOCK_CPUS=4096
 # CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
 # CONFIG_LEDS is not set
 CONFIG_ALIGNMENT_TRAP=y
 
@@ -203,6 +226,7 @@
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="mem=64M console=ttyS0,115200 initrd=0x21100000,3145728 root=/dev/ram0 rw"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
 
 #
 # Floating point emulation
@@ -228,7 +252,6 @@
 # Power management options
 #
 # CONFIG_PM is not set
-# CONFIG_APM is not set
 
 #
 # Networking
@@ -242,9 +265,6 @@
 CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
@@ -263,14 +283,15 @@
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
 # CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
 # CONFIG_INET6_XFRM_TUNNEL is not set
 # CONFIG_INET6_TUNNEL is not set
@@ -328,6 +349,7 @@
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
 
 #
@@ -348,6 +370,7 @@
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
@@ -360,7 +383,6 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
-CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 
@@ -369,6 +391,7 @@
 #
 # CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
 # CONFIG_SCSI_NETLINK is not set
 CONFIG_SCSI_PROC_FS=y
 
@@ -388,6 +411,7 @@
 CONFIG_SCSI_MULTI_LUN=y
 # CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
 
 #
 # SCSI Transports
@@ -405,6 +429,11 @@
 # CONFIG_SCSI_DEBUG is not set
 
 #
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
 # Multi-device support (RAID and LVM)
 #
 # CONFIG_MD is not set
@@ -425,7 +454,51 @@
 #
 # Network device support
 #
-# CONFIG_NETDEVICES is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -517,10 +590,6 @@
 # CONFIG_NVRAM is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
 # CONFIG_RAW_DRIVER is not set
 
 #
@@ -553,7 +622,11 @@
 #
 # Misc devices
 #
-# CONFIG_TIFM_CORE is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
 
 #
 # LED devices
@@ -582,7 +655,7 @@
 #
 # Graphics support
 #
-# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 # CONFIG_FB is not set
 
 #
@@ -590,7 +663,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -598,6 +670,12 @@
 # CONFIG_SOUND is not set
 
 #
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
 # USB support
 #
 CONFIG_USB_ARCH_HAS_HCD=y
@@ -610,7 +688,6 @@
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
 
@@ -619,7 +696,8 @@
 #
 # CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_SL811_HCD is not set
 
@@ -671,6 +749,7 @@
 # CONFIG_USB_ATI_REMOTE2 is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
 # CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
 
 #
 # USB Imaging devices
@@ -708,6 +787,7 @@
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
@@ -717,6 +797,7 @@
 # CONFIG_USB_APPLEDISPLAY is not set
 # CONFIG_USB_LD is not set
 # CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 
 #
@@ -889,6 +970,11 @@
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
 # Profiling support
 #
 # CONFIG_PROFILING is not set
@@ -900,28 +986,30 @@
 CONFIG_ENABLE_MUST_CHECK=y
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_LOG_BUF_SHIFT=14
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_RWSEMS is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_LIST is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_FORCED_INLINING=y
-# CONFIG_HEADERS_CHECK is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
 CONFIG_DEBUG_USER=y
 # CONFIG_DEBUG_ERRORS is not set
 CONFIG_DEBUG_LL=y
@@ -941,9 +1029,12 @@
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
diff -uNrbBw linux-2.6.22/arch/arm/configs/at91sam9261ek_defconfig linux-2.6.22_9260/arch/arm/configs/at91sam9261ek_defconfig
--- linux-2.6.22/arch/arm/configs/at91sam9261ek_defconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/configs/at91sam9261ek_defconfig	2014-08-26 16:22:54.443410692 +0800
@@ -1,18 +1,24 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.19-rc6
-# Fri Nov 17 18:00:38 2006
+# Linux kernel version: 2.6.21
+# Mon May  7 11:42:30 2007
 #
 CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
 # CONFIG_GENERIC_TIME is not set
 CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
@@ -31,13 +37,16 @@
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
 # CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_UTS_NS is not set
 # CONFIG_AUDIT is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
@@ -76,7 +85,9 @@
 # Block layer
 #
 CONFIG_BLOCK=y
+# CONFIG_LBD is not set
 # CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
 
 #
 # IO Schedulers
@@ -110,10 +121,12 @@
 # CONFIG_ARCH_IMX is not set
 # CONFIG_ARCH_IOP32X is not set
 # CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
 # CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
@@ -129,6 +142,7 @@
 # CONFIG_ARCH_AT91RM9200 is not set
 # CONFIG_ARCH_AT91SAM9260 is not set
 CONFIG_ARCH_AT91SAM9261=y
+# CONFIG_ARCH_AT91SAM9263 is not set
 
 #
 # AT91SAM9261 Board Type
@@ -138,12 +152,14 @@
 #
 # AT91 Board Options
 #
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
 # CONFIG_MTD_NAND_AT91_BUSWIDTH_16 is not set
 
 #
 # AT91 Feature Selections
 #
 # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
 
 #
 # Processor Type
@@ -166,6 +182,7 @@
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
 
 #
 # Bus support
@@ -193,6 +210,7 @@
 # CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SPLIT_PTLOCK_CPUS=4096
 # CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
 # CONFIG_LEDS is not set
 CONFIG_ALIGNMENT_TRAP=y
 
@@ -203,6 +221,7 @@
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="mem=64M console=ttyS0,115200 initrd=0x21100000,3145728 root=/dev/ram0 rw"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
 
 #
 # Floating point emulation
@@ -228,7 +247,6 @@
 # Power management options
 #
 # CONFIG_PM is not set
-# CONFIG_APM is not set
 
 #
 # Networking
@@ -245,6 +263,7 @@
 CONFIG_XFRM=y
 # CONFIG_XFRM_USER is not set
 # CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
@@ -271,6 +290,7 @@
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
 # CONFIG_INET6_XFRM_TUNNEL is not set
 # CONFIG_INET6_TUNNEL is not set
@@ -328,6 +348,7 @@
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
 
 #
@@ -350,6 +371,7 @@
 # User Modules And Translation Layers
 #
 # CONFIG_MTD_CHAR is not set
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
@@ -386,6 +408,8 @@
 #
 # Self-contained MTD device drivers
 #
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
@@ -422,6 +446,7 @@
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
@@ -434,7 +459,6 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
-CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 
@@ -443,6 +467,7 @@
 #
 # CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
 # CONFIG_SCSI_NETLINK is not set
 CONFIG_SCSI_PROC_FS=y
 
@@ -462,6 +487,7 @@
 CONFIG_SCSI_MULTI_LUN=y
 # CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
 
 #
 # SCSI Transports
@@ -479,6 +505,11 @@
 # CONFIG_SCSI_DEBUG is not set
 
 #
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
 # Multi-device support (RAID and LVM)
 #
 # CONFIG_MD is not set
@@ -575,7 +606,16 @@
 # CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -634,10 +674,6 @@
 # CONFIG_NVRAM is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
 # CONFIG_RAW_DRIVER is not set
 
 #
@@ -662,6 +698,7 @@
 # I2C Hardware Bus support
 #
 CONFIG_I2C_AT91=y
+CONFIG_I2C_AT91_CLOCKRATE=100000
 # CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_STUB is not set
@@ -686,8 +723,20 @@
 #
 # SPI support
 #
-# CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
 
 #
 # Dallas's 1-wire bus
@@ -703,7 +752,11 @@
 #
 # Misc devices
 #
-# CONFIG_TIFM_CORE is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
 
 #
 # LED devices
@@ -732,7 +785,7 @@
 #
 # Graphics support
 #
-# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 # CONFIG_FB is not set
 
 #
@@ -740,7 +793,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -748,6 +800,12 @@
 # CONFIG_SOUND is not set
 
 #
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
 # USB support
 #
 CONFIG_USB_ARCH_HAS_HCD=y
@@ -760,7 +818,6 @@
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
 
@@ -769,7 +826,8 @@
 #
 # CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_SL811_HCD is not set
 
@@ -821,6 +879,7 @@
 # CONFIG_USB_ATI_REMOTE2 is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
 # CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
 
 #
 # USB Imaging devices
@@ -858,6 +917,7 @@
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
@@ -867,6 +927,7 @@
 # CONFIG_USB_APPLEDISPLAY is not set
 # CONFIG_USB_LD is not set
 # CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 
 #
@@ -903,7 +964,6 @@
 # CONFIG_MMC_DEBUG is not set
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_AT91=m
-# CONFIG_MMC_TIFM_SD is not set
 
 #
 # Real Time Clock
@@ -973,7 +1033,6 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
 # CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=y
 # CONFIG_VXFS_FS is not set
@@ -1045,6 +1104,11 @@
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
 # Profiling support
 #
 # CONFIG_PROFILING is not set
@@ -1056,28 +1120,30 @@
 CONFIG_ENABLE_MUST_CHECK=y
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_LOG_BUF_SHIFT=14
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_RWSEMS is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_LIST is not set
 CONFIG_FRAME_POINTER=y
 CONFIG_FORCED_INLINING=y
-# CONFIG_HEADERS_CHECK is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
 CONFIG_DEBUG_USER=y
 # CONFIG_DEBUG_ERRORS is not set
 CONFIG_DEBUG_LL=y
@@ -1097,9 +1163,12 @@
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
diff -uNrbBw linux-2.6.22/arch/arm/configs/at91sam9263ek_defconfig linux-2.6.22_9260/arch/arm/configs/at91sam9263ek_defconfig
--- linux-2.6.22/arch/arm/configs/at91sam9263ek_defconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/configs/at91sam9263ek_defconfig	2014-08-26 16:22:54.445384974 +0800
@@ -1,11 +1,14 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.20-rc1
-# Mon Jan  8 16:06:54 2007
+# Linux kernel version: 2.6.21
+# Mon May  7 11:42:49 2007
 #
 CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
 # CONFIG_GENERIC_TIME is not set
 CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
@@ -15,6 +18,7 @@
 # CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
@@ -33,6 +37,7 @@
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
 # CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
@@ -41,6 +46,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
@@ -120,6 +126,7 @@
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
@@ -152,6 +159,7 @@
 # AT91 Feature Selections
 #
 # CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
 
 #
 # Processor Type
@@ -174,6 +182,7 @@
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
 
 #
 # Bus support
@@ -201,6 +210,7 @@
 # CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SPLIT_PTLOCK_CPUS=4096
 # CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
 # CONFIG_LEDS is not set
 CONFIG_ALIGNMENT_TRAP=y
 
@@ -211,6 +221,7 @@
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="mem=64M console=ttyS0,115200 initrd=0x21100000,3145728 root=/dev/ram0 rw"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
 
 #
 # Floating point emulation
@@ -236,7 +247,6 @@
 # Power management options
 #
 # CONFIG_PM is not set
-# CONFIG_APM is not set
 
 #
 # Networking
@@ -333,6 +343,7 @@
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
 
 #
@@ -430,6 +441,7 @@
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
@@ -443,7 +455,6 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
-CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 
@@ -531,6 +542,7 @@
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+CONFIG_MACB=y
 # CONFIG_SMC91X is not set
 # CONFIG_DM9000 is not set
 
@@ -685,6 +697,7 @@
 # I2C Hardware Bus support
 #
 CONFIG_I2C_AT91=y
+CONFIG_I2C_AT91_CLOCKRATE=100000
 # CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_STUB is not set
@@ -722,6 +735,7 @@
 #
 # SPI Protocol Masters
 #
+# CONFIG_SPI_AT25 is not set
 
 #
 # Dallas's 1-wire bus
@@ -737,7 +751,11 @@
 #
 # Misc devices
 #
-# CONFIG_TIFM_CORE is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
 
 #
 # LED devices
@@ -766,15 +784,23 @@
 #
 # Graphics support
 #
-# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
 # CONFIG_FB_CFB_FILLRECT is not set
 # CONFIG_FB_CFB_COPYAREA is not set
 # CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D15605 is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 
@@ -789,7 +815,6 @@
 # Logo configuration
 #
 # CONFIG_LOGO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -800,6 +825,7 @@
 # HID Devices
 #
 CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
 
 #
 # USB support
@@ -814,9 +840,7 @@
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_MULTITHREAD_PROBE is not set
 # CONFIG_USB_OTG is not set
 
 #
@@ -824,7 +848,8 @@
 #
 # CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_SL811_HCD is not set
 
@@ -877,6 +902,7 @@
 # CONFIG_USB_ATI_REMOTE2 is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
 # CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
 
 #
 # USB Imaging devices
@@ -914,6 +940,7 @@
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
@@ -923,6 +950,7 @@
 # CONFIG_USB_APPLEDISPLAY is not set
 # CONFIG_USB_LD is not set
 # CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 
 #
@@ -959,7 +987,6 @@
 # CONFIG_MMC_DEBUG is not set
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_AT91=m
-# CONFIG_MMC_TIFM_SD is not set
 
 #
 # Real Time Clock
@@ -1136,15 +1163,16 @@
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_LOG_BUF_SHIFT=14
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_RWSEMS is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
@@ -1155,6 +1183,7 @@
 CONFIG_FRAME_POINTER=y
 CONFIG_FORCED_INLINING=y
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
 CONFIG_DEBUG_USER=y
 # CONFIG_DEBUG_ERRORS is not set
 CONFIG_DEBUG_LL=y
@@ -1180,5 +1209,7 @@
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
 CONFIG_PLIST=y
-CONFIG_IOMAP_COPY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
diff -uNrbBw linux-2.6.22/arch/arm/configs/cam60_defconfig linux-2.6.22_9260/arch/arm/configs/cam60_defconfig
--- linux-2.6.22/arch/arm/configs/cam60_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/configs/cam60_defconfig	2014-08-26 16:22:54.437388192 +0800
@@ -0,0 +1,954 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.20
+# Tue May  1 21:06:33 2007
+#
+CONFIG_ARM=y
+# CONFIG_GENERIC_TIME is not set
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_AT91=y
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Atmel AT91 System-on-Chip
+#
+# CONFIG_ARCH_AT91RM9200 is not set
+CONFIG_ARCH_AT91SAM9260=y
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+
+#
+# AT91SAM9260 Board Type
+#
+# CONFIG_MACH_AT91SAM9260EK is not set
+CONFIG_MACH_CAM60=y
+
+#
+# AT91 Board Options
+#
+
+#
+# AT91 Feature Selections
+#
+# CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x22000000
+CONFIG_ZBOOT_ROM_BSS=0x20004000
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_CMDLINE="console=ttyS0,115200 noinitrd root=/dev/mtdblock3 rootfstype=jffs2 mem=64M"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+# CONFIG_APM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+# CONFIG_HID is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_IOMAP_COPY=y
diff -uNrbBw linux-2.6.22/arch/arm/configs/kb9202_defconfig linux-2.6.22_9260/arch/arm/configs/kb9202_defconfig
--- linux-2.6.22/arch/arm/configs/kb9202_defconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/configs/kb9202_defconfig	2014-08-26 16:22:54.439386515 +0800
@@ -1,19 +1,31 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.13-rc2
-# Sun Aug 14 19:26:59 2005
+# Linux kernel version: 2.6.21
+# Mon May  7 11:43:14 2007
 #
 CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
 CONFIG_MMU=y
-CONFIG_UID16=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
 #
 # Code maturity level options
 #
-# CONFIG_EXPERIMENTAL is not set
-CONFIG_CLEAN_COMPILE=y
+CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 
@@ -21,54 +33,103 @@
 # General setup
 #
 CONFIG_LOCALVERSION=""
-# CONFIG_SWAP is not set
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SYSCTL=y
-# CONFIG_AUDIT is not set
-CONFIG_HOTPLUG=y
-# CONFIG_KOBJECT_UEVENT is not set
-# CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
+CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
 
 #
 # Loadable module support
 #
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
-CONFIG_OBSOLETE_MODPARM=y
-# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
 CONFIG_KMOD=y
 
 #
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
 # System Type
 #
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_AT91=y
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
 # CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
 # CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
@@ -76,34 +137,52 @@
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
 # CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_AAEC2000 is not set
-CONFIG_ARCH_AT91=y
+
+#
+# Atmel AT91 System-on-Chip
+#
 CONFIG_ARCH_AT91RM9200=y
+# CONFIG_ARCH_AT91SAM9260 is not set
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
 
 #
-# AT91RM9200 Implementations
+# AT91RM9200 Board Type
 #
+# CONFIG_MACH_ONEARM is not set
 # CONFIG_ARCH_AT91RM9200DK is not set
 # CONFIG_MACH_AT91RM9200EK is not set
 # CONFIG_MACH_CSB337 is not set
 # CONFIG_MACH_CSB637 is not set
 # CONFIG_MACH_CARMEVA is not set
+# CONFIG_MACH_ATEB9200 is not set
 CONFIG_MACH_KB9200=y
+# CONFIG_MACH_KAFA is not set
+# CONFIG_MACH_CHUB is not set
+
+#
+# AT91 Board Options
+#
+
+#
+# AT91 Feature Selections
+#
+# CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
 
 #
 # Processor Type
 #
 CONFIG_CPU_32=y
 CONFIG_CPU_ARM920T=y
-CONFIG_CPU_32v4=y
+CONFIG_CPU_32v4T=y
 CONFIG_CPU_ABRT_EV4T=y
 CONFIG_CPU_CACHE_V4WT=y
 CONFIG_CPU_CACHE_VIVT=y
 CONFIG_CPU_COPY_V4WB=y
 CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
 
 #
 # Processor Features
@@ -112,24 +191,44 @@
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_OUTER_CACHE is not set
 
 #
 # Bus support
 #
-CONFIG_ISA_DMA_API=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
 #
-# CONFIG_PCCARD is not set
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+# CONFIG_AT91_CF is not set
 
 #
 # Kernel Features
 #
+# CONFIG_PREEMPT is not set
 # CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
 # CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
 # CONFIG_LEDS is not set
 CONFIG_ALIGNMENT_TRAP=y
 
@@ -138,8 +237,10 @@
 #
 CONFIG_ZBOOT_ROM_TEXT=0x10000000
 CONFIG_ZBOOT_ROM_BSS=0x20040000
-CONFIG_ZBOOT_ROM=y
-CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/ram rw initrd=0x20210000,654933"
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_CMDLINE="noinitrd root=/dev/mtdblock0 rootfstype=jffs2 mem=64M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
 
 #
 # Floating point emulation
@@ -150,6 +251,7 @@
 #
 CONFIG_FPE_NWFPE=y
 # CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
 
 #
 # Userspace binary formats
@@ -165,6 +267,96 @@
 # CONFIG_PM is not set
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
 # Device Drivers
 #
 
@@ -173,13 +365,95 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-CONFIG_DEBUG_DRIVER=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_AT91=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
 
 #
 # Parallel port support
@@ -189,6 +463,7 @@
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
@@ -196,28 +471,27 @@
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
-CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
 # CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
 
 #
-# IO Schedulers
+# ATA/ATAPI/MFM/RLL support
 #
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
 CONFIG_SCSI_PROC_FS=y
 
 #
@@ -233,97 +507,61 @@
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
 
 #
-# SCSI Transport Attributes
+# SCSI Transports
 #
-# CONFIG_SCSI_SPI_ATTRS is not set
+CONFIG_SCSI_SPI_ATTRS=m
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
 
 #
 # SCSI low-level drivers
 #
-# CONFIG_SCSI_SATA is not set
+# CONFIG_ISCSI_TCP is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
+# PCMCIA SCSI adapter support
 #
-# CONFIG_FUSION is not set
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
 
 #
-# IEEE 1394 (FireWire) support
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
 #
+# CONFIG_ATA is not set
 
 #
-# I2O device support
+# Multi-device support (RAID and LVM)
 #
+# CONFIG_MD is not set
 
 #
-# Networking support
+# Fusion MPT device support
 #
-CONFIG_NET=y
+# CONFIG_FUSION is not set
 
 #
-# Networking options
+# IEEE 1394 (FireWire) support
 #
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_IP_TCPDIAG is not set
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_BIC=y
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
 
 #
-# QoS and/or fair queueing
+# I2O device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -331,6 +569,11 @@
 # CONFIG_TUN is not set
 
 #
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -357,11 +600,20 @@
 # CONFIG_NET_RADIO is not set
 
 #
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
 # Wan interfaces
 #
 # CONFIG_WAN is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -372,6 +624,7 @@
 # Input device support
 #
 CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
 
 #
 # Userland interfaces
@@ -397,9 +650,7 @@
 #
 # Hardware I/O ports
 #
-CONFIG_SERIO=y
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
 
 #
@@ -408,6 +659,7 @@
 CONFIG_VT=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -420,11 +672,11 @@
 #
 CONFIG_SERIAL_ATMEL=y
 CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_LEGACY_PTYS is not set
 
 #
 # IPMI
@@ -435,21 +687,23 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
 # CONFIG_NVRAM is not set
-# CONFIG_RTC is not set
-# CONFIG_AT91RM9200_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
 #
-# Ftape, the floppy tape device driver
+# PCMCIA character devices
 #
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
 # TPM devices
 #
-# CONFIG_AT91_SPI is not set
+# CONFIG_TCG_TPM is not set
 
 #
 # I2C support
@@ -457,10 +711,50 @@
 # CONFIG_I2C is not set
 
 #
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_VT1211 is not set
+CONFIG_HWMON_DEBUG_CHIP=y
+
+#
 # Misc devices
 #
 
 #
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -469,17 +763,57 @@
 # Digital Video Broadcasting Devices
 #
 # CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
 
 #
 # Graphics support
 #
-# CONFIG_FB is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_KB920x=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S1D15605=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+CONFIG_FONT_MINI_4x6=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
 
 #
 # Sound
@@ -487,82 +821,98 @@
 # CONFIG_SOUND is not set
 
 #
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
 # USB support
 #
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
 CONFIG_USB=y
-CONFIG_USB_DEBUG=y
+# CONFIG_USB_DEBUG is not set
 
 #
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
 
 #
 # USB Host Controller Drivers
 #
 # CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_SL811_HCD is not set
 
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_BLUETOOTH_TTY is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
 #
 CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+CONFIG_USB_LIBUSUAL=y
 
 #
 # USB Input Devices
 #
-# CONFIG_USB_HID is not set
-
-#
-# USB HID Boot Protocol drivers
-#
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_MOUSE is not set
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
 # CONFIG_USB_AIPTEK is not set
 # CONFIG_USB_WACOM is not set
 # CONFIG_USB_ACECAD is not set
 # CONFIG_USB_KBTAB is not set
 # CONFIG_USB_POWERMATE is not set
-# CONFIG_USB_MTOUCH is not set
-# CONFIG_USB_ITMTOUCH is not set
-# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
 # CONFIG_USB_XPAD is not set
 # CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
 
 #
 # USB Imaging devices
 #
+# CONFIG_USB_MDC800 is not set
 # CONFIG_USB_MICROTEK is not set
 
 #
-# USB Multimedia devices
-#
-# CONFIG_USB_DABUSB is not set
-
-#
-# Video4Linux support is needed for USB Multimedia device support
-#
-
-#
 # USB Network Adapters
 #
+# CONFIG_USB_CATC is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET_MII is not set
 # CONFIG_USB_USBNET is not set
 # CONFIG_USB_MON is not set
 
@@ -580,12 +930,23 @@
 #
 # CONFIG_USB_EMI62 is not set
 # CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
 # CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGETKIT is not set
-# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_PHIDGET is not set
 # CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
 
 #
 # USB DSL modem support
@@ -599,36 +960,51 @@
 #
 # MMC/SD Card support
 #
-# CONFIG_MMC is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_AT91=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
-# CONFIG_EXT2_FS_POSIX_ACL is not set
-# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
 # CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
-# CONFIG_EXT3_FS_POSIX_ACL is not set
-# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4DEV_FS is not set
 CONFIG_JBD=y
 # CONFIG_JBD_DEBUG is not set
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
+CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
-CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS_FS is not set
 CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
@@ -643,25 +1019,40 @@
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
 # CONFIG_NTFS_FS is not set
 
 #
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
 CONFIG_SYSFS=y
-CONFIG_DEVPTS_FS_XATTR=y
-# CONFIG_DEVPTS_FS_SECURITY is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
+# CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_CONFIGFS_FS=y
 
 #
 # Miscellaneous filesystems
 #
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
 # CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -675,16 +1066,23 @@
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -734,26 +1132,51 @@
 # CONFIG_NLS_ISO8859_15 is not set
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+# CONFIG_DEBUG_MUTEXES is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
 CONFIG_FRAME_POINTER=y
-CONFIG_DEBUG_USER=y
-CONFIG_DEBUG_ERRORS=y
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
 CONFIG_DEBUG_LL=y
 # CONFIG_DEBUG_ICEDCC is not set
 
@@ -766,7 +1189,43 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -775,6 +1234,14 @@
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91rm9200.c linux-2.6.22_9260/arch/arm/mach-at91/at91rm9200.c
--- linux-2.6.22/arch/arm/mach-at91/at91rm9200.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91rm9200.c	2014-08-26 16:22:54.420383350 +0800
@@ -267,6 +267,33 @@
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91rm9200_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91RM9200_BASE_TCB0,
+		.irq		= { AT91RM9200_ID_TC0, AT91RM9200_ID_TC1, AT91RM9200_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	},
+	[1] = {
+		.physaddr	= AT91RM9200_BASE_TCB1,
+		.irq		= { AT91RM9200_ID_TC3, AT91RM9200_ID_TC4, AT91RM9200_ID_TC5 },
+		.clk		= { &tc3_clk, &tc4_clk, &tc5_clk },
+	},
+};
+
+#define at91rm9200_tc_init()	atmel_tc_init(at91rm9200_tcblocks, ARRAY_SIZE(at91rm9200_tcblocks))
+
+#else
+#define at91rm9200_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91RM9200 processor initialization
  * -------------------------------------------------------------------- */
 void __init at91rm9200_initialize(unsigned long main_clock, unsigned short banks)
@@ -288,6 +315,9 @@
 
 	/* Initialize GPIO subsystem */
 	at91_gpio_init(at91rm9200_gpio, banks);
+
+	/* Initialize the Timer/Counter blocks */
+	at91rm9200_tc_init();
 }
 
 
@@ -301,28 +331,28 @@
 static unsigned int at91rm9200_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller (FIQ) */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
-	0,	/* Parallel IO Controller D */
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
-	6,	/* USART 3 */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
+	1,	/* Parallel IO Controller D */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	5,	/* Serial Synchronous Controller 2 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	4,	/* Serial Synchronous Controller 2 */
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
 	0,	/* Timer Counter 3 */
 	0,	/* Timer Counter 4 */
 	0,	/* Timer Counter 5 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* Ethernet MAC */
 	0,	/* Advanced Interrupt Controller (IRQ0) */
 	0,	/* Advanced Interrupt Controller (IRQ1) */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91rm9200_devices.c linux-2.6.22_9260/arch/arm/mach-at91/at91rm9200_devices.c
--- linux-2.6.22/arch/arm/mach-at91/at91rm9200_devices.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91rm9200_devices.c	2014-08-26 16:22:54.422391649 +0800
@@ -477,7 +477,18 @@
  *  SPI
  * -------------------------------------------------------------------- */
 
-#if defined(CONFIG_SPI_AT91) || defined(CONFIG_SPI_AT91_MODULE) || defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)
+#if defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)		/* legacy SPI driver */
+#define SPI_DEVNAME	"at91_spi"
+
+#elif defined(CONFIG_SPI_AT91) || defined(CONFIG_SPI_AT91_MODULE)	/* SPI bitbanging driver */
+#define SPI_DEVNAME	"at91_spi"
+
+#elif defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)	/* new SPI driver */
+#define SPI_DEVNAME	"atmel_spi"
+
+#endif
+
+#ifdef SPI_DEVNAME
 static u64 spi_dmamask = 0xffffffffUL;
 
 static struct resource spi_resources[] = {
@@ -494,7 +505,7 @@
 };
 
 static struct platform_device at91rm9200_spi_device = {
-	.name		= "at91_spi",
+	.name		= SPI_DEVNAME,
 	.id		= 0,
 	.dev		= {
 				.dma_mask		= &spi_dmamask,
@@ -603,6 +614,32 @@
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9260.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9260.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9260.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9260.c	2014-08-26 16:22:54.405467034 +0800
@@ -269,6 +269,33 @@
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9260_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9260_BASE_TCB0,
+		.irq		= { AT91SAM9260_ID_TC0, AT91SAM9260_ID_TC1, AT91SAM9260_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	},
+	[1] = {
+		.physaddr	= AT91SAM9260_BASE_TCB1,
+		.irq		= { AT91SAM9260_ID_TC3, AT91SAM9260_ID_TC4, AT91SAM9260_ID_TC5 },
+		.clk		= { &tc3_clk, &tc4_clk, &tc5_clk },
+	},
+};
+
+#define at91sam9260_tc_init()	atmel_tc_init(at91sam9260_tcblocks, ARRAY_SIZE(at91sam9260_tcblocks))
+
+#else
+#define at91sam9260_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9260 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -315,6 +342,9 @@
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9260_gpio, 3);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9260_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -327,30 +357,30 @@
 static unsigned int at91sam9260_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
 	0,	/* Analog-to-Digital Converter */
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
 	5,	/* Serial Synchronous Controller */
 	0,
 	0,
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* Ethernet */
 	0,	/* Image Sensor Interface */
-	6,	/* USART 3 */
-	6,	/* USART 4 */
-	6,	/* USART 5 */
+	5,	/* USART 3 */
+	5,	/* USART 4 */
+	5,	/* USART 5 */
 	0,	/* Timer Counter 3 */
 	0,	/* Timer Counter 4 */
 	0,	/* Timer Counter 5 */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9260_devices.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9260_devices.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9260_devices.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9260_devices.c	2014-08-26 16:23:12.711402115 +0800
@@ -138,6 +138,13 @@
 		.end	= AT91SAM9260_ID_EMAC,
 		.flags	= IORESOURCE_IRQ,
 	},
+#if defined(CONFIG_MACB_TX_SRAM)
+        [2] = {
+               .start  = AT91SAM9260_SRAM0_BASE,
+               .end    = AT91SAM9260_SRAM0_BASE + AT91SAM9260_SRAM0_SIZE - 1,
+               .flags  = IORESOURCE_MEM,
+       },
+#endif
 };
 
 static struct platform_device at91sam9260_eth_device = {
@@ -524,6 +531,32 @@
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9261.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9261.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9261.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9261.c	2014-08-26 16:22:54.406409639 +0800
@@ -247,6 +247,28 @@
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9261_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9261_BASE_TCB0,
+		.irq		= { AT91SAM9261_ID_TC0, AT91SAM9261_ID_TC1, AT91SAM9261_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	}
+};
+
+#define at91sam9261_tc_init()	atmel_tc_init(at91sam9261_tcblocks, ARRAY_SIZE(at91sam9261_tcblocks))
+
+#else
+#define at91sam9261_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9261 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -267,6 +289,9 @@
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9261_gpio, 3);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9261_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -279,25 +304,25 @@
 static unsigned int at91sam9261_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
-	0,
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
+	0,
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	5,	/* Serial Synchronous Controller 2 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	4,	/* Serial Synchronous Controller 2 */
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* LCD Controller */
 	0,
 	0,
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9261_devices.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9261_devices.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9261_devices.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9261_devices.c	2014-08-26 16:23:12.712398993 +0800
@@ -14,6 +14,9 @@
 #include <asm/mach/map.h>
 
 #include <linux/platform_device.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
@@ -342,7 +345,13 @@
 	.num_resources	= ARRAY_SIZE(spi0_resources),
 };
 
-static const unsigned spi0_standard_cs[4] = { AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PA5, AT91_PIN_PA6 };
+static const unsigned spi0_standard_cs[4] = { AT91_PIN_PA3, AT91_PIN_PA4, AT91_PIN_PA28, 
+#if defined(CONFIG_MACH_AT91SAM9261EK) && defined(CONFIG_SND_AT73C213) 
+	AT91_PIN_PA29 };
+#else
+	AT91_PIN_PA6 };
+#endif
+
 
 static struct resource spi1_resources[] = {
 	[0] = {
@@ -522,6 +531,32 @@
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9263.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9263.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9263.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9263.c	2014-08-26 16:22:54.410396902 +0800
@@ -273,6 +273,28 @@
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9263_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9263_BASE_TCB0,
+		.irq		= { AT91SAM9263_ID_TCB, AT91SAM9263_ID_TCB, AT91SAM9263_ID_TCB },
+		.clk		= { &tcb_clk, &tcb_clk, &tcb_clk },
+	}
+};
+
+#define at91sam9263_tc_init()	atmel_tc_init(at91sam9263_tcblocks, ARRAY_SIZE(at91sam9263_tcblocks))
+
+#else
+#define at91sam9263_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9263 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -292,6 +314,9 @@
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9263_gpio, 5);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9263_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -304,34 +329,34 @@
 static unsigned int at91sam9263_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller (FIQ) */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C, D and E */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C, D and E */
 	0,
 	0,
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface 0 */
 	0,	/* Multimedia Card Interface 1 */
-	4,	/* CAN */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	6,	/* AC97 Controller */
+	3,	/* CAN */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	5,	/* AC97 Controller */
 	0,	/* Timer Counter 0, 1 and 2 */
 	0,	/* Pulse Width Modulation Controller */
 	3,	/* Ethernet */
 	0,
 	0,	/* 2D Graphic Engine */
-	3,	/* USB Device Port */
+	2,	/* USB Device Port */
 	0,	/* Image Sensor Interface */
 	3,	/* LDC Controller */
 	0,	/* DMA Controller */
 	0,
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	0,	/* Advanced Interrupt Controller (IRQ0) */
 	0,	/* Advanced Interrupt Controller (IRQ1) */
 };
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9263_devices.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9263_devices.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9263_devices.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9263_devices.c	2014-08-26 16:23:12.715391022 +0800
@@ -13,6 +13,9 @@
 #include <asm/mach/map.h>
 
 #include <linux/platform_device.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
@@ -146,6 +149,13 @@
 		.end	= AT91SAM9263_ID_EMAC,
 		.flags	= IORESOURCE_IRQ,
 	},
+#if defined(CONFIG_MACB_TX_SRAM)
+	[2] = {
+               .start  = AT91SAM9263_SRAM0_BASE,
+               .end    = AT91SAM9263_SRAM0_BASE + AT91SAM9263_SRAM0_SIZE - 1,
+               .flags  = IORESOURCE_MEM,
+       },
+#endif
 };
 
 static struct platform_device at91sam9263_eth_device = {
@@ -616,7 +626,7 @@
 	if (data->reset_pin)
 		at91_set_gpio_output(data->reset_pin, 0);
 
-	ac97_data = *ek_data;
+	ac97_data = *data;
 	platform_device_register(&at91sam9263_ac97_device);
 }
 #else
@@ -625,6 +635,56 @@
 
 
 /* --------------------------------------------------------------------
+ *  Image Sensor Interface
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_VIDEO_AT91_ISI) || defined(CONFIG_VIDEO_AT91_ISI_MODULE)
+
+struct resource isi_resources[] = {
+	[0] = {
+		.start	= AT91SAM9263_BASE_ISI,
+		.end	= AT91SAM9263_BASE_ISI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9263_ID_ISI,
+		.end	= AT91SAM9263_ID_ISI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9263_isi_device = {
+	.name		= "at91_isi",
+	.id		= -1,
+	.resource	= isi_resources,
+	.num_resources	= ARRAY_SIZE(isi_resources),
+};
+
+void __init at91_add_device_isi(void)
+{
+	at91_set_A_periph(AT91_PIN_PE0, 0);	/* ISI_D0 */
+	at91_set_A_periph(AT91_PIN_PE1, 0);	/* ISI_D1 */
+	at91_set_A_periph(AT91_PIN_PE2, 0);	/* ISI_D2 */
+	at91_set_A_periph(AT91_PIN_PE3, 0);	/* ISI_D3 */
+	at91_set_A_periph(AT91_PIN_PE4, 0);	/* ISI_D4 */
+	at91_set_A_periph(AT91_PIN_PE5, 0);	/* ISI_D5 */
+	at91_set_A_periph(AT91_PIN_PE6, 0);	/* ISI_D6 */
+	at91_set_A_periph(AT91_PIN_PE7, 0);	/* ISI_D7 */
+	at91_set_A_periph(AT91_PIN_PE8, 0);	/* ISI_PCK */
+	at91_set_A_periph(AT91_PIN_PE9, 0);	/* ISI_HSYNC */
+	at91_set_A_periph(AT91_PIN_PE10, 0);	/* ISI_VSYNC */
+	at91_set_B_periph(AT91_PIN_PE11, 0);	/* ISI_MCK (PCK3) */
+	at91_set_B_periph(AT91_PIN_PE12, 0);	/* ISI_PD8 */
+	at91_set_B_periph(AT91_PIN_PE13, 0);	/* ISI_PD9 */
+	at91_set_B_periph(AT91_PIN_PE14, 0);	/* ISI_PD10 */
+	at91_set_B_periph(AT91_PIN_PE15, 0);	/* ISI_PD11 */
+}
+#else
+void __init at91_add_device_isi(void) {}
+#endif
+
+
+/* --------------------------------------------------------------------
  *  LCD Controller
  * -------------------------------------------------------------------- */
 
@@ -715,6 +775,32 @@
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9rl.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9rl.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9rl.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9rl.c	2014-08-26 16:22:54.426398543 +0800
@@ -246,6 +246,28 @@
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9rl_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9RL_BASE_TCB0,
+		.irq		= { AT91SAM9RL_ID_TC0, AT91SAM9RL_ID_TC1, AT91SAM9RL_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	}
+};
+
+#define at91sam9rl_tc_init()	atmel_tc_init(at91sam9rl_tcblocks, ARRAY_SIZE(at91sam9rl_tcblocks))
+
+#else
+#define at91sam9rl_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9RL processor initialization
  * -------------------------------------------------------------------- */
 
@@ -284,6 +306,9 @@
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9rl_gpio, 4);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9rl_tc_init();
 }
 
 /* --------------------------------------------------------------------
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/at91sam9rl_devices.c linux-2.6.22_9260/arch/arm/mach-at91/at91sam9rl_devices.c
--- linux-2.6.22/arch/arm/mach-at91/at91sam9rl_devices.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/at91sam9rl_devices.c	2014-08-26 16:22:54.427386084 +0800
@@ -370,6 +370,32 @@
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-cam60.c linux-2.6.22_9260/arch/arm/mach-at91/board-cam60.c
--- linux-2.6.22/arch/arm/mach-at91/board-cam60.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-cam60.c	2014-08-26 16:22:54.435387485 +0800
@@ -0,0 +1,148 @@
+/*
+ * KwikByte CAM60
+ *
+ * based on board-sam9260ek.c
+ *   Copyright (C) 2005 SAN People
+ *   Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam926x_mc.h>
+
+#include "generic.h"
+
+
+/*
+ * Serial port configuration.
+ *    0 .. 5 = USART0 .. USART5
+ *    6      = DBGU
+ */
+static struct at91_uart_config __initdata cam60_uart_config = {
+	.console_tty	= 0,				/* ttyS0 */
+	.nr_tty		= 1,
+	.tty_map	= { 6, -1, -1, -1, -1, -1, -1 }	/* ttyS0, ..., ttyS6 */
+};
+
+static void __init cam60_map_io(void)
+{
+	/* Initialize processor: 10 MHz crystal */
+	at91sam9260_initialize(10000000);
+
+	/* Setup the serial ports and console */
+	at91_init_serial(&cam60_uart_config);
+}
+
+static void __init cam60_init_irq(void)
+{
+	at91sam9260_init_interrupts(NULL);
+}
+
+
+/*
+ * SPI devices.
+ */
+#if defined(CONFIG_MTD_DATAFLASH)
+static struct mtd_partition __initdata cam60_spi_partitions[] = {
+	{
+		.name	= "BOOT1",
+		.offset	= 0,
+		.size	= 4 * 1056,
+	},
+	{
+		.name	= "BOOT2",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 256 * 1056,
+	},
+	{
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 2222 * 1056,
+	},
+	{
+		.name	= "file system",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data __initdata cam60_spi_flash_platform_data = {
+	.name		= "spi_flash",
+	.parts		= cam60_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(cam60_spi_partitions)
+};
+#endif
+
+static struct spi_board_info cam60_spi_devices[] = {
+#if defined(CONFIG_MTD_DATAFLASH)
+	{	/* DataFlash chip */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+		.platform_data	= &cam60_spi_flash_platform_data
+	},
+#endif
+};
+
+
+/*
+ * MACB Ethernet device
+ */
+static struct __initdata at91_eth_data cam60_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PB5,
+	.is_rmii	= 0,
+};
+
+
+static void __init cam60_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* SPI */
+	at91_add_device_spi(cam60_spi_devices, ARRAY_SIZE(cam60_spi_devices));
+	/* Ethernet */
+	at91_add_device_eth(&cam60_macb_data);
+}
+
+MACHINE_START(CAM60, "KwikByte CAM60")
+	/* Maintainer: KwikByte */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91sam926x_timer,
+	.map_io		= cam60_map_io,
+	.init_irq	= cam60_init_irq,
+	.init_machine	= cam60_board_init,
+MACHINE_END
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-chub.c linux-2.6.22_9260/arch/arm/mach-at91/board-chub.c
--- linux-2.6.22/arch/arm/mach-at91/board-chub.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-chub.c	2014-08-26 16:22:54.414401084 +0800
@@ -0,0 +1,132 @@
+/*
+ * linux/arch/arm/mach-at91/board-chub.c
+ *
+ *  Copyright (C) 2005 SAN People, adapted for Promwad Chub board
+ *  by Kuten Ivan
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#include "generic.h"
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+static struct at91_uart_config __initdata chub_uart_config = {
+	.console_tty	= 0,				/* ttyS0 */
+	.nr_tty		= 5,
+	.tty_map	= { 4, 0, 1, 2, 3 }		/* ttyS0, ..., ttyS4 */
+};
+
+static void __init chub_init_irq(void)
+{
+	at91rm9200_init_interrupts(NULL);
+}
+
+static void __init chub_map_io(void)
+{
+	/* Initialize clocks: 18.432 MHz crystal */
+	at91rm9200_initialize(18432000, AT91RM9200_PQFP);
+
+	/* Setup the serial ports and console */
+	at91_init_serial(&chub_uart_config);
+}
+
+static struct at91_eth_data __initdata chub_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PB29,
+	.is_rmii	= 0,
+};
+
+static struct mtd_partition __initdata chub_nand_partition[] = {
+	{
+		.name	= "NAND Partition 1",
+		.offset = 0,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(chub_nand_partition);
+	return chub_nand_partition;
+}
+
+static struct at91_nand_data __initdata chub_nand_data = {
+	.ale		= 22,
+	.cle		= 21,
+	.enable_pin	= AT91_PIN_PA27,
+	.partition_info	= nand_partitions,
+};
+
+static struct spi_board_info chub_spi_devices[] = {
+	{	/* DataFlash chip */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+	},
+};
+
+static void __init chub_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* I2C */
+	at91_add_device_i2c();
+	/* Ethernet */
+	at91_add_device_eth(&chub_eth_data);
+	/* SPI */
+	at91_add_device_spi(chub_spi_devices, ARRAY_SIZE(chub_spi_devices));
+	/* NAND Flash */
+	at91_add_device_nand(&chub_nand_data);
+	/* Disable write protect for NAND */
+	at91_set_gpio_output(AT91_PIN_PB7, 1);
+	/* Power enable for 3x RS-232 and 1x RS-485 */
+	at91_set_gpio_output(AT91_PIN_PB9, 1);
+	/* Disable write protect for FRAM */
+	at91_set_gpio_output(AT91_PIN_PA21, 1);
+	/* Disable write protect for Dataflash */
+	at91_set_gpio_output(AT91_PIN_PA19, 1);
+}
+
+MACHINE_START(CHUB, "Promwad Chub")
+	/* Maintainer: Ivan Kuten AT Promwad DOT com */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= chub_map_io,
+	.init_irq	= chub_init_irq,
+	.init_machine	= chub_board_init,
+MACHINE_END
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-csb337.c linux-2.6.22_9260/arch/arm/mach-at91/board-csb337.c
--- linux-2.6.22/arch/arm/mach-at91/board-csb337.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-csb337.c	2014-08-26 16:22:54.433385483 +0800
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/interrupt.h>
 #include <linux/mtd/physmap.h>
 
 #include <asm/hardware.h>
@@ -59,6 +60,7 @@
 
 	/* Setup the LEDs */
 	at91_init_leds(AT91_PIN_PB0, AT91_PIN_PB1);
+	at91_set_gpio_output(AT91_PIN_PB2, 1);		/* third (unused) LED */
 
 	/* Setup the serial ports and console */
 	at91_init_serial(&csb337_uart_config);
@@ -149,6 +151,55 @@
 	.num_resources	= ARRAY_SIZE(csb_flash_resources),
 };
 
+static struct at91_gpio_led csb337_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB0,
+		.trigger	= "heartbeat",
+	},
+	{
+		.name		= "led1",
+		.gpio		= AT91_PIN_PB1,
+		.trigger	= "timer",
+	},
+	{
+		.name		= "led2",
+		.gpio		= AT91_PIN_PB2,
+	}
+};
+
+#if defined(CONFIG_CSB300_WAKE_SW0) || defined(CONFIG_CSB300_WAKE_SW1)
+static irqreturn_t switch_irq_handler(int irq, void *context)
+{
+	return IRQ_HANDLED;
+}
+
+static inline void __init switch_irq_setup(int irq, char *name, unsigned long mode)
+{
+	int res;
+
+	res = request_irq(irq, switch_irq_handler, IRQF_SAMPLE_RANDOM | mode, name, NULL);
+	if (res == 0)
+		enable_irq_wake(irq);
+}
+
+static void __init csb300_switches(void)
+{
+#ifdef CONFIG_CSB300_WAKE_SW0
+	at91_set_A_periph(AT91_PIN_PB29, 1);		/* IRQ0 */
+	switch_irq_setup(AT91RM9200_ID_IRQ0, "csb300_sw0", IRQF_TRIGGER_FALLING);
+#endif
+#ifdef CONFIG_CSB300_WAKE_SW1
+	at91_set_gpio_input(AT91_PIN_PB28, 1);
+	at91_set_deglitch(AT91_PIN_PB28, 1);
+	switch_irq_setup(AT91_PIN_PB28, "csb300_sw1", IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING);
+#endif
+	/* there's also SW2 at PA21, GPIO or TIOA2 */
+}
+#else
+static void __init csb300_switches(void) {}
+#endif
+
 static void __init csb337_board_init(void)
 {
 	/* Serial */
@@ -168,8 +219,12 @@
 	at91_add_device_spi(csb337_spi_devices, ARRAY_SIZE(csb337_spi_devices));
 	/* MMC */
 	at91_add_device_mmc(0, &csb337_mmc_data);
+	/* LEDS */
+	at91_gpio_leds(csb337_leds, ARRAY_SIZE(csb337_leds));
 	/* NOR flash */
 	platform_device_register(&csb_flash);
+	/* Switches on CSB300 */
+	csb300_switches();
 }
 
 MACHINE_START(CSB337, "Cogent CSB337")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-dk.c linux-2.6.22_9260/arch/arm/mach-at91/board-dk.c
--- linux-2.6.22/arch/arm/mach-at91/board-dk.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-dk.c	2014-08-26 16:22:54.433385483 +0800
@@ -73,6 +73,185 @@
 	at91rm9200_init_interrupts(NULL);
 }
 
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x30000000L
+#define AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x30200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init dk_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_set_A_periph(AT91_PIN_PC6, 0);
+
+	/* Initialization of the Static Memory Controller for Chip Select 2 */
+	at91_sys_write(AT91_SMC_CSR(2), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(4)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+
+	at91_ics1523_init();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval dk_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0x00},
+	{S1DREG_GPIO_CNF1,		0x00},
+	{S1DREG_GPIO_CTL0,		0x08},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x00},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata dk_s1dfb_pdata = {
+	.initregs		= dk_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(dk_s1dfb_initregs),
+	.platform_init_video	= dk_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource dk_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dk_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &dk_s1dfb_pdata,
+	},
+	.resource	= dk_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(dk_s1dfb_resource),
+};
+
+static void __init dk_add_device_video(void)
+{
+	platform_device_register(&dk_s1dfb_device);
+}
+#else
+static void __init dk_add_device_video(void) {}
+#endif
+
 static struct at91_eth_data __initdata dk_eth_data = {
 	.phy_irq_pin	= AT91_PIN_PC4,
 	.is_rmii	= 1,
@@ -170,6 +349,13 @@
 	.num_resources	= 1,
 };
 
+static struct at91_gpio_led dk_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB2,
+		.trigger	= "timer",
+	}
+};
 
 static void __init dk_board_init(void)
 {
@@ -200,8 +386,10 @@
 	at91_add_device_nand(&dk_nand_data);
 	/* NOR Flash */
 	platform_device_register(&dk_flash);
+	/* LEDs */
+	at91_gpio_leds(dk_leds, ARRAY_SIZE(dk_leds));
 	/* VGA */
-//	dk_add_device_video();
+	dk_add_device_video();
 }
 
 MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-ek.c linux-2.6.22_9260/arch/arm/mach-at91/board-ek.c
--- linux-2.6.22/arch/arm/mach-at91/board-ek.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-ek.c	2014-08-26 16:22:54.419390652 +0800
@@ -73,6 +73,187 @@
 	at91rm9200_init_interrupts(NULL);
 }
 
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x40000000L
+#define	AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x40200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init ek_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_set_A_periph(AT91_PIN_PC6, 0);
+
+	/* Initialization of the Static Memory Controller for Chip Select 3 */
+	at91_sys_write(AT91_SMC_CSR(3), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(5)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+
+	at91_ics1523_init();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval ek_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0xFF},	// 0x00
+	{S1DREG_GPIO_CNF1,		0x1F},	// 0x08
+	{S1DREG_GPIO_CTL0,		0x00},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{0x005E,			0x9F},
+	{0x005F,			0x00},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x10},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata ek_s1dfb_pdata = {
+	.initregs		= ek_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(ek_s1dfb_initregs),
+	.platform_init_video	= ek_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource ek_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ek_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &ek_s1dfb_pdata,
+	},
+	.resource	= ek_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(ek_s1dfb_resource),
+};
+
+static void __init ek_add_device_video(void)
+{
+	platform_device_register(&ek_s1dfb_device);
+}
+#else
+static void __init ek_add_device_video(void) {}
+#endif
+
 static struct at91_eth_data __initdata ek_eth_data = {
 	.phy_irq_pin	= AT91_PIN_PC4,
 	.is_rmii	= 1,
@@ -132,6 +313,18 @@
 	.num_resources	= 1,
 };
 
+static struct at91_gpio_led ek_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB1,
+		.trigger	= "heartbeat",
+	},
+	{
+		.name		= "led1",
+		.gpio		= AT91_PIN_PB2,
+		.trigger	= "timer",
+	}
+};
 
 static void __init ek_board_init(void)
 {
@@ -158,8 +351,10 @@
 #endif
 	/* NOR Flash */
 	platform_device_register(&ek_flash);
+	/* LEDs */
+	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
 	/* VGA */
-//	ek_add_device_video();
+	ek_add_device_video();
 }
 
 MACHINE_START(AT91RM9200EK, "Atmel AT91RM9200-EK")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-kb9202.c linux-2.6.22_9260/arch/arm/mach-at91/board-kb9202.c
--- linux-2.6.22/arch/arm/mach-at91/board-kb9202.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-kb9202.c	2014-08-26 16:22:54.400743873 +0800
@@ -37,6 +37,8 @@
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
 
+#include <asm/arch/at91rm9200_mc.h>
+
 #include "generic.h"
 
 
@@ -111,6 +113,48 @@
 	.partition_info	= nand_partitions,
 };
 
+
+#if defined(CONFIG_FB_S1D15605)
+#warning "Rather pass reset pin via platform_data"
+static struct resource kb9202_lcd_resources[] = {
+	[0] = {
+		.start	= AT91_CHIPSELECT_2,
+		.end	= AT91_CHIPSELECT_2 + 0x200FF,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {	/* reset pin */
+		.start	= AT91_PIN_PC22,
+		.end	= AT91_PIN_PC22,
+		.flags	= IORESOURCE_MEM
+	},
+};
+
+static struct platform_device kb9202_lcd_device = {
+	.name		= "s1d15605fb",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(kb9202_lcd_resources),
+	.resource	= kb9202_lcd_resources,
+};
+
+static void __init kb9202_add_device_lcd(void)
+{
+ 	/* In case the boot loader did not set the chip select mode and timing */
+	at91_sys_write(AT91_SMC_CSR(2),
+		AT91_SMC_WSEN | AT91_SMC_NWS_(18) | AT91_SMC_TDF_(1) | AT91_SMC_DBW_8 |
+		AT91_SMC_RWSETUP_(1) | AT91_SMC_RWHOLD_(1));
+
+	/* Backlight pin = output, off */
+	at91_set_gpio_output(AT91_PIN_PC23, 0);
+
+	/* Reset pin = output, in reset */
+	at91_set_gpio_output(AT91_PIN_PC22, 0);
+
+	platform_device_register(&kb9202_lcd_device);
+}
+#else
+static void __init kb9202_add_device_lcd(void) {}
+#endif
+
 static void __init kb9202_board_init(void)
 {
 	/* Serial */
@@ -129,6 +173,8 @@
 	at91_add_device_spi(NULL, 0);
 	/* NAND */
 	at91_add_device_nand(&kb9202_nand_data);
+	/* LCD	*/
+	kb9202_add_device_lcd();
 }
 
 MACHINE_START(KB9200, "KB920x")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-sam9260ek.c linux-2.6.22_9260/arch/arm/mach-at91/board-sam9260ek.c
--- linux-2.6.22/arch/arm/mach-at91/board-sam9260ek.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-sam9260ek.c	2014-08-26 16:23:29.794393087 +0800
@@ -24,6 +24,7 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
@@ -41,6 +42,61 @@
 
 #include "generic.h"
 
+#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
+static struct resource at91sam9260_dm9000_resource[] = {
+        [0] = {
+                .start  = AT91_CHIPSELECT_4,
+                .end    = AT91_CHIPSELECT_4 + 3,
+                .flags  = IORESOURCE_MEM
+        },
+        [1] = {
+                .start  = AT91_CHIPSELECT_4 + 0x44,
+                .end    = AT91_CHIPSELECT_4 + 0xFF,
+                .flags  = IORESOURCE_MEM
+        },
+        [2] = {
+                .start  = AT91_PIN_PC15,
+                .end    = AT91_PIN_PC15,
+                .flags  = IORESOURCE_IRQ
+        }
+};
+ 
+#include <linux/dm9000.h>
+static struct dm9000_plat_data dm9000_platdata = {
+        .flags          = DM9000_PLATF_16BITONLY,
+};
+ 
+static struct platform_device at91sam9260_dm9000_device = {
+        .name           = "dm9000",
+        .id             = 0,
+        .num_resources  = ARRAY_SIZE(at91sam9260_dm9000_resource),
+        .resource       = at91sam9260_dm9000_resource,
+        .dev            = {
+                .platform_data  = &dm9000_platdata,
+        }
+};
+ 
+static void __init ek_add_device_dm9000(void)
+{
+        /*
+         * Configure Chip-Select 2 on SMC for the DM9000.
+         * Note: These timings were calculated for MASTER_CLOCK = 100000000
+         *  according to the DM9000 timings.
+         */
+        at91_sys_write(AT91_SMC_SETUP(4), AT91_SMC_NWESETUP_(2) | AT91_SMC_NCS_WRSETUP_(0) | AT91_SMC_NRDSETUP_(2) | AT91_SMC_NCS_RDSETUP_(0));
+        at91_sys_write(AT91_SMC_PULSE(4), AT91_SMC_NWEPULSE_(4) | AT91_SMC_NCS_WRPULSE_(8) | AT91_SMC_NRDPULSE_(4) | AT91_SMC_NCS_RDPULSE_(8));
+        at91_sys_write(AT91_SMC_CYCLE(4), AT91_SMC_NWECYCLE_(16) | AT91_SMC_NRDCYCLE_(16));
+        at91_sys_write(AT91_SMC_MODE(4), AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_BAT_WRITE | AT91_SMC_DBW_16 | AT91_SMC_TDF_(1));
+ 
+        /* Configure Interrupt pin as PC15, no pull-up */
+        at91_set_gpio_input(AT91_PIN_PC15, 0);
+ 
+        /* Configure NCS4 pin as cs, pull-up */
+        at91_set_A_periph(AT91_PIN_PC8, 1);
+ 
+        platform_device_register(&at91sam9260_dm9000_device);
+}
+#endif /* CONFIG_DM9000 */
 
 /*
  * Serial port configuration.
@@ -49,8 +105,8 @@
  */
 static struct at91_uart_config __initdata ek_uart_config = {
 	.console_tty	= 0,				/* ttyS0 */
-	.nr_tty		= 3,
-	.tty_map	= { 6, 0, 1, -1, -1, -1, -1 }	/* ttyS0, ..., ttyS6 */
+	.nr_tty		= 6,
+	.tty_map	= { 6, 0, 1, 2, 3, 4 }	/* ttyS0, ..., ttyS5 */
 };
 
 static void __init ek_map_io(void)
@@ -85,6 +141,69 @@
 
 
 /*
++ * AT73C213
++ */
+#if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
+static struct atmel_at73c213_data at73c213_data;
+
+static u64 ssc_dmamask = 0xffffffffUL;
+static struct resource ssc_resource[] = {
+	[0] = {
+		.start	= AT91SAM9260_BASE_SSC,
+		.end	= AT91SAM9260_BASE_SSC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9260_ID_SSC,
+		.end	= AT91SAM9260_ID_SSC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9260_ssc_device = {
+	.name		= "atmel_ssc_at73c213",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &ssc_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &at73c213_data,
+	},
+	.resource		= ssc_resource,
+	.num_resources	= ARRAY_SIZE(ssc_resource),
+};
+void __init at91_add_device_ssc_at73c213(void)
+{
+	struct clk *at73_clk;
+	struct clk *ssc_clk;
+	struct clk *parent_clk;
+
+	/* Set SSC1 IO */
+	at91_set_A_periph(AT91_PIN_PB16, 0);		/* TK0 */
+	at91_set_A_periph(AT91_PIN_PB17, 0);		/* TF0 */
+	at91_set_A_periph(AT91_PIN_PB18, 0);		/* TD0 */
+
+	/* AT73C213 MCK Clock */
+	at91_set_B_periph(AT91_PIN_PC1, 0);		/* PCK0 */
+
+	at73_clk = clk_get(NULL, "pck0");
+	parent_clk = clk_get(NULL, "plla");
+	clk_set_parent(at73_clk, parent_clk);
+	clk_set_rate(at73_clk, 12416000);
+	clk_enable(at73_clk);
+
+	ssc_clk = clk_get(NULL, "ssc_clk");
+	clk_enable(ssc_clk);
+
+	at73c213_data.ssc_div  = 32;
+	at73c213_data.at73_mck = at73_clk;
+
+	platform_device_register(&at91sam9260_ssc_device);
+}
+#else
+	void __init at91_add_device_ssc_at73c213(void) {}
+#endif
+
+/*
  * SPI devices.
  */
 static struct spi_board_info ek_spi_devices[] = {
@@ -129,14 +248,49 @@
  */
 static struct mtd_partition __initdata ek_nand_partition[] = {
 	{
-		.name	= "Partition 1",
-		.offset	= 0,
-		.size	= 256 * 1024,
+		name:"bootstrap - 128KB",
+		offset:0,
+		size:SZ_128K
+	},
+	{
+		name:"uboot - 256KB",
+		offset:SZ_128K,
+		size:SZ_256K
+	},
+	{
+		name:"uboot env - 128KB",
+		offset:3 * SZ_128K,
+		size:SZ_128K
 	},
 	{
-		.name	= "Partition 2",
-		.offset	= 256 * 1024,
-		.size	= MTDPART_SIZ_FULL,
+		name:"uboot env swap - 128KB",
+		offset:4 * SZ_128K,
+		size:SZ_128K
+	},
+	{
+		name:"kernel - 5MB",
+		offset:5 * SZ_128K,
+		size:5 * SZ_1M
+	},
+	{
+		name:"fs - 5MB",
+		offset:5 * SZ_1M + 5 * SZ_128K,
+		size:5 * SZ_1M
+	},
+	{
+		name:"apps - 20MB",
+		offset:5 * SZ_128K + 10 * SZ_1M,
+		size:20 * SZ_1M
+	},
+	{
+		name:"info - 1MB",
+		offset:5 * SZ_128K + 30 * SZ_1M,
+		size:1 * SZ_1M
+	},
+	{
+		name:"data - 224MB",
+		offset:5 * SZ_128K + 31 * SZ_1M,
+		size:224 * SZ_1M
 	},
 };
 
@@ -167,9 +321,9 @@
 static struct at91_mmc_data __initdata ek_mmc_data = {
 	.slot_b		= 1,
 	.wire4		= 1,
-//	.det_pin	= ... not connected
-//	.wp_pin		= ... not connected
-//	.vcc_pin	= ... not connected
+	.det_pin	= AT91_PIN_PA6,
+	.wp_pin		= AT91_PIN_PA9,
+	.vcc_pin	= AT91_PIN_PB19,
 };
 
 static void __init ek_board_init(void)
@@ -190,6 +344,11 @@
 	at91_add_device_mmc(0, &ek_mmc_data);
 	/* I2C */
 	at91_add_device_i2c();
+	/* AT73C213 & SSC port */
+	//at91_add_device_ssc_at73c213();
+        /* DM9000A */
+        ek_add_device_dm9000();
+
 }
 
 MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-sam9261ek.c linux-2.6.22_9260/arch/arm/mach-at91/board-sam9261ek.c
--- linux-2.6.22/arch/arm/mach-at91/board-sam9261ek.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-sam9261ek.c	2014-08-26 16:23:12.716392520 +0800
@@ -27,6 +27,12 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/ads7846.h>
 #include <linux/dm9000.h>
+#include <linux/fb.h>
+#include <linux/clk.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/hardware.h>
 #include <asm/setup.h>
@@ -152,6 +158,69 @@
 
 
 /*
+ * AT73C213
+ */
+#if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
+static struct atmel_at73c213_data at73c213_data;
+
+static u64 ssc1_dmamask = 0xffffffffUL;
+static struct resource ssc1_resource[] = {
+	[0] = {
+		.start	= AT91SAM9261_BASE_SSC1,
+		.end	= AT91SAM9261_BASE_SSC1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9261_ID_SSC1,
+		.end	= AT91SAM9261_ID_SSC1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9261_ssc1_device = {
+	.name		= "atmel_ssc_at73c213",
+	.id			= -1,
+	.dev		= {
+				.dma_mask		= &ssc1_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &at73c213_data,
+	},
+	.resource		= ssc1_resource,
+	.num_resources	= ARRAY_SIZE(ssc1_resource),
+};
+void __init at91_add_device_ssc1_at73c213(void)
+{
+	struct clk *at73_clk;
+	struct clk *ssc_clk;
+	struct clk *parent_clk;
+
+	/* Set SSC1 IO */
+	at91_set_B_periph(AT91_PIN_PA17, 0);		/* TD1 */
+	at91_set_B_periph(AT91_PIN_PA18, 0);		/* TF1 */
+	at91_set_B_periph(AT91_PIN_PA19, 0);		/* TK1 */
+
+	/* AT73C213 MCK Clock */
+	at91_set_B_periph(AT91_PIN_PB31, 0);		/* PCK2 */
+
+	at73_clk = clk_get(NULL, "pck2");
+	parent_clk = clk_get(NULL, "plla");
+	clk_set_parent(at73_clk, parent_clk);
+	clk_set_rate(at73_clk, 12416000);
+	clk_enable(at73_clk);
+
+	ssc_clk = clk_get(NULL, "ssc1_clk");
+	clk_enable(ssc_clk);
+	
+	at73c213_data.ssc_div  = 32;  
+	at73c213_data.at73_mck = at73_clk;  
+
+	platform_device_register(&at91sam9261_ssc1_device);
+}
+#else
+	void __init at91_add_device_ssc1_at73c213(void) {}
+#endif
+
+/*
  * MCI (SD/MMC)
  */
 static struct at91_mmc_data __initdata ek_mmc_data = {
@@ -169,11 +238,11 @@
 	{
 		.name	= "Partition 1",
 		.offset	= 0,
-		.size	= 256 * 1024,
+		.size	= 64 * 1024 * 1024,
 	},
 	{
 		.name	= "Partition 2",
-		.offset	= 256 * 1024 ,
+		.offset	= 64 * 1024 * 1024,
 		.size	= MTDPART_SIZ_FULL,
 	},
 };
@@ -251,6 +320,7 @@
 		.bus_num	= 0,
 		.platform_data	= &ads_info,
 		.irq		= AT91SAM9261_ID_IRQ0,
+		.controller_data = (void *)AT91_PIN_PA28,	/* CS pin */
 	},
 #endif
 #if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
@@ -271,6 +341,127 @@
 };
 
 
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+	        .name           = "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor        = "TX09D50VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9261_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT    \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	if (on)
+		at91_set_gpio_value(AT91_PIN_PA12, 0);	/* power up */
+	else
+		at91_set_gpio_value(AT91_PIN_PA12, 1);	/* power down */
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9261_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button ek_buttons[] = {
+	{
+		.gpio		= AT91_PIN_PA27,
+		.code		= BTN_0,
+		.desc		= "Button 0",
+		.active_low	= 1,
+	},
+	{
+		.gpio		= AT91_PIN_PA26,
+		.code		= BTN_1,
+		.desc		= "Button 1",
+		.active_low	= 1,
+	},
+	{
+		.gpio		= AT91_PIN_PA25,
+		.code		= BTN_2,
+		.desc		= "Button 2",
+		.active_low	= 1,
+	},
+	{
+		.gpio		= AT91_PIN_PA24,
+		.code		= BTN_3,
+		.desc		= "Button 3",
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_platform_data ek_button_data = {
+	.buttons	= ek_buttons,
+	.nbuttons	= ARRAY_SIZE(ek_buttons),
+};
+
+static struct platform_device ek_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &ek_button_data,
+	}
+};
+
+static void __init ek_add_device_buttons(void)
+{
+	at91_set_gpio_input(AT91_PIN_PA27, 0);	/* btn0 */
+	at91_set_deglitch(AT91_PIN_PA27, 1);
+	at91_set_gpio_input(AT91_PIN_PA26, 0);	/* btn1 */
+	at91_set_deglitch(AT91_PIN_PA26, 1);
+	at91_set_gpio_input(AT91_PIN_PA25, 0);	/* btn2 */
+	at91_set_deglitch(AT91_PIN_PA25, 1);
+	at91_set_gpio_input(AT91_PIN_PA24, 0);	/* btn3 */
+	at91_set_deglitch(AT91_PIN_PA24, 1);
+
+	platform_device_register(&ek_button_device);
+}
+#else
+static void __init ek_add_device_buttons(void) {}
+#endif
+
 static void __init ek_board_init(void)
 {
 	/* Serial */
@@ -292,10 +483,16 @@
 	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
 	/* Touchscreen */
 	ek_add_device_ts();
+	/* AT73C213 & SSC1 port */
+	at91_add_device_ssc1_at73c213(); 	
 #else
 	/* MMC */
 	at91_add_device_mmc(0, &ek_mmc_data);
 #endif
+	/* LCD Controller */
+	at91_add_device_lcdc(&ek_lcdc_data);
+	/* Push Buttons */
+	ek_add_device_buttons();
 }
 
 MACHINE_START(AT91SAM9261EK, "Atmel AT91SAM9261-EK")
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/board-sam9263ek.c linux-2.6.22_9260/arch/arm/mach-at91/board-sam9263ek.c
--- linux-2.6.22/arch/arm/mach-at91/board-sam9263ek.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/board-sam9263ek.c	2014-08-26 16:22:54.416619909 +0800
@@ -26,6 +26,9 @@
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/ads7846.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/hardware.h>
 #include <asm/setup.h>
@@ -202,6 +205,65 @@
 
 
 /*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+	        .name           = "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor        = "TX09D70VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9263_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT    \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	if (on)
+		at91_set_gpio_value(AT91_PIN_PD12, 0);	/* power up */
+	else
+		at91_set_gpio_value(AT91_PIN_PD12, 1);	/* power down */
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9263_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+
+/*
  * AC97
  */
 static struct atmel_ac97_data ek_ac97_data = {
@@ -230,6 +292,8 @@
 	at91_add_device_nand(&ek_nand_data);
 	/* I2C */
 	at91_add_device_i2c();
+	/* LCD Controller */
+	at91_add_device_lcdc(&ek_lcdc_data);
 	/* AC97 */
 	at91_add_device_ac97(&ek_ac97_data);
 }
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/clock.c linux-2.6.22_9260/arch/arm/mach-at91/clock.c
--- linux-2.6.22/arch/arm/mach-at91/clock.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/clock.c	2014-08-26 16:22:54.434386747 +0800
@@ -32,6 +32,7 @@
 #include <asm/arch/cpu.h>
 
 #include "clock.h"
+#include "generic.h"
 
 
 /*
@@ -254,6 +255,23 @@
 
 /*------------------------------------------------------------------------*/
 
+#ifdef CONFIG_PM
+
+int clk_must_disable(struct clk *clk)
+{
+	if (!at91_suspend_entering_slow_clock())
+		return 0;
+
+	while (clk->parent)
+		clk = clk->parent;
+	return clk != &clk32k;
+}
+EXPORT_SYMBOL(clk_must_disable);
+
+#endif
+
+/*------------------------------------------------------------------------*/
+
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
 
 /*
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/generic.h linux-2.6.22_9260/arch/arm/mach-at91/generic.h
--- linux-2.6.22/arch/arm/mach-at91/generic.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/generic.h	2014-08-26 16:22:54.416619909 +0800
@@ -36,6 +36,7 @@
  /* Power Management */
 extern void at91_irq_suspend(void);
 extern void at91_irq_resume(void);
+extern int at91_suspend_entering_slow_clock(void);
 
  /* GPIO */
 #define AT91RM9200_PQFP		3	/* AT91RM9200 PQFP package has 3 banks */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/ics1523.c linux-2.6.22_9260/arch/arm/mach-at91/ics1523.c
--- linux-2.6.22/arch/arm/mach-at91/ics1523.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/ics1523.c	2014-08-26 16:22:54.420383350 +0800
@@ -0,0 +1,207 @@
+/*
+ * arch/arm/mach-at91rm9200/ics1523.c
+ *
+ *  Copyright (C) 2003 ATMEL Rousset
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <asm/arch/ics1523.h>
+#include <asm/arch/at91_twi.h>
+#include <asm/arch/gpio.h>
+
+/* TWI Errors */
+#define	AT91_TWI_ERROR	(AT91_TWI_NACK | AT91_TWI_UNRE | AT91_TWI_OVRE)
+
+
+static void __iomem *twi_base;
+
+#define at91_twi_read(reg)		__raw_readl(twi_base + (reg))
+#define at91_twi_write(reg, val)	__raw_writel((val), twi_base + (reg))
+
+
+/* -----------------------------------------------------------------------------
+ * Initialization of TWI CLOCK
+ * ----------------------------------------------------------------------------- */
+
+static void at91_ics1523_SetTwiClock(unsigned int mck_khz)
+{
+	int sclock;
+
+	/* Here, CKDIV = 1 and CHDIV = CLDIV  ==> CLDIV = CHDIV = 1/4*((Fmclk/FTWI) -6) */
+	sclock = (10*mck_khz / ICS_TRANSFER_RATE);
+	if (sclock % 10 >= 5)
+		sclock = (sclock /10) - 5;
+	else
+		sclock = (sclock /10)- 6;
+	sclock = (sclock + (4 - sclock %4)) >> 2;	/* div 4 */
+
+	at91_twi_write(AT91_TWI_CWGR, 0x00010000 | sclock | (sclock << 8));
+}
+
+/* -----------------------------------------------------------------------------
+ * Read a byte with TWI Interface from the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+static int at91_ics1523_ReadByte(unsigned char reg_address, unsigned char *data_in)
+{
+	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_MREAD | AT91_TWI_IADRSZ_1 | ((ICS_ADDR << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	/* Program temporizing period (300us) */
+	udelay(300);
+
+	/* Wait TXcomplete ... */
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		Status = at91_twi_read(AT91_TWI_SR);
+	}
+
+	if (Status & AT91_TWI_TXCOMP) {
+		*data_in = (unsigned char) at91_twi_read(AT91_TWI_RHR);
+		return ICS1523_ACCESS_OK;
+	}
+	else
+		return ICS1523_ACCESS_ERROR;
+}
+
+/* -----------------------------------------------------------------------------
+ * Write a byte with TWI Interface to the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+static int at91_ics1523_WriteByte(unsigned char reg_address, unsigned char data_out)
+{
+	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_IADRSZ_1 | ((ICS_ADDR << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_THR, data_out);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	/* Program temporizing period (300us) */
+	udelay(300);
+
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		if (Status & AT91_TWI_ERROR) {
+			/* If Underrun OR NACK - Start again */
+			at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+			/*  Program temporizing period (300us) */
+			udelay(300);
+		}
+		Status = at91_twi_read(AT91_TWI_SR);
+	};
+
+	if (Status & AT91_TWI_TXCOMP)
+		return ICS1523_ACCESS_OK;
+	else
+		return ICS1523_ACCESS_ERROR;
+}
+
+/* -----------------------------------------------------------------------------
+ * Initialization of the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+int at91_ics1523_init(void)
+{
+	int		nb_trial;
+	int		ack = ICS1523_ACCESS_OK;
+	unsigned int	status = 0xffffffff;
+	struct clk	*twi_clk;
+
+	/* Map in TWI peripheral */
+	twi_base = ioremap(AT91RM9200_BASE_TWI, SZ_16K);
+	if (!twi_base)
+		return -ENOMEM;
+
+	/* pins used for TWI interface */
+	at91_set_A_periph(AT91_PIN_PA25, 0);            /* TWD */
+	at91_set_multi_drive(AT91_PIN_PA25, 1);
+	at91_set_A_periph(AT91_PIN_PA26, 0);            /* TWCK */
+	at91_set_multi_drive(AT91_PIN_PA26, 1);
+
+	/* Enable the TWI clock */
+	twi_clk = clk_get(NULL, "twi_clk");
+	if (IS_ERR(twi_clk))
+		return ICS1523_ACCESS_ERROR;
+	clk_enable(twi_clk);
+
+	/* Disable interrupts */
+	at91_twi_write(AT91_TWI_IDR, -1);
+
+	/* Reset peripheral */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_SWRST);
+
+	/* Set Master mode */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);
+
+	/* Set TWI Clock Waveform Generator Register */
+	at91_ics1523_SetTwiClock(60000);     /* MCK in KHz = 60000 KHz */
+
+	/* ICS1523 Initialisation */
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) 0);
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_OE, (unsigned char) (ICS_OEF | ICS_OET2 | ICS_OETCK));
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_OD, (unsigned char) (ICS_INSEL | 0x7F));
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0);
+
+	nb_trial = 0;
+	do {
+		nb_trial++;
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) (ICS_ENDLS | ICS_ENPLS | ICS_PDEN /*| ICS_FUNCSEL*/));
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_LCR, (unsigned char) (ICS_PSD | ICS_PFD));
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_FD0, (unsigned char) 0x39) ; /* 0x7A */
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_FD1, (unsigned char) 0x00);
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_PLLR));
+
+		/* Program 1ms temporizing period */
+		mdelay(1);
+
+		at91_ics1523_ReadByte ((unsigned char) ICS_SR, (char *)&status);
+	} while (!((unsigned int) status & (unsigned int) ICS_PLLLOCK) && (nb_trial < 10));
+
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAC, (unsigned char) 0x03) ; /* 0x01 */
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_DPAR));
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0x00);
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+	
+	/* All done - cleanup */
+	iounmap(twi_base);
+	clk_disable(twi_clk);
+	clk_put(twi_clk);
+
+	return ack;
+}
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/Kconfig linux-2.6.22_9260/arch/arm/mach-at91/Kconfig
--- linux-2.6.22/arch/arm/mach-at91/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/Kconfig	2014-08-26 16:22:54.402390322 +0800
@@ -97,6 +97,12 @@
 	help
 	  Select this if you are using Sperry-Sun's KAFA board.
 
+config MACH_CHUB
+	bool "Promwad Chub board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Promwad's Chub board.
+
 endif
 
 # ----------------------------------------------------------
@@ -121,6 +127,13 @@
 	  Select this if you are using Atmel's AT91SAM9260-EK or AT91SAM9XE Evaluation Kit
 	  <http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933>
 
+config MACH_CAM60
+	bool "KwikByte CAM60 board"
+	depends on ARCH_AT91SAM9260
+	help
+	  Select this if you are using KwikByte's CAM60 board based on the Atmel AT91SAM9260.
+	  <http://www.kwikbyte.com>
+
 endif
 
 # ----------------------------------------------------------
@@ -184,6 +197,20 @@
 	  On AT91SAM926x boards both types of NAND flash can be present
 	  (8 and 16 bit data bus width).
 
+config CSB300_WAKE_SW0
+	bool "CSB300 SW0 irq0 wakeup"
+	depends on MACH_CSB337 && PM
+	help
+	  If you have a CSB300 connected to your CSB337, this lets
+	  SW0 serve as a wakeup button.  It uses IRQ0.
+
+config CSB300_WAKE_SW1
+	bool "CSB300 SW1 gpio wakeup"
+	depends on MACH_CSB337 && PM
+	help
+	  If you have a CSB300 connected to your CSB337, this lets
+	  SW1 serve as a wakeup button.  It uses GPIO.
+
 # ----------------------------------------------------------
 
 comment "AT91 Feature Selections"
@@ -194,6 +221,20 @@
 	  Select this if you need to program one or more of the PCK0..PCK3
 	  programmable clock outputs.
 
+config ATMEL_TCLIB
+	bool "Timer/Counter Library"
+	help
+	  Select this if you want a library to allocate the Timer/Counter
+	  blocks found on many Atmel processors.  This facilitates using
+	  these modules despite processor differences.
+
+config AT91_SLOW_CLOCK
+	bool "Suspend-to-RAM uses slow clock mode (EXPERIMENTAL)"
+	depends on PM && EXPERIMENTAL
+	help
+	  Select this if you wish to put the CPU into slow clock mode
+	  while in the "Suspend to RAM" state, to save more power.
+
 endmenu
 
 endif
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/Makefile linux-2.6.22_9260/arch/arm/mach-at91/Makefile
--- linux-2.6.22/arch/arm/mach-at91/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/Makefile	2014-08-26 16:22:54.425479380 +0800
@@ -8,6 +8,8 @@
 obj-		:=
 
 obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_AT91_SLOW_CLOCK)	+= pm_slowclock.o
+obj-$(CONFIG_ATMEL_TCLIB)	+= tclib.o
 
 # CPU-specific support
 obj-$(CONFIG_ARCH_AT91RM9200)	+= at91rm9200.o at91rm9200_time.o at91rm9200_devices.o
@@ -26,10 +28,12 @@
 obj-$(CONFIG_MACH_KB9200)	+= board-kb9202.o
 obj-$(CONFIG_MACH_ATEB9200)	+= board-eb9200.o
 obj-$(CONFIG_MACH_KAFA)		+= board-kafa.o
+obj-$(CONFIG_MACH_CHUB)		+= board-chub.o
 obj-$(CONFIG_MACH_PICOTUX2XX)	+= board-picotux200.o
 
 # AT91SAM9260 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9260EK) += board-sam9260ek.o
+obj-$(CONFIG_MACH_CAM60)	+= board-cam60.o
 
 # AT91SAM9261 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9261EK) += board-sam9261ek.o
@@ -51,7 +55,7 @@
 obj-$(CONFIG_LEDS) += $(led-y)
 
 # VGA support
-#obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
+obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
 
 
 ifeq ($(CONFIG_PM_DEBUG),y)
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/pm.c linux-2.6.22_9260/arch/arm/mach-at91/pm.c
--- linux-2.6.22/arch/arm/mach-at91/pm.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/pm.c	2014-08-26 16:22:54.429451305 +0800
@@ -63,6 +63,7 @@
  * Verify that all the clocks are correct before entering
  * slow-clock mode.
  */
+#warning "SAM9260 only has 3 programmable clocks."
 static int at91_pm_verify_clocks(void)
 {
 	unsigned long scsr;
@@ -103,20 +104,15 @@
 }
 
 /*
- * Call this from platform driver suspend() to see how deeply to suspend.
+ * This is called from clk_must_disable(), to see how deeply to suspend.
  * For example, some controllers (like OHCI) need one of the PLL clocks
  * in order to act as a wakeup source, and those are not available when
  * going into slow clock mode.
- *
- * REVISIT: generalize as clk_will_be_available(clk)?  Other platforms have
- * the very same problem (but not using at91 main_clk), and it'd be better
- * to add one generic API rather than lots of platform-specific ones.
  */
 int at91_suspend_entering_slow_clock(void)
 {
 	return (target_state == PM_SUSPEND_MEM);
 }
-EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 
 static void (*slow_clock)(void);
@@ -205,16 +201,23 @@
 	.enter		= at91_pm_enter,
 };
 
+#ifdef CONFIG_AT91_SLOW_CLOCK
+extern void at91rm9200_slow_clock(void);
+extern u32 at91rm9200_slow_clock_sz;
+#endif
+
 static int __init at91_pm_init(void)
 {
-	printk("AT91: Power Management\n");
-
-#ifdef CONFIG_AT91_PM_SLOW_CLOCK
-	/* REVISIT allocations of SRAM should be dynamically managed.
+#ifdef CONFIG_AT91_SLOW_CLOCK
+	/*
+	 * REVISIT allocations of SRAM should be dynamically managed.
 	 * FIQ handlers and other components will want SRAM/TCM too...
 	 */
-	slow_clock = (void *) (AT91_VA_BASE_SRAM + (3 * SZ_4K));
+	slow_clock = (void *) (AT91_IO_VIRT_BASE - AT91RM9200_SRAM_SIZE + (3 * SZ_4K));
 	memcpy(slow_clock, at91rm9200_slow_clock, at91rm9200_slow_clock_sz);
+	printk("AT91: Power Management (with slow clock mode)\n");
+#else
+	printk("AT91: Power Management\n");
 #endif
 
 	/* Disable SDRAM low-power mode.  Cannot be used with self-refresh. */
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/pm_slowclock.S linux-2.6.22_9260/arch/arm/mach-at91/pm_slowclock.S
--- linux-2.6.22/arch/arm/mach-at91/pm_slowclock.S	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/pm_slowclock.S	2014-08-26 16:22:54.431558169 +0800
@@ -0,0 +1,172 @@
+/*
+ * arch/arm/mach-at91/pm_slow_clock.S
+ *
+ *  Copyright (C) 2006 Savin Zlobec
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/hardware.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91rm9200_mc.h>
+
+#define MCKRDY_TIMEOUT		1000
+#define MOSCRDY_TIMEOUT 	1000
+#define PLLALOCK_TIMEOUT	1000
+
+	.macro wait_mckrdy
+	mov	r2, #MCKRDY_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_MCKRDY
+	beq	1b
+2:
+	.endm
+
+	.macro wait_moscrdy
+	mov	r2, #MOSCRDY_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_MOSCS
+	beq	1b
+2:
+	.endm
+
+	.macro wait_pllalock
+	mov	r2, #PLLALOCK_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_LOCKA
+	beq	1b
+2:
+	.endm
+
+	.macro wait_plladis
+	mov	r2, #PLLALOCK_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_LOCKA
+	bne	1b
+2:
+	.endm
+
+	.text
+
+ENTRY(at91rm9200_slow_clock)
+
+	ldr	r1, .at91_va_base_sys
+
+	/* Put SDRAM in self refresh mode */
+
+	b	1f
+	.align	5
+1:	mcr	p15, 0, r0, c7, c10, 4
+	mov	r2, #1
+	str	r2, [r1, #AT91_SDRAMC_SRR]
+
+	/* Save Master clock setting */
+
+	ldr	r2, [r1, #AT91_PMC_MCKR]
+	str	r2, .saved_mckr
+
+	/*
+	 * Set the Master clock source to slow clock
+	 *
+	 * First set the CSS field, wait for MCKRDY
+	 * and than set the PRES and MDIV fields.
+	 *
+	 * See eratta #2[78] for details.
+	 */
+
+	bic	r2, r2, #3
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+	mov	r2, #0
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	/* Save PLLA setting and disable it */
+
+	ldr	r2, [r1, #AT91_CKGR_PLLAR]
+	str	r2, .saved_pllar
+
+	mov	r2, #0
+	str	r2, [r1, #AT91_CKGR_PLLAR]
+
+	wait_plladis
+
+	/* Turn off the main oscillator */
+
+	ldr	r2, [r1, #AT91_CKGR_MOR]
+	bic	r2, r2, #AT91_PMC_MOSCEN
+	str	r2, [r1, #AT91_CKGR_MOR]
+
+	/* Wait for interrupt */
+
+	mcr	p15, 0, r0, c7, c0, 4
+
+	/* Turn on the main oscillator */
+
+	ldr	r2, [r1, #AT91_CKGR_MOR]
+	orr	r2, r2, #AT91_PMC_MOSCEN
+	str	r2, [r1, #AT91_CKGR_MOR]
+
+	wait_moscrdy
+
+	/* Restore PLLA setting */
+
+	ldr	r2, .saved_pllar
+	str	r2, [r1, #AT91_CKGR_PLLAR]
+
+	wait_pllalock
+
+	/*
+	 * Restore master clock setting
+	 *
+	 * First set PRES if it was not 0,
+	 * than set CSS and MDIV fields.
+	 * After every change wait for
+	 * MCKRDY.
+	 *
+	 * See eratta #2[78] for details.
+	 */
+
+	ldr	r2, .saved_mckr
+	tst	r2, #0x1C
+	beq	2f
+	and	r2, r2, #0x1C
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+2:	ldr	r2, .saved_mckr
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+	mov	pc, lr
+
+.saved_mckr:
+	.word 0
+
+.saved_pllar:
+	.word 0
+
+.at91_va_base_sys:
+	.word AT91_VA_BASE_SYS
+
+ENTRY(at91rm9200_slow_clock_sz)
+	.word .-at91rm9200_slow_clock
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/tclib.c linux-2.6.22_9260/arch/arm/mach-at91/tclib.c
--- linux-2.6.22/arch/arm/mach-at91/tclib.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/tclib.c	2014-08-26 16:22:54.426398543 +0800
@@ -0,0 +1,17 @@
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "tclib.h"
+
+static struct atmel_tcblock *blocks;
+static int nblocks;
+
+/*
+ * Called from the processor-specific init to register the TC Blocks.
+ */
+void __init atmel_tc_init(struct atmel_tcblock *tcblocks, int n)
+{
+	blocks = tcblocks;
+	nblocks = n;
+}
diff -uNrbBw linux-2.6.22/arch/arm/mach-at91/tclib.h linux-2.6.22_9260/arch/arm/mach-at91/tclib.h
--- linux-2.6.22/arch/arm/mach-at91/tclib.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/arch/arm/mach-at91/tclib.h	2014-08-26 16:22:54.426398543 +0800
@@ -0,0 +1,11 @@
+
+#define TC_PER_TCB	3
+
+struct atmel_tcblock {
+	u32 		physaddr;
+	void __iomem	*ioaddr;
+	struct clk	*clk[TC_PER_TCB];
+	int		irq[TC_PER_TCB];
+};
+
+extern void __init atmel_tc_init(struct atmel_tcblock *tcblocks, int n);
diff -uNrbBw linux-2.6.22/drivers/char/at91_spi.c linux-2.6.22_9260/drivers/char/at91_spi.c
--- linux-2.6.22/drivers/char/at91_spi.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/char/at91_spi.c	2014-08-26 16:22:54.463393410 +0800
@@ -0,0 +1,336 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/atmel_pdc.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <asm/arch/at91_spi.h>
+#include <asm/arch/board.h>
+#include <asm/arch/spi.h>
+
+#undef DEBUG_SPI
+
+static struct spi_local spi_dev[NR_SPI_DEVICES];	/* state of the SPI devices */
+static int spi_enabled = 0;
+static struct semaphore spi_lock;			/* protect access to SPI bus */
+static int current_device = -1;				/* currently selected SPI device */
+static struct clk *spi_clk;				/* SPI clock */
+static void __iomem *spi_base;				/* SPI peripheral base-address */
+
+DECLARE_COMPLETION(transfer_complete);
+
+
+#define at91_spi_read(reg)		__raw_readl(spi_base + (reg))
+#define at91_spi_write(reg, val)	__raw_writel((val), spi_base + (reg))
+
+
+/* ......................................................................... */
+
+/*
+ * Access and enable the SPI bus.
+ * This MUST be called before any transfers are performed.
+ */
+void spi_access_bus(short device)
+{
+	/* Ensure that requested device is valid */
+	if ((device < 0) || (device >= NR_SPI_DEVICES))
+		panic("at91_spi: spi_access_bus called with invalid device");
+
+	if (spi_enabled == 0) {
+		clk_enable(spi_clk);				/* Enable Peripheral clock */
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);	/* Enable SPI */
+#ifdef DEBUG_SPI
+		printk("SPI on\n");
+#endif
+	}
+	spi_enabled++;
+
+	/* Lock the SPI bus */
+	down(&spi_lock);
+	current_device = device;
+
+	/* Configure SPI bus for device */
+	at91_spi_write(AT91_SPI_MR, AT91_SPI_MSTR | AT91_SPI_MODFDIS | (spi_dev[device].pcs << 16));
+}
+
+/*
+ * Relinquish control of the SPI bus.
+ */
+void spi_release_bus(short device)
+{
+	if (device != current_device)
+		panic("at91_spi: spi_release called with invalid device");
+
+	/* Release the SPI bus */
+	current_device = -1;
+	up(&spi_lock);
+
+	spi_enabled--;
+	if (spi_enabled == 0) {
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);	/* Disable SPI */
+		clk_disable(spi_clk);				/* Disable Peripheral clock */
+#ifdef DEBUG_SPI
+		printk("SPI off\n");
+#endif
+	}
+}
+
+/*
+ * Perform a data transfer over the SPI bus
+ */
+int spi_transfer(struct spi_transfer_list* list)
+{
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	int tx_size;
+
+	if (!list)
+		panic("at91_spi: spi_transfer called with NULL transfer list");
+	if (current_device == -1)
+		panic("at91_spi: spi_transfer called without acquiring bus");
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer start [%i]\n", list->nr_transfers);
+#endif
+
+	/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+	tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+	/* Store transfer list */
+	device->xfers = list;
+	list->curr = 0;
+
+	/* Assume there must be at least one transfer */
+	device->tx = dma_map_single(NULL, list->tx[0], list->txlen[0], DMA_TO_DEVICE);
+	device->rx = dma_map_single(NULL, list->rx[0], list->rxlen[0], DMA_FROM_DEVICE);
+
+	/* Program PDC registers */
+	at91_spi_write(ATMEL_PDC_TPR, device->tx);
+	at91_spi_write(ATMEL_PDC_RPR, device->rx);
+	at91_spi_write(ATMEL_PDC_TCR, list->txlen[0] / tx_size);
+	at91_spi_write(ATMEL_PDC_RCR, list->rxlen[0] / tx_size);
+
+	/* Is there a second transfer? */
+	if (list->nr_transfers > 1) {
+		device->txnext = dma_map_single(NULL, list->tx[1], list->txlen[1], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[1], list->rxlen[1], DMA_FROM_DEVICE);
+
+		/* Program Next PDC registers */
+		at91_spi_write(ATMEL_PDC_TNPR, device->txnext);
+		at91_spi_write(ATMEL_PDC_RNPR, device->rxnext);
+		at91_spi_write(ATMEL_PDC_TNCR, list->txlen[1] / tx_size);
+		at91_spi_write(ATMEL_PDC_RNCR, list->rxlen[1] / tx_size);
+	}
+	else {
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(ATMEL_PDC_TNCR, 0);
+		at91_spi_write(ATMEL_PDC_RNCR, 0);
+	}
+
+	// TODO: If we are doing consecutive transfers (at high speed, or
+	//   small buffers), then it might be worth modifying the 'Delay between
+	//   Consecutive Transfers' in the CSR registers.
+	//   This is an issue if we cannot chain the next buffer fast enough
+	//   in the interrupt handler.
+
+	/* Enable transmitter and receiver */
+	at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN | ATMEL_PDC_TXTEN);
+
+	at91_spi_write(AT91_SPI_IER, AT91_SPI_ENDRX);		/* enable buffer complete interrupt */
+	wait_for_completion(&transfer_complete);
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer end\n");
+#endif
+
+	return 0;
+}
+
+/* ......................................................................... */
+
+/*
+ * Handle interrupts from the SPI controller.
+ */
+static irqreturn_t at91spi_interrupt(int irq, void *dev_id)
+{
+	unsigned int status;
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	struct spi_transfer_list *list = device->xfers;
+
+#ifdef DEBUG_SPI
+	printk("SPI interrupt %i\n", current_device);
+#endif
+
+	if (!list)
+		panic("at91_spi: spi_interrupt with a NULL transfer list");
+
+		status = at91_spi_read(AT91_SPI_SR) & at91_spi_read(AT91_SPI_IMR);	/* read status */
+
+	dma_unmap_single(NULL, device->tx, list->txlen[list->curr], DMA_TO_DEVICE);
+	dma_unmap_single(NULL, device->rx, list->rxlen[list->curr], DMA_FROM_DEVICE);
+
+	device->tx = device->txnext;	/* move next transfer to current transfer */
+	device->rx = device->rxnext;
+
+	list->curr = list->curr + 1;
+	if (list->curr == list->nr_transfers) {		/* all transfers complete */
+		at91_spi_write(AT91_SPI_IDR, AT91_SPI_ENDRX);		/* disable interrupt */
+
+		/* Disable transmitter and receiver */
+		at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
+
+		device->xfers = NULL;
+		complete(&transfer_complete);
+	}
+	else if (list->curr+1 == list->nr_transfers) {	/* no more next transfers */
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(ATMEL_PDC_TNCR, 0);
+		at91_spi_write(ATMEL_PDC_RNCR, 0);
+	}
+	else {
+		int i = (list->curr)+1;
+
+		/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+		int tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+		device->txnext = dma_map_single(NULL, list->tx[i], list->txlen[i], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[i], list->rxlen[i], DMA_FROM_DEVICE);
+		at91_spi_write(ATMEL_PDC_TNPR, device->txnext);
+		at91_spi_write(ATMEL_PDC_RNPR, device->rxnext);
+		at91_spi_write(ATMEL_PDC_TNCR, list->txlen[i] / tx_size);
+		at91_spi_write(ATMEL_PDC_RNCR, list->rxlen[i] / tx_size);
+	}
+	return IRQ_HANDLED;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize the SPI controller
+ */
+static int __init at91spi_probe(struct platform_device *pdev)
+{
+	int i;
+	unsigned long scbr;
+	struct resource *res;
+
+	init_MUTEX(&spi_lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	if (!request_mem_region(res->start, res->end - res->start + 1, "at91_spi"))
+		return -EBUSY;
+
+	spi_base = ioremap(res->start, res->end - res->start + 1);
+	if (!spi_base) {
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -ENOMEM;
+	}
+
+	spi_clk = clk_get(NULL, "spi_clk");
+	if (IS_ERR(spi_clk)) {
+		printk(KERN_ERR "at91_spi: no clock defined\n");
+		iounmap(spi_base);
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -ENODEV;
+	}
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SWRST);	/* software reset of SPI controller */
+
+	/*
+	 * Calculate the correct SPI baud-rate divisor.
+	 */
+	scbr = clk_get_rate(spi_clk) / (2 * DEFAULT_SPI_CLK);
+	scbr = scbr + 1;		/* round up */
+
+	printk(KERN_INFO "at91_spi: Baud rate set to %ld\n", clk_get_rate(spi_clk) / (2 * scbr));
+
+	/* Set Chip Select registers to good defaults */
+	for (i = 0; i < 4; i++) {
+		at91_spi_write(AT91_SPI_CSR(i), AT91_SPI_CPOL | AT91_SPI_BITS_8 | (16 << 16) | (scbr << 8));
+	}
+
+	at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
+
+	memset(&spi_dev, 0, sizeof(spi_dev));
+	spi_dev[0].pcs = 0xE;
+	spi_dev[1].pcs = 0xD;
+	spi_dev[2].pcs = 0xB;
+	spi_dev[3].pcs = 0x7;
+
+	if (request_irq(AT91RM9200_ID_SPI, at91spi_interrupt, 0, "spi", NULL)) {
+		clk_put(spi_clk);
+		iounmap(spi_base);
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -EBUSY;
+	}
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);		/* Enable SPI */
+
+	return 0;
+}
+
+static int __devexit at91spi_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);		/* Disable SPI */
+	clk_put(spi_clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iounmap(spi_base);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	free_irq(AT91RM9200_ID_SPI, 0);
+	return 0;
+}
+
+static struct platform_driver at91spi_driver = {
+	.probe		= at91spi_probe,
+	.remove		= __devexit_p(at91spi_remove),
+	.driver		= {
+		.name	= "at91_spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91spi_init(void)
+{
+	return platform_driver_register(&at91spi_driver);
+}
+
+static void __exit at91spi_exit(void)
+{
+	platform_driver_unregister(&at91spi_driver);
+}
+
+EXPORT_SYMBOL(spi_access_bus);
+EXPORT_SYMBOL(spi_release_bus);
+EXPORT_SYMBOL(spi_transfer);
+
+module_init(at91spi_init);
+module_exit(at91spi_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI driver for Atmel AT91RM9200")
diff -uNrbBw linux-2.6.22/drivers/char/at91_spidev.c linux-2.6.22_9260/drivers/char/at91_spidev.c
--- linux-2.6.22/drivers/char/at91_spidev.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/char/at91_spidev.c	2014-08-26 16:22:54.467391198 +0800
@@ -0,0 +1,236 @@
+/*
+ * User-space interface to the SPI bus on Atmel AT91RM9200
+ *
+ *  Copyright (C) 2003 SAN People (Pty) Ltd
+ *
+ * Based on SPI driver by Rick Bronson
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <asm/arch/spi.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+
+#undef DEBUG_SPIDEV
+
+/* ......................................................................... */
+
+/*
+ * Read or Write to SPI bus.
+ */
+static ssize_t spidev_rd_wr(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	unsigned int spi_device = (unsigned int) file->private_data;
+
+	struct mm_struct * mm;
+	struct page ** maplist;
+	struct spi_transfer_list* list;
+	int    pgcount;
+
+	unsigned int ofs, pagelen;
+	int res, i, err;
+
+	if (!count) {
+		return 0;
+	}
+
+	list = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!list) {
+		return -ENOMEM;
+	}
+
+	mm = current->mm;
+
+	pgcount = ((unsigned long)buf+count+PAGE_SIZE-1)/PAGE_SIZE - (unsigned long)buf/PAGE_SIZE;
+
+	if (pgcount >= MAX_SPI_TRANSFERS) {
+		kfree(list);
+		return -EFBIG;
+	}
+
+	maplist = kmalloc (pgcount * sizeof (struct page *), GFP_KERNEL);
+
+	if (!maplist) {
+		kfree(list);
+		return -ENOMEM;
+	}
+	flush_cache_all();
+	down_read(&mm->mmap_sem);
+	err= get_user_pages(current, mm, (unsigned long)buf, pgcount, 1, 0, maplist, NULL);
+	up_read(&mm->mmap_sem);
+
+	if (err < 0) {
+		kfree(list);
+		kfree(maplist);
+		return err;
+	}
+	pgcount = err;
+
+#ifdef DEBUG_SPIDEV
+	printk("spidev_rd_rw: %i %i\n", count, pgcount);
+#endif
+
+	/* Set default return value = transfer length */
+	res = count;
+
+	/*
+	 * At this point, the virtual area buf[0] .. buf[count-1] will have
+	 * corresponding pages mapped in the physical memory and locked until
+	 * we unmap the kiobuf.  The pages cannot be swapped out or moved
+	 * around.
+	 */
+	ofs = (unsigned long) buf & (PAGE_SIZE -1);
+	pagelen = PAGE_SIZE - ofs;
+	if (count < pagelen)
+		pagelen = count;
+
+	for (i = 0; i < pgcount; i++) {
+		flush_dcache_page(maplist[i]);
+
+		list->tx[i] = list->rx[i] = page_address(maplist[i]) + ofs;
+		list->txlen[i] = list->rxlen[i] = pagelen;
+
+#ifdef DEBUG_SPIDEV
+		printk("  %i: %x  (%i)\n", i, list->tx[i], list->txlen[i]);
+#endif
+
+		ofs = 0;	/* all subsequent transfers start at beginning of a page */
+		count = count - pagelen;
+		pagelen = (count < PAGE_SIZE) ? count : PAGE_SIZE;
+	}
+	list->nr_transfers = pgcount;
+
+	/* Perform transfer on SPI bus */
+	spi_access_bus(spi_device);
+	spi_transfer(list);
+	spi_release_bus(spi_device);
+
+	while (pgcount--) {
+		page_cache_release (maplist[pgcount]);
+	}
+	flush_cache_all();
+
+	kfree(maplist);
+	kfree(list);
+
+	return res;
+}
+
+static int spidev_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	// TODO: This interface can be used to configure the SPI bus.
+	// Configurable options could include: Speed, Clock Polarity, Clock Phase
+
+	switch(cmd) {
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * Open the SPI device
+ */
+static int spidev_open(struct inode *inode, struct file *file)
+{
+	unsigned int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	/*
+	 * 'private_data' is actually a pointer, but we overload it with the
+	 * value we want to store.
+	 */
+	file->private_data = (void *)spi_device;
+
+	return 0;
+}
+
+/*
+ * Close the SPI device
+ */
+static int spidev_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/* ......................................................................... */
+
+static struct file_operations spidev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= spidev_rd_wr,
+	.write		= (int (*) (struct file *file, const char *buf, size_t count, loff_t *offset))spidev_rd_wr,
+	.ioctl		= spidev_ioctl,
+	.open		= spidev_open,
+	.release	= spidev_close,
+};
+
+/*
+ * Install the SPI /dev interface driver
+ */
+static int __init at91_spidev_init(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+#endif
+
+	if (register_chrdev(SPI_MAJOR, "spi", &spidev_fops)) {
+		printk(KERN_ERR "at91_spidev: Unable to get major %d for SPI bus\n", SPI_MAJOR);
+		return -EIO;
+	}
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_dir("spi");
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_mk_cdev(MKDEV(SPI_MAJOR, i), S_IFCHR | S_IRUSR | S_IWUSR, "spi/%d",i);
+	}
+#endif
+	printk(KERN_INFO "AT91 SPI driver loaded\n");
+
+	return 0;
+}
+
+/*
+ * Remove the SPI /dev interface driver
+ */
+static void __exit at91_spidev_exit(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_remove("spi/%d", i);
+	}
+
+	devfs_remove("spi");
+#endif
+
+	if (unregister_chrdev(SPI_MAJOR, "spi")) {
+		printk(KERN_ERR "at91_spidev: Unable to release major %d for SPI bus\n", SPI_MAJOR);
+		return;
+	}
+}
+
+module_init(at91_spidev_init);
+module_exit(at91_spidev_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI /dev interface for Atmel AT91RM9200")
diff -uNrbBw linux-2.6.22/drivers/char/Kconfig linux-2.6.22_9260/drivers/char/Kconfig
--- linux-2.6.22/drivers/char/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/char/Kconfig	2014-08-26 16:22:54.465390911 +0800
@@ -1083,5 +1083,21 @@
 
 source "drivers/s390/char/Kconfig"
 
+config AT91_SPI
+	bool "SPI driver (legacy) for AT91RM9200 processors"
+	depends on ARCH_AT91RM9200
+	default y
+	help
+	  The SPI driver gives access to this serial bus on the AT91RM9200
+	  processor.
+
+config AT91_SPIDEV
+	bool "SPI device interface (legacy) for AT91RM9200 processors"
+	depends on ARCH_AT91RM9200 && AT91_SPI
+	default n
+	help
+	  The SPI driver gives user mode access to this serial
+	  bus on the AT91RM9200 processor.
+
 endmenu
 
diff -uNrbBw linux-2.6.22/drivers/char/keyboard.c linux-2.6.22_9260/drivers/char/keyboard.c
--- linux-2.6.22/drivers/char/keyboard.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/char/keyboard.c	2014-08-26 16:23:29.796471079 +0800
@@ -1082,7 +1082,8 @@
 
 #define HW_RAW(dev)	0
 
-#warning "Cannot generate rawmode keyboard for your architecture yet."
+//dissable useless warnning message
+//#warning "Cannot generate rawmode keyboard for your architecture yet."
 
 static int emulate_raw(struct vc_data *vc, unsigned int keycode, unsigned char up_flag)
 {
diff -uNrbBw linux-2.6.22/drivers/char/Makefile linux-2.6.22_9260/drivers/char/Makefile
--- linux-2.6.22/drivers/char/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/char/Makefile	2014-08-26 16:22:54.467391198 +0800
@@ -93,6 +93,8 @@
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_AT91_SPI)		+= at91_spi.o
+obj-$(CONFIG_AT91_SPIDEV)	+= at91_spidev.o
 
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_MWAVE)		+= mwave/
diff -uNrbBw linux-2.6.22/drivers/i2c/busses/i2c-at91.c linux-2.6.22_9260/drivers/i2c/busses/i2c-at91.c
--- linux-2.6.22/drivers/i2c/busses/i2c-at91.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/i2c/busses/i2c-at91.c	2014-08-26 16:23:29.798401412 +0800
@@ -31,8 +31,11 @@
 #include <asm/arch/board.h>
 #include <asm/arch/cpu.h>
 
-#define TWI_CLOCK		100000		/* Hz. max 400 Kbits/sec */
 
+/* Clockrate is configurable - max 400 Kbits/sec */
+static unsigned int clockrate = CONFIG_I2C_AT91_CLOCKRATE;
+module_param(clockrate, uint, 0);
+MODULE_PARM_DESC(clockrate, "The TWI clockrate");
 
 static struct clk *twi_clk;
 static void __iomem *twi_base;
@@ -44,7 +47,8 @@
 /*
  * Initialize the TWI hardware registers.
  */
-static void __devinit at91_twi_hwinit(void)
+//static void __devinit at91_twi_hwinit(void)
+static void at91_twi_hwinit(void)
 {
 	unsigned long cdiv, ckdiv;
 
@@ -53,7 +57,7 @@
 	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);	/* Set Master mode */
 
 	/* Calcuate clock dividers */
-	cdiv = (clk_get_rate(twi_clk) / (2 * TWI_CLOCK)) - 3;
+	cdiv = (clk_get_rate(twi_clk) / (2 * clockrate)) - 3;
 	cdiv = cdiv + 1;	/* round up */
 	ckdiv = 0;
 	while (cdiv > 255) {
@@ -61,15 +65,17 @@
 		cdiv = cdiv >> 1;
 	}
 
-	if (cpu_is_at91rm9200()) {			/* AT91RM9200 Errata #22 */
-		if (ckdiv > 5) {
-			printk(KERN_ERR "AT91 I2C: Invalid TWI_CLOCK value!\n");
+	if (cpu_is_at91rm9200() && (ckdiv > 5)) {	/* AT91RM9200 Errata #22 */
+		printk(KERN_ERR "AT91 I2C: Invalid TWI clockrate!\n");
 			ckdiv = 5;
-		}
+	} else if (ckdiv > 7) {
+		printk(KERN_ERR "AT91 I2C: Invalid TWI clockrate!\n");
+		ckdiv = 7;
 	}
 
 	at91_twi_write(AT91_TWI_CWGR, (ckdiv << 16) | (cdiv << 8) | cdiv);
 }
+EXPORT_SYMBOL_GPL(at91_twi_hwinit);
 
 /*
  * Poll the i2c status register until the specified bit is set.
diff -uNrbBw linux-2.6.22/drivers/i2c/busses/i2c-pca.c linux-2.6.22_9260/drivers/i2c/busses/i2c-pca.c
--- linux-2.6.22/drivers/i2c/busses/i2c-pca.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/i2c/busses/i2c-pca.c	2014-08-26 16:22:54.480388247 +0800
@@ -0,0 +1,213 @@
+/*
+ *  Platform driver for PCA9564 I2C bus controller.
+ *
+ *  (C) 2006 Andrew Victor
+ *
+ *  Based on i2c-pca-isa.c driver for PCA9564 on ISA boards
+ *    Copyright (C) 2004 Arcom Control Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-pca.h>
+
+#include <asm/io.h>
+
+#include "../algos/i2c-algo-pca.h"
+
+#define PCA_OWN_ADDRESS		0x55	/* our address for slave mode */
+#define PCA_CLOCK		I2C_PCA_CON_59kHz
+
+//#define REG_SHIFT		2
+#define REG_SHIFT		0
+
+//#define DEBUG_IO
+
+#define PCA_IO_SIZE 4
+
+static void __iomem *base_addr;
+static int irq;
+static wait_queue_head_t pca_wait;
+
+static int pca_getown(struct i2c_algo_pca_data *adap)
+{
+	return PCA_OWN_ADDRESS;
+}
+
+static int pca_getclock(struct i2c_algo_pca_data *adap)
+{
+	return PCA_CLOCK;
+}
+
+static void pca_writebyte(struct i2c_algo_pca_data *adap, int reg, int val)
+{
+#ifdef DEBUG_IO
+	static char *names[] = { "T/O", "DAT", "ADR", "CON" };
+	printk("*** write %s at %#lx <= %#04x\n", names[reg], (unsigned long) base_addr+reg, val);
+#endif
+	udelay(1);
+	outb(val, base_addr + (reg << REG_SHIFT));
+}
+
+static int pca_readbyte(struct i2c_algo_pca_data *adap, int reg)
+{
+	int res;
+
+	udelay(1);
+	res = inb(base_addr + (reg << REG_SHIFT));
+#ifdef DEBUG_IO
+	{
+		static char *names[] = { "STA", "DAT", "ADR", "CON" };
+		printk("*** read  %s => %#04x\n", names[reg], res);
+	}
+#endif
+	return res;
+}
+
+static int pca_waitforinterrupt(struct i2c_algo_pca_data *adap)
+{
+	int ret = 0;
+
+	if (irq > -1) {
+		ret = wait_event_interruptible(pca_wait,
+				pca_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI);
+	} else {
+		while ((pca_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)
+			udelay(100);
+	}
+	return ret;
+}
+
+static irqreturn_t pca_handler(int this_irq, void *dev_id)
+{
+	wake_up_interruptible(&pca_wait);
+	return IRQ_HANDLED;
+}
+
+static struct i2c_algo_pca_data pca_i2c_data = {
+	.get_own		= pca_getown,
+	.get_clock		= pca_getclock,
+	.write_byte		= pca_writebyte,
+	.read_byte		= pca_readbyte,
+	.wait_for_interrupt	= pca_waitforinterrupt,
+};
+
+static struct i2c_adapter pca_i2c_ops = {
+	.owner          = THIS_MODULE,
+	.id		= I2C_HW_A_PLAT,
+	.algo_data	= &pca_i2c_data,
+	.name		= "PCA9564",
+	.class		= I2C_CLASS_HWMON,
+};
+
+static int __devinit pca_i2c_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	init_waitqueue_head(&pca_wait);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, PCA_IO_SIZE, "PCA9564"))
+		return -ENXIO;
+
+	base_addr = ioremap(res->start, PCA_IO_SIZE);
+	if (base_addr == NULL)
+		goto out_region;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq > -1) {
+		if (request_irq(irq, pca_handler, 0, "pca9564", NULL) < 0) {
+			printk(KERN_ERR "i2c-pca: Request irq%d failed\n", irq);
+			goto out_remap;
+		}
+	}
+
+	/* set up the driverfs linkage to our parent device */
+	pca_i2c_ops.dev.parent = &pdev->dev;
+
+	if (i2c_pca_add_bus(&pca_i2c_ops) < 0) {
+		printk(KERN_ERR "i2c-pca: Failed to add i2c bus\n");
+		goto out_irq;
+	}
+
+	return 0;
+
+ out_irq:
+	if (irq > -1)
+		free_irq(irq, &pca_i2c_ops);
+
+ out_remap:
+	iounmap(base_addr);
+
+ out_region:
+	release_mem_region(res->start, PCA_IO_SIZE);
+	return -ENODEV;
+}
+
+static int __devexit pca_i2c_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	i2c_del_adapter(&pca_i2c_ops);
+
+	if (irq > 0)
+		free_irq(irq, NULL);
+
+	iounmap(base_addr);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, PCA_IO_SIZE);
+
+	return 0;
+}
+
+static struct platform_driver pca_i2c_driver = {
+	.probe		= pca_i2c_probe,
+	.remove		= __devexit_p(pca_i2c_remove),
+	.driver		= {
+		.name	= "pca9564",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pca_i2c_init(void)
+{
+	return platform_driver_register(&pca_i2c_driver);
+}
+
+static void __exit pca_i2c_exit(void)
+{
+	platform_driver_unregister(&pca_i2c_driver);
+}
+
+module_init(pca_i2c_init);
+module_exit(pca_i2c_exit);
+
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("PCA9564 platform driver");
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/drivers/i2c/busses/Kconfig linux-2.6.22_9260/drivers/i2c/busses/Kconfig
--- linux-2.6.22/drivers/i2c/busses/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/i2c/busses/Kconfig	2014-08-26 16:22:54.477385691 +0800
@@ -80,6 +80,14 @@
 	  This supports the use of the I2C interface on Atmel AT91
 	  processors.
 
+config I2C_AT91_CLOCKRATE
+	prompt "Atmel AT91 I2C/TWI clock-rate"
+	depends on I2C_AT91
+	int
+	default 100000
+	help
+	  Set the AT91 I2C/TWI clock-rate.
+
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on SOC_AU1550 || SOC_AU1200
@@ -598,6 +606,14 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-voodoo3.
 
+config I2C_PCA
+	tristate "PCA9564"
+	depends on I2C
+	select I2C_ALGOPCA
+	help
+	  This driver support the Philips PCA 9564 Parallel bus to I2C
+	  bus controller.
+
 config I2C_PCA_ISA
 	tristate "PCA9564 on an ISA bus"
 	depends on ISA
diff -uNrbBw linux-2.6.22/drivers/i2c/busses/Makefile linux-2.6.22_9260/drivers/i2c/busses/Makefile
--- linux-2.6.22/drivers/i2c/busses/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/i2c/busses/Makefile	2014-08-26 16:22:54.479388517 +0800
@@ -30,6 +30,7 @@
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
 obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
 obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
+obj-$(CONFIG_I2C_PCA)		+= i2c-pca.o
 obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
 obj-$(CONFIG_I2C_PIIX4)		+= i2c-piix4.o
 obj-$(CONFIG_I2C_PNX)		+= i2c-pnx.o
diff -uNrbBw linux-2.6.22/drivers/leds/Kconfig linux-2.6.22_9260/drivers/leds/Kconfig
--- linux-2.6.22/drivers/leds/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/leds/Kconfig	2014-08-26 16:22:54.470385207 +0800
@@ -77,6 +77,13 @@
 	  This option enables support for the Soekris net4801 and net4826 error
 	  LED.
 
+config LEDS_AT91
+	tristate "LED support using AT91 GPIOs"
+	depends on LEDS_CLASS && ARCH_AT91 && !LEDS
+	help
+	  This option enables support for LEDs connected to GPIO lines
+	  on AT91-based boards.
+
 config LEDS_WRAP
 	tristate "LED Support for the WRAP series LEDs"
 	depends on LEDS_CLASS && SCx200_GPIO
diff -uNrbBw linux-2.6.22/drivers/leds/leds-at91.c linux-2.6.22_9260/drivers/leds/leds-at91.c
--- linux-2.6.22/drivers/leds/leds-at91.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/leds/leds-at91.c	2014-08-26 16:22:54.471387868 +0800
@@ -0,0 +1,140 @@
+/*
+ * AT91 GPIO based LED driver
+ *
+ * Copyright (C) 2006 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+static LIST_HEAD(at91_led_list);	/* list of AT91 LEDs */
+
+struct at91_led {
+	struct led_classdev	cdev;
+	struct list_head	list;
+	struct at91_gpio_led	*led_data;
+};
+
+/*
+ * Change the state of the LED.
+ */
+static void at91_led_set(struct led_classdev *cdev, enum led_brightness value)
+{
+	struct at91_led	*led = container_of(cdev, struct at91_led, cdev);
+	short		active = (value == LED_OFF);
+
+	if (led->led_data->flags & 1)	/* active high/low? */
+		active = !active;
+	at91_set_gpio_value(led->led_data->gpio, active);
+}
+
+static int __devexit at91_led_remove(struct platform_device *pdev)
+{
+	struct at91_led		*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_unregister(&led->cdev);
+
+#warning "Free allocated memory"
+	// TODO: Free memory.	kfree(led);
+
+	return 0;
+}
+
+static int __init at91_led_probe(struct platform_device *pdev)
+{
+	int			status = 0;
+	struct at91_gpio_led	*pdata = pdev->dev.platform_data;
+	unsigned		nr_leds;
+	struct at91_led		*led;
+
+	if (!pdata)
+		return -ENODEV;
+
+	nr_leds = pdata->index;		/* first index stores number of LEDs */
+
+	while (nr_leds--) {
+		led = kzalloc(sizeof(struct at91_led), GFP_KERNEL);
+		if (!led) {
+			dev_err(&pdev->dev, "No memory for device\n");
+			status = -ENOMEM;
+			goto cleanup;
+		}
+		led->led_data = pdata;
+		led->cdev.name = pdata->name;
+		led->cdev.brightness_set = at91_led_set,
+		led->cdev.default_trigger = pdata->trigger;
+
+		status = led_classdev_register(&pdev->dev, &led->cdev);
+		if (status < 0) {
+			dev_err(&pdev->dev, "led_classdev_register failed - %d\n", status);
+cleanup:
+			at91_led_remove(pdev);
+			break;
+		}
+		list_add(&led->list, &at91_led_list);
+		pdata++;
+	}
+	return status;
+}
+
+#ifdef CONFIG_PM
+static int at91_led_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct at91_led	*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_suspend(&led->cdev);
+
+	return 0;
+}
+
+static int at91_led_resume(struct platform_device *dev)
+{
+	struct at91_led	*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_resume(&led->cdev);
+
+	return 0;
+}
+#else
+#define	at91_led_suspend	NULL
+#define	at91_led_resume		NULL
+#endif
+
+static struct platform_driver at91_led_driver = {
+	.probe		= at91_led_probe,
+	.remove		= __devexit_p(at91_led_remove),
+	.suspend	= at91_led_suspend,
+	.resume		= at91_led_resume,
+	.driver		= {
+		.name	= "at91_leds",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91_led_init(void)
+{
+	return platform_driver_register(&at91_led_driver);
+}
+module_init(at91_led_init);
+
+static void __exit at91_led_exit(void)
+{
+	platform_driver_unregister(&at91_led_driver);
+}
+module_exit(at91_led_exit);
+
+MODULE_DESCRIPTION("AT91 GPIO LED driver");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/drivers/leds/Makefile linux-2.6.22_9260/drivers/leds/Makefile
--- linux-2.6.22/drivers/leds/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/leds/Makefile	2014-08-26 16:22:54.472391600 +0800
@@ -16,6 +16,7 @@
 obj-$(CONFIG_LEDS_WRAP)			+= leds-wrap.o
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
+obj-$(CONFIG_LEDS_AT91)			+= leds-at91.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
diff -uNrbBw linux-2.6.22/drivers/mmc/card/block.c linux-2.6.22_9260/drivers/mmc/card/block.c
--- linux-2.6.22/drivers/mmc/card/block.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/mmc/card/block.c	2014-08-26 16:23:29.799393849 +0800
@@ -519,6 +519,12 @@
 	return 0;
 }
 
+/* modified on 08-12-04 */
+int card_state = 0;
+static DEFINE_SPINLOCK(card_state_lock);
+DECLARE_WAIT_QUEUE_HEAD(wait_if_state_changed);
+
+
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md;
@@ -545,6 +551,14 @@
 
 	mmc_set_drvdata(card, md);
 	add_disk(md->disk);
+
+        /* modified on 08-12-03 */
+        spin_lock_irq(&card_state_lock);
+        card_state = 1;
+        wake_up(&wait_if_state_changed);
+        spin_unlock_irq(&card_state_lock);
+       // printk("card_state=1\n\n");
+
 	return 0;
 
  out:
@@ -572,8 +586,17 @@
 		mmc_blk_put(md);
 	}
 	mmc_set_drvdata(card, NULL);
+        
+        spin_lock_irq(&card_state_lock);
+        card_state = 0;
+        wake_up(&wait_if_state_changed);
+        spin_unlock_irq(&card_state_lock);
+        //printk("card_state=0\n\n");
 }
 
+EXPORT_SYMBOL(card_state);
+EXPORT_SYMBOL(wait_if_state_changed);
+
 #ifdef CONFIG_PM
 static int mmc_blk_suspend(struct mmc_card *card, pm_message_t state)
 {
diff -uNrbBw linux-2.6.22/drivers/mmc/host/at91_mci.c linux-2.6.22_9260/drivers/mmc/host/at91_mci.c
--- linux-2.6.22/drivers/mmc/host/at91_mci.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/mmc/host/at91_mci.c	2014-08-26 16:23:29.800386594 +0800
@@ -1,5 +1,5 @@
 /*
- *  linux/drivers/mmc/at91_mci.c - ATMEL AT91 MCI Driver
+ *  linux/drivers/mmc/host/at91_mci.c - ATMEL AT91 MCI Driver
  *
  *  Copyright (C) 2005 Cougar Creek Computing Devices Ltd, All Rights Reserved
  *
@@ -78,8 +78,6 @@
 
 #define DRIVER_NAME "at91_mci"
 
-#undef	SUPPORT_4WIRE
-
 #define FL_SENT_COMMAND	(1 << 0)
 #define FL_SENT_STOP	(1 << 1)
 
@@ -131,7 +129,7 @@
 /*
  * Copy from sg to a dma block - used for transfers
  */
-static inline void at91mci_sg_to_dma(struct at91mci_host *host, struct mmc_data *data)
+static inline void at91_mci_sg_to_dma(struct at91mci_host *host, struct mmc_data *data)
 {
 	unsigned int len, i, size;
 	unsigned *dmabuf = host->buffer;
@@ -180,7 +178,7 @@
 /*
  * Prepare a dma read
  */
-static void at91mci_pre_dma_read(struct at91mci_host *host)
+static void at91_mci_pre_dma_read(struct at91mci_host *host)
 {
 	int i;
 	struct scatterlist *sg;
@@ -248,7 +246,7 @@
 /*
  * Handle after a dma read
  */
-static void at91mci_post_dma_read(struct at91mci_host *host)
+static void at91_mci_post_dma_read(struct at91mci_host *host)
 {
 	struct mmc_command *cmd;
 	struct mmc_data *data;
@@ -268,8 +266,6 @@
 	}
 
 	while (host->in_use_index < host->transfer_index) {
-		unsigned int *buffer;
-
 		struct scatterlist *sg;
 
 		pr_debug("finishing index %d\n", host->in_use_index);
@@ -280,29 +276,31 @@
 
 		dma_unmap_page(NULL, sg->dma_address, sg->length, DMA_FROM_DEVICE);
 
-		/* Swap the contents of the buffer */
-		buffer = kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
-		pr_debug("buffer = %p, length = %d\n", buffer, sg->length);
-
 		data->bytes_xfered += sg->length;
 
 		if (cpu_is_at91rm9200()) {	/* AT91RM9200 errata */
+			unsigned int *buffer;
 			int index;
 
+			/* Swap the contents of the buffer */
+			buffer = kmap_atomic(sg->page, KM_BIO_SRC_IRQ) + sg->offset;
+			pr_debug("buffer = %p, length = %d\n", buffer, sg->length);
+
 			for (index = 0; index < (sg->length / 4); index++)
 				buffer[index] = swab32(buffer[index]);
-		}
 
 		kunmap_atomic(buffer, KM_BIO_SRC_IRQ);
+		}
+
 		flush_dcache_page(sg->page);
 	}
 
 	/* Is there another transfer to trigger? */
 	if (host->transfer_index < data->sg_len)
-		at91mci_pre_dma_read(host);
+		at91_mci_pre_dma_read(host);
 	else {
+		at91_mci_write(host, AT91_MCI_IDR, AT91_MCI_ENDRX);
 		at91_mci_write(host, AT91_MCI_IER, AT91_MCI_RXBUFF);
-		at91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
 	}
 
 	pr_debug("post dma read done\n");
@@ -323,7 +321,6 @@
 
 	/* Now wait for cmd ready */
 	at91_mci_write(host, AT91_MCI_IDR, AT91_MCI_TXBUFE);
-	at91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);
 
 	cmd = host->cmd;
 	if (!cmd) return;
@@ -331,18 +328,53 @@
 	data = cmd->data;
 	if (!data) return;
 
+	if (cmd->data->flags & MMC_DATA_MULTI) {
+		pr_debug("multiple write : wait for BLKE...\n");
+		at91_mci_write(host, AT91_MCI_IER, AT91_MCI_BLKE);
+	} else
+		at91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);
+
 	data->bytes_xfered = host->total_length;
 }
 
+/*Handle after command sent ready*/
+static int at91_mci_handle_cmdrdy(struct at91mci_host *host)
+{
+	if (!host->cmd)
+		return 1;
+	else if (!host->cmd->data) {
+		if (host->flags & FL_SENT_STOP) {
+			/*After multi block write, we must wait for NOTBUSY*/
+			at91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);
+		} else return 1;
+	} else if (host->cmd->data->flags & MMC_DATA_WRITE) {
+		/*After sendding multi-block-write command, start DMA transfer*/
+		at91_mci_write(host, AT91_MCI_IER, AT91_MCI_TXBUFE);
+		at91_mci_write(host, AT91_MCI_IER, AT91_MCI_BLKE);
+		at91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);
+	}
+
+	/* command not completed, have to wait */
+	return 0;
+}
+
+
 /*
  * Enable the controller
  */
 static void at91_mci_enable(struct at91mci_host *host)
 {
+	unsigned int mr;
+
 	at91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIEN);
 	at91_mci_write(host, AT91_MCI_IDR, 0xffffffff);
 	at91_mci_write(host, AT91_MCI_DTOR, AT91_MCI_DTOMUL_1M | AT91_MCI_DTOCYC);
-	at91_mci_write(host, AT91_MCI_MR, AT91_MCI_PDCMODE | 0x34a);
+	mr = AT91_MCI_PDCMODE | 0x34a;
+
+	if (cpu_is_at91sam9260() || cpu_is_at91sam9263())
+		mr |= AT91_MCI_RDPROOF | AT91_MCI_WRPROOF;
+
+	at91_mci_write(host, AT91_MCI_MR, mr);
 
 	/* use Slot A or B (only one at same time) */
 	at91_mci_write(host, AT91_MCI_SDCR, host->board->slot_b);
@@ -358,9 +390,8 @@
 
 /*
  * Send a command
- * return the interrupts to enable
  */
-static unsigned int at91_mci_send_command(struct at91mci_host *host, struct mmc_command *cmd)
+static void at91_mci_send_command(struct at91mci_host *host, struct mmc_command *cmd)
 {
 	unsigned int cmdr, mr;
 	unsigned int block_length;
@@ -371,8 +402,7 @@
 
 	host->cmd = cmd;
 
-	/* Not sure if this is needed */
-#if 0
+	/* Needed for leaving busy state before CMD1 */
 	if ((at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_RTOE) && (cmd->opcode == 1)) {
 		pr_debug("Clearing timeout\n");
 		at91_mci_write(host, AT91_MCI_ARGR, 0);
@@ -382,7 +412,7 @@
 			pr_debug("Clearing: SR = %08X\n", at91_mci_read(host, AT91_MCI_SR));
 		}
 	}
-#endif
+
 	cmdr = cmd->opcode;
 
 	if (mmc_resp_type(cmd) == MMC_RSP_NONE)
@@ -398,6 +428,14 @@
 	}
 
 	if (data) {
+
+		if ( data->blksz & 0x3 ) {
+			pr_debug("Unsupported block size\n");
+			cmd->error = -EINVAL;
+			mmc_request_done(host->mmc, host->request);
+			return;
+		}
+
 		block_length = data->blksz;
 		blocks = data->blocks;
 
@@ -439,13 +477,10 @@
 		at91_mci_write(host, ATMEL_PDC_TCR, 0);
 		at91_mci_write(host, ATMEL_PDC_TNPR, 0);
 		at91_mci_write(host, ATMEL_PDC_TNCR, 0);
-
-		at91_mci_write(host, AT91_MCI_ARGR, cmd->arg);
-		at91_mci_write(host, AT91_MCI_CMDR, cmdr);
-		return AT91_MCI_CMDRDY;
-	}
-
-	mr = at91_mci_read(host, AT91_MCI_MR) & 0x7fff;	/* zero block length and PDC mode */
+		ier = AT91_MCI_CMDRDY;
+	} else {
+		/* zero block length and PDC mode */
+		mr = at91_mci_read(host, AT91_MCI_MR) & 0x7fff;
 	at91_mci_write(host, AT91_MCI_MR, mr | (block_length << 16) | AT91_MCI_PDCMODE);
 
 	/*
@@ -464,7 +499,7 @@
 			host->buffer = NULL;
 			host->total_length = 0;
 
-			at91mci_pre_dma_read(host);
+				at91_mci_pre_dma_read(host);
 			ier = AT91_MCI_ENDRX /* | AT91_MCI_RXBUFF */;
 		}
 		else {
@@ -476,13 +511,14 @@
 						  host->total_length,
 						  &host->physical_address, GFP_KERNEL);
 
-			at91mci_sg_to_dma(host, data);
+				at91_mci_sg_to_dma(host, data);
 
 			pr_debug("Transmitting %d bytes\n", host->total_length);
 
 			at91_mci_write(host, ATMEL_PDC_TPR, host->physical_address);
 			at91_mci_write(host, ATMEL_PDC_TCR, host->total_length / 4);
-			ier = AT91_MCI_TXBUFE;
+				ier = AT91_MCI_CMDRDY;
+			}
 		}
 	}
 
@@ -497,39 +533,24 @@
 	if (cmdr & AT91_MCI_TRCMD_START) {
 		if (cmdr & AT91_MCI_TRDIR)
 			at91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);
-		else
-			at91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);
 	}
-	return ier;
-}
-
-/*
- * Wait for a command to complete
- */
-static void at91mci_process_command(struct at91mci_host *host, struct mmc_command *cmd)
-{
-	unsigned int ier;
 
-	ier = at91_mci_send_command(host, cmd);
-
-	pr_debug("setting ier to %08X\n", ier);
-
-	/* Stop on errors or the required value */
+	/* Enable selected interrupts */
 	at91_mci_write(host, AT91_MCI_IER, AT91_MCI_ERRORS | ier);
 }
 
 /*
  * Process the next step in the request
  */
-static void at91mci_process_next(struct at91mci_host *host)
+static void at91_mci_process_next(struct at91mci_host *host)
 {
 	if (!(host->flags & FL_SENT_COMMAND)) {
 		host->flags |= FL_SENT_COMMAND;
-		at91mci_process_command(host, host->request->cmd);
+		at91_mci_send_command(host, host->request->cmd);
 	}
 	else if ((!(host->flags & FL_SENT_STOP)) && host->request->stop) {
 		host->flags |= FL_SENT_STOP;
-		at91mci_process_command(host, host->request->stop);
+		at91_mci_send_command(host, host->request->stop);
 	}
 	else
 		mmc_request_done(host->mmc, host->request);
@@ -538,7 +559,7 @@
 /*
  * Handle a command that has been completed
  */
-static void at91mci_completed_command(struct at91mci_host *host)
+static void at91_mci_completed_command(struct at91mci_host *host)
 {
 	struct mmc_command *cmd = host->cmd;
 	unsigned int status;
@@ -560,9 +581,7 @@
 	pr_debug("Status = %08X [%08X %08X %08X %08X]\n",
 		 status, cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
 
-	if (status & (AT91_MCI_RINDE | AT91_MCI_RDIRE | AT91_MCI_RCRCE |
-			AT91_MCI_RENDE | AT91_MCI_RTOE | AT91_MCI_DCRCE |
-			AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)) {
+	if (status & AT91_MCI_ERRORS) {
 		if ((status & AT91_MCI_RCRCE) && !(mmc_resp_type(cmd) & MMC_RSP_CRC)) {
 			cmd->error = MMC_ERR_NONE;
 		}
@@ -583,7 +602,7 @@
 	else
 		cmd->error = MMC_ERR_NONE;
 
-	at91mci_process_next(host);
+	at91_mci_process_next(host);
 }
 
 /*
@@ -595,7 +614,7 @@
 	host->request = mrq;
 	host->flags = 0;
 
-	at91mci_process_next(host);
+	at91_mci_process_next(host);
 }
 
 /*
@@ -639,14 +658,21 @@
 	at91_mci_write(host, AT91_MCI_MR, (at91_mci_read(host, AT91_MCI_MR) & ~AT91_MCI_CLKDIV) | clkdiv);
 
 	/* maybe switch power to the card */
+	/*
+	 * Add By WENJING 20090702
+	 * L350 V21 set vcc low to poweroff, high to poweron
+	 * L350 V22 set vcc high to poweroff, low to poweron
+	 */
 	if (host->board->vcc_pin) {
 		switch (ios->power_mode) {
 			case MMC_POWER_OFF:
-				at91_set_gpio_value(host->board->vcc_pin, 0);
+			      //at91_set_gpio_value(host->board->vcc_pin, 0);
+				at91_set_gpio_value(host->board->vcc_pin, 1);
 				break;
 			case MMC_POWER_UP:
 			case MMC_POWER_ON:
-				at91_set_gpio_value(host->board->vcc_pin, 1);
+			      //at91_set_gpio_value(host->board->vcc_pin, 1);
+				at91_set_gpio_value(host->board->vcc_pin, 0);
 				break;
 		}
 	}
@@ -698,29 +724,33 @@
 			at91_mci_handle_transmitted(host);
 		}
 
+		if (int_status & AT91_MCI_ENDRX) {
+			pr_debug("ENDRX\n");
+			at91_mci_post_dma_read(host);
+		}
+
 		if (int_status & AT91_MCI_RXBUFF) {
 			pr_debug("RX buffer full\n");
-			at91_mci_write(host, AT91_MCI_IER, AT91_MCI_CMDRDY);
+			at91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
+			at91_mci_write(host, AT91_MCI_IDR, AT91_MCI_RXBUFF | AT91_MCI_ENDRX);
+			completed = 1;
 		}
 
 		if (int_status & AT91_MCI_ENDTX)
 			pr_debug("Transmit has ended\n");
 
-		if (int_status & AT91_MCI_ENDRX) {
-			pr_debug("Receive has ended\n");
-			at91mci_post_dma_read(host);
-		}
-
 		if (int_status & AT91_MCI_NOTBUSY) {
 			pr_debug("Card is ready\n");
-			at91_mci_write(host, AT91_MCI_IER, AT91_MCI_CMDRDY);
+			completed = 1;
 		}
 
 		if (int_status & AT91_MCI_DTIP)
 			pr_debug("Data transfer in progress\n");
 
-		if (int_status & AT91_MCI_BLKE)
+		if (int_status & AT91_MCI_BLKE) {
 			pr_debug("Block transfer has ended\n");
+			completed = 1;
+		}
 
 		if (int_status & AT91_MCI_TXRDY)
 			pr_debug("Ready to transmit\n");
@@ -730,14 +760,14 @@
 
 		if (int_status & AT91_MCI_CMDRDY) {
 			pr_debug("Command ready\n");
-			completed = 1;
+			completed = at91_mci_handle_cmdrdy(host);
 		}
 	}
 
 	if (completed) {
 		pr_debug("Completed command\n");
 		at91_mci_write(host, AT91_MCI_IDR, 0xffffffff);
-		at91mci_completed_command(host);
+		at91_mci_completed_command(host);
 	} else
 		at91_mci_write(host, AT91_MCI_IDR, int_status);
 
@@ -819,7 +849,7 @@
 	mmc->f_min = 375000;
 	mmc->f_max = 25000000;
 	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
-	mmc->caps = MMC_CAP_BYTEBLOCK;
+	mmc->caps = MMC_CAP_MULTIWRITE;
 
 	mmc->max_blk_size = 4095;
 	mmc->max_blk_count = mmc->max_req_size;
@@ -830,11 +860,11 @@
 	host->bus_mode = 0;
 	host->board = pdev->dev.platform_data;
 	if (host->board->wire4) {
-#ifdef SUPPORT_4WIRE
+		if (cpu_is_at91sam9260() || cpu_is_at91sam9263())
 		mmc->caps |= MMC_CAP_4_BIT_DATA;
-#else
-		printk("AT91 MMC: 4 wire bus mode not supported by this driver - using 1 wire\n");
-#endif
+		else
+			printk("AT91 MMC: 4 wire bus mode not supported"
+				" - using 1 wire\n");
 	}
 
 	/*
@@ -886,8 +916,10 @@
 	/*
 	 * Add host to MMC layer
 	 */
-	if (host->board->det_pin)
+	if (host->board->det_pin) {
 		host->present = !at91_get_gpio_value(host->board->det_pin);
+		device_init_wakeup(&pdev->dev, 1);
+	}
 	else
 		host->present = -1;
 
@@ -922,7 +954,8 @@
 
 	host = mmc_priv(mmc);
 
-	if (host->present != -1) {
+	if (host->board->det_pin) {
+		device_init_wakeup(&pdev->dev, 0);
 		free_irq(host->board->det_pin, host);
 		cancel_delayed_work(&host->mmc->detect);
 	}
@@ -949,8 +982,12 @@
 static int at91_mci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct at91mci_host *host = mmc_priv(mmc);
 	int ret = 0;
 
+	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
+		enable_irq_wake(host->board->det_pin);
+
 	if (mmc)
 		ret = mmc_suspend_host(mmc, state);
 
@@ -960,8 +997,12 @@
 static int at91_mci_resume(struct platform_device *pdev)
 {
 	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct at91mci_host *host = mmc_priv(mmc);
 	int ret = 0;
 
+	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
+		disable_irq_wake(host->board->det_pin);
+
 	if (mmc)
 		ret = mmc_resume_host(mmc);
 
diff -uNrbBw linux-2.6.22/drivers/mtd/devices/at91_dataflash.c linux-2.6.22_9260/drivers/mtd/devices/at91_dataflash.c
--- linux-2.6.22/drivers/mtd/devices/at91_dataflash.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/mtd/devices/at91_dataflash.c	2014-08-26 16:22:54.450408567 +0800
@@ -0,0 +1,667 @@
+/*
+ * Atmel DataFlash driver for Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/arch/spi.h>
+
+#undef DEBUG_DATAFLASH
+
+#define DATAFLASH_MAX_DEVICES	4	/* max number of dataflash devices */
+#undef	DATAFLASH_ALWAYS_ADD_DEVICE	/* always add whole device when using partitions? */
+
+#define OP_READ_CONTINUOUS	0xE8
+#define OP_READ_PAGE		0xD2
+#define OP_READ_BUFFER1		0xD4
+#define OP_READ_BUFFER2		0xD6
+#define OP_READ_STATUS		0xD7
+
+#define OP_ERASE_PAGE		0x81
+#define OP_ERASE_BLOCK		0x50
+
+#define OP_TRANSFER_BUF1	0x53
+#define OP_TRANSFER_BUF2	0x55
+#define OP_COMPARE_BUF1		0x60
+#define OP_COMPARE_BUF2		0x61
+
+#define OP_PROGRAM_VIA_BUF1	0x82
+#define OP_PROGRAM_VIA_BUF2	0x85
+
+struct dataflash_local
+{
+	int spi;			/* SPI chip-select number */
+
+	unsigned int page_size;		/* number of bytes per page */
+	unsigned short page_offset;	/* page offset in flash address */
+};
+
+
+/* Detected DataFlash devices */
+static struct mtd_info* mtd_devices[DATAFLASH_MAX_DEVICES];
+static int nr_devices = 0;
+
+/* ......................................................................... */
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition static_partitions_2M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 528,	/* 1st sector = 32 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 6 * 32 * 8 * 528,	/* 6 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 9 sectors */
+	}
+};
+
+static struct mtd_partition static_partitions_4M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 64 * 8 * 528,	/* 1st sector = 64 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 4 * 64 * 8 * 528,	/* 4 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 11 sectors */
+	}
+};
+
+#if defined(CONFIG_MACH_KAFA)
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		name:		"romboot",
+		offset:		0,
+		size:		16 * 1056,	/* 160 Kb */
+		mask_flags:	MTD_WRITEABLE,		/* read-only */
+	},
+	{
+		name:		"uboot",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		128 * 1056,		/* 1 MB */
+	},
+	{
+		name:		"kernel",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		1024 * 1056,		/* 1 MB */
+	},
+	{
+		name:		"filesystem",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		MTDPART_SIZ_FULL,
+	}
+};
+
+#elif defined(CONFIG_MACH_MULTMDP)
+
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 12 * 1056,		/* 1st sector = 32 blocks * 8 pages * 1056 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "configuration",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 20 * 1056,
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 1520 * 1056,
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,
+	}
+};
+
+#else
+
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 1056,	/* 1st sector = 32 blocks * 8 pages * 1056 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 5 * 32 * 8 * 1056,	/* 5 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 26 sectors */
+	}
+};
+#endif
+
+static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+#endif
+
+/* ......................................................................... */
+
+/* Allocate a single SPI transfer descriptor.  We're assuming that if multiple
+   SPI transfers occur at the same time, spi_access_bus() will serialize them.
+   If this is not valid, then either (i) each dataflash 'priv' structure
+   needs it's own transfer descriptor, (ii) we lock this one, or (iii) use
+   another mechanism.   */
+static struct spi_transfer_list* spi_transfer_desc;
+
+/*
+ * Perform a SPI transfer to access the DataFlash device.
+ */
+static int do_spi_transfer(int nr, char* tx, int tx_len, char* rx, int rx_len,
+		char* txnext, int txnext_len, char* rxnext, int rxnext_len)
+{
+	struct spi_transfer_list* list = spi_transfer_desc;
+
+	list->tx[0] = tx;	list->txlen[0] = tx_len;
+	list->rx[0] = rx;	list->rxlen[0] = rx_len;
+
+	list->tx[1] = txnext;	list->txlen[1] = txnext_len;
+	list->rx[1] = rxnext;	list->rxlen[1] = rxnext_len;
+
+	list->nr_transfers = nr;
+
+	return spi_transfer(list);
+}
+
+/* ......................................................................... */
+
+/*
+ * Poll the DataFlash device until it is READY.
+ */
+static void at91_dataflash_waitready(void)
+{
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return;
+
+	do {
+		command[0] = OP_READ_STATUS;
+		command[1] = 0;
+
+		do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	} while ((command[1] & 0x80) == 0);
+
+	kfree(command);
+}
+
+/*
+ * Return the status of the DataFlash device.
+ */
+static unsigned short at91_dataflash_status(void)
+{
+	unsigned short status;
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return 0;
+
+	command[0] = OP_READ_STATUS;
+	command[1] = 0;
+
+	do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	status = command[1];
+
+	kfree(command);
+	return status;
+}
+
+/* ......................................................................... */
+
+/*
+ * Erase blocks of flash.
+ */
+static int at91_dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_erase: addr=%i len=%i\n", instr->addr, instr->len);
+#endif
+
+	/* Sanity checks */
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+	if ((instr->len % mtd->erasesize != 0) || (instr->len % priv->page_size != 0))
+		return -EINVAL;
+	if ((instr->addr % priv->page_size) != 0)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	while (instr->len > 0) {
+		/* Calculate flash page address */
+		pageaddr = (instr->addr / priv->page_size) << priv->page_offset;
+
+		command[0] = OP_ERASE_PAGE;
+		command[1] = (pageaddr & 0x00FF0000) >> 16;
+		command[2] = (pageaddr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("ERASE: (%x) %x %x %x [%i]\n", command[0], command[1], command[2], command[3], pageaddr);
+#endif
+
+		/* Send command to SPI device */
+		spi_access_bus(priv->spi);
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+
+		at91_dataflash_waitready();		/* poll status until ready */
+		spi_release_bus(priv->spi);
+
+		instr->addr += priv->page_size;		/* next page */
+		instr->len -= priv->page_size;
+	}
+
+	kfree(command);
+
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+/*
+ * Read from the DataFlash device.
+ *   from   : Start offset in flash device
+ *   len    : Amount to read
+ *   retlen : About of data actually read
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int addr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_read: %lli .. %lli\n", from, from+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (from + len > mtd->size)
+		return -EINVAL;
+
+	/* Calculate flash page/byte address */
+	addr = (((unsigned)from / priv->page_size) << priv->page_offset) + ((unsigned)from % priv->page_size);
+
+	command = kmalloc(8, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	command[0] = OP_READ_CONTINUOUS;
+	command[1] = (addr & 0x00FF0000) >> 16;
+	command[2] = (addr & 0x0000FF00) >> 8;
+	command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+	printk("READ: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+
+	/* Send command to SPI device */
+	spi_access_bus(priv->spi);
+	do_spi_transfer(2, command, 8, command, 8, buf, len, buf, len);
+	spi_release_bus(priv->spi);
+
+	*retlen = len;
+	kfree(command);
+	return 0;
+}
+
+/*
+ * Write to the DataFlash device.
+ *   to     : Start offset in flash device
+ *   len    : Amount to write
+ *   retlen : Amount of data actually written
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr, addr, offset, writelen;
+	size_t remaining;
+	u_char *writebuf;
+	unsigned short status;
+	int res = 0;
+	char* command;
+	char* tmpbuf = NULL;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_write: %lli .. %lli\n", to, to+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (to + len > mtd->size)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	pageaddr = ((unsigned)to / priv->page_size);
+	offset = ((unsigned)to % priv->page_size);
+	if (offset + len > priv->page_size)
+		writelen = priv->page_size - offset;
+	else
+		writelen = len;
+	writebuf = (u_char *)buf;
+	remaining = len;
+
+	/* Allocate temporary buffer */
+	tmpbuf = kmalloc(priv->page_size, GFP_KERNEL);
+	if (!tmpbuf) {
+		kfree(command);
+		return -ENOMEM;
+	}
+
+	/* Gain access to the SPI bus */
+	spi_access_bus(priv->spi);
+
+	while (remaining > 0) {
+#ifdef DEBUG_DATAFLASH
+		printk("write @ %i:%i len=%i\n", pageaddr, offset, writelen);
+#endif
+
+		/* (1) Transfer to Buffer1 */
+		if (writelen != priv->page_size) {
+			addr = pageaddr << priv->page_offset;
+			command[0] = OP_TRANSFER_BUF1;
+			command[1] = (addr & 0x00FF0000) >> 16;
+			command[2] = (addr & 0x0000FF00) >> 8;
+			command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+			printk("TRANSFER: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+			do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+			at91_dataflash_waitready();
+		}
+
+		/* (2) Program via Buffer1 */
+		addr = (pageaddr << priv->page_offset) + offset;
+		command[0] = OP_PROGRAM_VIA_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+		printk("PROGRAM: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(2, command, 4, command, 4, writebuf, writelen, tmpbuf, writelen);
+		at91_dataflash_waitready();
+
+		/* (3) Compare to Buffer1 */
+		addr = pageaddr << priv->page_offset;
+		command[0] = OP_COMPARE_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("COMPARE: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+		at91_dataflash_waitready();
+
+		/* Get result of the compare operation */
+		status = at91_dataflash_status();
+		if ((status & 0x40) == 1) {
+			printk("at91_dataflash: Write error on page %i\n", pageaddr);
+			remaining = 0;
+			res = -EIO;
+		}
+
+		remaining = remaining - writelen;
+		pageaddr++;
+		offset = 0;
+		writebuf += writelen;
+		*retlen += writelen;
+
+		if (remaining > priv->page_size)
+			writelen = priv->page_size;
+		else
+			writelen = remaining;
+	}
+
+	/* Release SPI bus */
+	spi_release_bus(priv->spi);
+
+	kfree(tmpbuf);
+	kfree(command);
+	return res;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize and register DataFlash device with MTD subsystem.
+ */
+static int __init add_dataflash(int channel, char *name, int IDsize,
+		int nr_pages, int pagesize, int pageoffset)
+{
+	struct mtd_info *device;
+	struct dataflash_local *priv;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *mtd_parts = 0;
+	int mtd_parts_nr = 0;
+#endif
+
+	if (nr_devices >= DATAFLASH_MAX_DEVICES) {
+		printk(KERN_ERR "at91_dataflash: Too many devices detected\n");
+		return 0;
+	}
+
+	device = kmalloc(sizeof(struct mtd_info) + strlen(name) + 8, GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+	memset(device, 0, sizeof(struct mtd_info));
+
+	device->name = (char *)&device[1];
+	sprintf(device->name, "%s.spi%d", name, channel);
+	device->size = nr_pages * pagesize;
+	device->erasesize = pagesize;
+	device->writesize = pagesize;
+	device->owner = THIS_MODULE;
+	device->type = MTD_DATAFLASH;
+	device->flags = MTD_WRITEABLE;
+	device->erase = at91_dataflash_erase;
+	device->read = at91_dataflash_read;
+	device->write = at91_dataflash_write;
+
+	priv = (struct dataflash_local *) kmalloc(sizeof(struct dataflash_local), GFP_KERNEL);
+	if (!priv) {
+		kfree(device);
+		return -ENOMEM;
+	}
+	memset(priv, 0, sizeof(struct dataflash_local));
+
+	priv->spi = channel;
+	priv->page_size = pagesize;
+	priv->page_offset = pageoffset;
+	device->priv = priv;
+
+	mtd_devices[nr_devices] = device;
+	nr_devices++;
+	printk("at91_dataflash: %s detected [spi%i] (%i bytes)\n", name, channel, device->size);
+
+#ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nr = parse_mtd_partitions(device, part_probes, &mtd_parts, 0);
+#endif
+	if (mtd_parts_nr <= 0) {
+		switch (IDsize) {
+			case SZ_2M:
+				mtd_parts = static_partitions_2M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_2M);
+				break;
+			case SZ_4M:
+				mtd_parts = static_partitions_4M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_4M);
+				break;
+			case SZ_8M:
+				mtd_parts = static_partitions_8M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_8M);
+				break;
+		}
+	}
+
+	if (mtd_parts_nr > 0) {
+#ifdef DATAFLASH_ALWAYS_ADD_DEVICE
+		add_mtd_device(device);
+#endif
+		return add_mtd_partitions(device, mtd_parts, mtd_parts_nr);
+	}
+#endif
+	return add_mtd_device(device);		/* add whole device */
+}
+
+/*
+ * Detect and initialize DataFlash device connected to specified SPI channel.
+ *
+ *   Device            Density         ID code                 Nr Pages        Page Size       Page offset
+ *   AT45DB011B        1Mbit   (128K)  xx0011xx (0x0c)         512             264             9
+ *   AT45DB021B        2Mbit   (256K)  xx0101xx (0x14)         1025            264             9
+ *   AT45DB041B        4Mbit   (512K)  xx0111xx (0x1c)         2048            264             9
+ *   AT45DB081B        8Mbit   (1M)    xx1001xx (0x24)         4096            264             9
+ *   AT45DB0161B       16Mbit  (2M)    xx1011xx (0x2c)         4096            528             10
+ *   AT45DB0321B       32Mbit  (4M)    xx1101xx (0x34)         8192            528             10
+ *   AT45DB0642        64Mbit  (8M)    xx1111xx (0x3c)         8192            1056            11
+ *   AT45DB1282        128Mbit (16M)   xx0100xx (0x10)         16384           1056            11
+ */
+static int __init at91_dataflash_detect(int channel)
+{
+	int res = 0;
+	unsigned short status;
+
+	spi_access_bus(channel);
+	status = at91_dataflash_status();
+	spi_release_bus(channel);
+	if (status != 0xff) {			/* no dataflash device there */
+		switch (status & 0x3c) {
+			case 0x0c:	/* 0 0 1 1 */
+				res = add_dataflash(channel, "AT45DB011B", SZ_128K, 512, 264, 9);
+				break;
+			case 0x14:	/* 0 1 0 1 */
+				res = add_dataflash(channel, "AT45DB021B", SZ_256K, 1025, 264, 9);
+				break;
+			case 0x1c:	/* 0 1 1 1 */
+				res = add_dataflash(channel, "AT45DB041B", SZ_512K, 2048, 264, 9);
+				break;
+			case 0x24:	/* 1 0 0 1 */
+				res = add_dataflash(channel, "AT45DB081B", SZ_1M, 4096, 264, 9);
+				break;
+			case 0x2c:	/* 1 0 1 1 */
+				res = add_dataflash(channel, "AT45DB161B", SZ_2M, 4096, 528, 10);
+				break;
+			case 0x34:	/* 1 1 0 1 */
+				res = add_dataflash(channel, "AT45DB321B", SZ_4M, 8192, 528, 10);
+				break;
+			case 0x3c:	/* 1 1 1 1 */
+				res = add_dataflash(channel, "AT45DB642", SZ_8M, 8192, 1056, 11);
+				break;
+// Currently unsupported since Atmel removed the "Main Memory Program via Buffer" commands.
+//			case 0x10:	/* 0 1 0 0 */
+//				res = add_dataflash(channel, "AT45DB1282", SZ_16M, 16384, 1056, 11);
+//				break;
+			default:
+				printk(KERN_ERR "at91_dataflash: Unknown device (%x)\n", status & 0x3c);
+		}
+	}
+
+	return res;
+}
+
+static int __init at91_dataflash_init(void)
+{
+	spi_transfer_desc = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!spi_transfer_desc)
+		return -ENOMEM;
+
+	/* DataFlash (SPI chip select 0) */
+	at91_dataflash_detect(0);
+
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	/* DataFlash card (SPI chip select 3) */
+	at91_dataflash_detect(3);
+#endif
+
+	return 0;
+}
+
+static void __exit at91_dataflash_exit(void)
+{
+	int i;
+
+	for (i = 0; i < DATAFLASH_MAX_DEVICES; i++) {
+		if (mtd_devices[i]) {
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(mtd_devices[i]);
+#else
+			del_mtd_device(mtd_devices[i]);
+#endif
+			kfree(mtd_devices[i]->priv);
+			kfree(mtd_devices[i]);
+		}
+	}
+	nr_devices = 0;
+	kfree(spi_transfer_desc);
+}
+
+
+module_init(at91_dataflash_init);
+module_exit(at91_dataflash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("DataFlash driver for Atmel AT91RM9200");
diff -uNrbBw linux-2.6.22/drivers/mtd/devices/Kconfig linux-2.6.22_9260/drivers/mtd/devices/Kconfig
--- linux-2.6.22/drivers/mtd/devices/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/mtd/devices/Kconfig	2014-08-26 16:22:54.448390841 +0800
@@ -269,5 +269,11 @@
 	  LinuxBIOS or if you need to recover a DiskOnChip Millennium on which
 	  you have managed to wipe the first block.
 
-endmenu
+config MTD_AT91_DATAFLASH
+	tristate "AT91RM9200 DataFlash AT45DBxxx (legacy driver)"
+	depends on MTD && ARCH_AT91RM9200 && AT91_SPI
+	help
+	  This enables access to the DataFlash (AT45DBxxx) on the AT91RM9200.
+	  If you have such a board, say 'Y'.
 
+endmenu
diff -uNrbBw linux-2.6.22/drivers/mtd/devices/Makefile linux-2.6.22_9260/drivers/mtd/devices/Makefile
--- linux-2.6.22/drivers/mtd/devices/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/mtd/devices/Makefile	2014-08-26 16:22:54.450408567 +0800
@@ -18,3 +18,4 @@
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_DATAFLASH26)	+= at91_dataflash26.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_AT91_DATAFLASH)+= at91_dataflash.o
diff -uNrbBw linux-2.6.22/drivers/net/arm/at91_ether.c linux-2.6.22_9260/drivers/net/arm/at91_ether.c
--- linux-2.6.22/drivers/net/arm/at91_ether.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/net/arm/at91_ether.c	2014-08-26 16:23:29.801391163 +0800
@@ -330,6 +330,15 @@
 		read_phy(lp->phy_address, MII_DSINTR_REG, &dsintr);
 		dsintr = dsintr | 0xf00;			/* set bits 8..11 */
 		write_phy(lp->phy_address, MII_DSINTR_REG, dsintr);
+		
+		read_phy(lp->phy_address, MII_DBMCR_REG,  &dsintr);    /* add by zxw */
+		dsintr = dsintr | 0x800;                        /* set bits 11,Power Down add by zxw*/
+		write_phy(lp->phy_address, MII_DBMCR_REG, dsintr);/* add by zxw */
+	//	printk("Function void disable_phyirq is called!\n");
+
+		read_phy(lp->phy_address, MII_DSCR2_REG,  &dsintr);    /* add by zxw */
+		dsintr = dsintr | 0x10;                        /* set bits 4,Disable auto MDI/MDIX add by zxw */
+		write_phy(lp->phy_address, MII_DSCR2_REG, dsintr);/* add by zxw */
 	}
 	else if (lp->phy_type == MII_LXT971A_ID) {	/* for Intel PHY */
 		read_phy(lp->phy_address, MII_ISINTE_REG, &dsintr);
@@ -894,6 +903,7 @@
 			skb_reserve(skb, 2);
 			memcpy(skb_put(skb, pktlen), p_recv, pktlen);
 
+			skb->dev = dev;
 			skb->protocol = eth_type_trans(skb, dev);
 			dev->last_rx = jiffies;
 			lp->stats.rx_bytes += pktlen;
@@ -978,14 +988,22 @@
 	struct net_device *dev;
 	struct at91_private *lp;
 	unsigned int val;
-	int res;
+	struct resource *res;
+	int ret;
 
 	dev = alloc_etherdev(sizeof(struct at91_private));
 	if (!dev)
 		return -ENOMEM;
 
-	dev->base_addr = AT91_VA_BASE_EMAC;
-	dev->irq = AT91RM9200_ID_EMAC;
+	/* Get I/O base address and IRQ */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		free_netdev(dev);
+		return -ENODEV;
+	}
+	dev->base_addr = res->start;
+	dev->irq = platform_get_irq(pdev, 0);
+
 	SET_MODULE_OWNER(dev);
 
 	/* Install the interrupt handler */
@@ -1058,12 +1076,12 @@
 	lp->phy_address = phy_address;	/* MDI address of PHY */
 
 	/* Register the network interface */
-	res = register_netdev(dev);
-	if (res) {
+	ret = register_netdev(dev);
+	if (ret) {
 		free_irq(dev->irq, dev);
 		free_netdev(dev);
 		dma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);
-		return res;
+		return ret;
 	}
 
 	/* Determine current link speed */
diff -uNrbBw linux-2.6.22/drivers/net/Kconfig linux-2.6.22_9260/drivers/net/Kconfig
--- linux-2.6.22/drivers/net/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/net/Kconfig	2014-08-26 16:23:12.730385734 +0800
@@ -199,6 +199,12 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config MACB_TX_SRAM
+	bool "Use internal SRAM for EMAC (Ethernet) transmit buffers"
+	depends on (ARCH_AT91SAM9263 || ARCH_AT91SAM9260) && MACB
+	help
+	  Select this if you are using internal SRAM for EMAC transmit buffers.
+
 source "drivers/net/arm/Kconfig"
 
 config MACE
diff -uNrbBw linux-2.6.22/drivers/net/macb.c linux-2.6.22_9260/drivers/net/macb.c
--- linux-2.6.22/drivers/net/macb.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/net/macb.c	2014-08-26 16:23:29.803406046 +0800
@@ -24,9 +24,17 @@
 #include <linux/platform_device.h>
 
 #include <asm/arch/board.h>
+/* modified on 09-04-21 */
+#include <asm/arch/gpio.h>
+#include <asm/arch-at91/hardware.h>
+#include <asm/io.h>
 
 #include "macb.h"
 
+/* modified on 09-04-21 */
+#define SIM_SLOT_1              AT91_PIN_PC6
+#define SIM_SLOT_2              AT91_PIN_PC7
+
 #define RX_BUFFER_SIZE		128
 #define RX_RING_SIZE		512
 #define RX_RING_BYTES		(sizeof(struct dma_desc) * RX_RING_SIZE)
@@ -34,22 +42,26 @@
 /* Make the IP header word-aligned (the ethernet header is 14 bytes) */
 #define RX_OFFSET		2
 
-#define TX_RING_SIZE		128
-#define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
-#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
+#define TX_MAX_PKT_SIZE		1536
+#define TX_DEFAULT_RING_SIZE	128
+
+#define DEF_TX_RING_PENDING(bp)	((bp)->tx_ring_size - 1)
+
+#define TX_RING_BYTES(bp)	(sizeof(struct dma_desc) * (bp)->tx_ring_size)
 
 #define TX_RING_GAP(bp)						\
-	(TX_RING_SIZE - (bp)->tx_pending)
+	((bp)->tx_ring_size - (bp)->tx_pending)
+
 #define TX_BUFFS_AVAIL(bp)					\
 	(((bp)->tx_tail <= (bp)->tx_head) ?			\
 	 (bp)->tx_tail + (bp)->tx_pending - (bp)->tx_head :	\
 	 (bp)->tx_tail - (bp)->tx_head - TX_RING_GAP(bp))
-#define NEXT_TX(n)		(((n) + 1) & (TX_RING_SIZE - 1))
 
-#define NEXT_RX(n)		(((n) + 1) & (RX_RING_SIZE - 1))
+#define NEXT_TX(bp, n)		(((n) + 1) % ((bp)->tx_ring_size))
+#define NEXT_RX(n)		(((n) + 1) % (RX_RING_SIZE))
 
 /* minimum number of free TX descriptors before waking up TX process */
-#define MACB_TX_WAKEUP_THRESH	(TX_RING_SIZE / 4)
+#define MACB_TX_WAKEUP_THRESH(bp)	((bp)->tx_ring_size / 4)
 
 #define MACB_RX_INT_FLAGS	(MACB_BIT(RCOMP) | MACB_BIT(RXUBR)	\
 				 | MACB_BIT(ISR_ROVR))
@@ -198,12 +210,36 @@
 	spin_unlock_irq(&bp->lock);
 }
 
+
+/* modified on 09-04-21 */
+int eth1_link_state = 0;
+static DEFINE_SPINLOCK(eth1_state_lock);
+extern wait_queue_head_t wait_if_state_changed;
+int sim1_state = 0;
+int sim2_state = 0;
+static DEFINE_SPINLOCK(sim_state_lock);
+
 static void macb_check_media(struct macb *bp, int ok_to_print, int init_media)
 {
 	struct mii_if_info *mii = &bp->mii;
 	unsigned int old_carrier, new_carrier;
 	int advertise, lpa, media, duplex;
 
+        /* modified on 09-04-21 */
+        if (sim1_state != (!at91_get_gpio_value(SIM_SLOT_1))) {
+            spin_lock_irq(&sim_state_lock);
+            sim1_state = (!at91_get_gpio_value(SIM_SLOT_1));
+            wake_up(&wait_if_state_changed);
+            spin_unlock_irq(&sim_state_lock);
+        }
+
+        if (sim2_state != (!at91_get_gpio_value(SIM_SLOT_2))) {
+            spin_lock_irq(&sim_state_lock);
+            sim2_state = (!at91_get_gpio_value(SIM_SLOT_2));
+            wake_up(&wait_if_state_changed);
+            spin_unlock_irq(&sim_state_lock);
+        }
+
 	/* if forced media, go no further */
 	if (mii->force_media)
 		return;
@@ -220,6 +256,14 @@
 	if (!new_carrier) {
 		netif_carrier_off(mii->dev);
 		printk(KERN_INFO "%s: link down\n", mii->dev->name);
+                /* modified on 08-12-04 */
+                if (NULL!=strstr(mii->dev->name, "eth1")) {
+                    spin_lock_irq(&eth1_state_lock);
+                    eth1_link_state = 0;
+                    wake_up(&wait_if_state_changed);
+                    spin_unlock_irq(&eth1_state_lock);
+                }
+
 		return;
 	}
 
@@ -247,12 +291,26 @@
 		       media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? "100" : "10",
 		       duplex ? "full" : "half", lpa);
 
+        /* modified on 08-12-04 */
+        if (NULL!=strstr(mii->dev->name, "eth1")) {
+            spin_lock_irq(&eth1_state_lock);
+            eth1_link_state = 1;
+            wake_up(&wait_if_state_changed);
+            spin_unlock_irq(&eth1_state_lock);
+        }
+
 	mii->full_duplex = duplex;
 
 	/* Let the MAC know about the new link state */
 	macb_set_media(bp, media);
 }
 
+/* modified on 09-04-21 */
+EXPORT_SYMBOL(eth1_link_state);
+EXPORT_SYMBOL(sim1_state);
+EXPORT_SYMBOL(sim2_state);
+
+
 static void macb_update_stats(struct macb *bp)
 {
 	u32 __iomem *reg = bp->regs + MACB_PFR;
@@ -302,7 +360,7 @@
 		return;
 
 	head = bp->tx_head;
-	for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {
+	for (tail = bp->tx_tail; tail != head; tail = NEXT_TX(bp, tail)) {
 		struct ring_info *rp = &bp->tx_skb[tail];
 		struct sk_buff *skb = rp->skb;
 		u32 bufstat;
@@ -327,7 +385,7 @@
 
 	bp->tx_tail = tail;
 	if (netif_queue_stopped(bp->dev) &&
-	    TX_BUFFS_AVAIL(bp) > MACB_TX_WAKEUP_THRESH)
+	    TX_BUFFS_AVAIL(bp) > MACB_TX_WAKEUP_THRESH(bp))
 		netif_wake_queue(bp->dev);
 }
 
@@ -357,6 +415,7 @@
 	}
 
 	skb_reserve(skb, RX_OFFSET);
+	skb->dev = bp->dev;
 	skb->ip_summed = CHECKSUM_NONE;
 	skb_put(skb, len);
 
@@ -601,8 +660,17 @@
 
 	entry = bp->tx_head;
 	dev_dbg(&bp->pdev->dev, "Allocated ring entry %u\n", entry);
+
+	if (bp->smem_start) {
+		mapping = bp->tx_ring[entry].addr;
+		memcpy(bp->tx_buffers + entry * TX_MAX_PKT_SIZE, \
+			skb->data, len);
+	} else {
 	mapping = dma_map_single(&bp->pdev->dev, skb->data,
 				 len, DMA_TO_DEVICE);
+		bp->tx_ring[entry].addr = mapping;
+	}
+
 	bp->tx_skb[entry].skb = skb;
 	bp->tx_skb[entry].mapping = mapping;
 	dev_dbg(&bp->pdev->dev, "Mapped skb data %p to DMA addr %08lx\n",
@@ -610,14 +678,13 @@
 
 	ctrl = MACB_BF(TX_FRMLEN, len);
 	ctrl |= MACB_BIT(TX_LAST);
-	if (entry == (TX_RING_SIZE - 1))
+	if (entry == (bp->tx_ring_size - 1))
 		ctrl |= MACB_BIT(TX_WRAP);
 
-	bp->tx_ring[entry].addr = mapping;
 	bp->tx_ring[entry].ctrl = ctrl;
 	wmb();
 
-	entry = NEXT_TX(entry);
+	entry = NEXT_TX(bp, entry);
 	bp->tx_head = entry;
 
 	macb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(TSTART));
@@ -644,7 +711,8 @@
 		bp->rx_ring = NULL;
 	}
 	if (bp->tx_ring) {
-		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
+		if (!bp->smem_start)
+			dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES(bp),
 				  bp->tx_ring, bp->tx_ring_dma);
 		bp->tx_ring = NULL;
 	}
@@ -654,13 +722,16 @@
 				  bp->rx_buffers, bp->rx_buffers_dma);
 		bp->rx_buffers = NULL;
 	}
+
+	if (bp->smem_start && bp->tx_ring_dma)
+		release_mem_region(bp->tx_ring_dma, bp->smem_size);
 }
 
 static int macb_alloc_consistent(struct macb *bp)
 {
 	int size;
 
-	size = TX_RING_SIZE * sizeof(struct ring_info);
+	size = bp->tx_ring_size * sizeof(struct ring_info);
 	bp->tx_skb = kmalloc(size, GFP_KERNEL);
 	if (!bp->tx_skb)
 		goto out_err;
@@ -674,14 +745,30 @@
 		"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->rx_ring_dma, bp->rx_ring);
 
-	size = TX_RING_BYTES;
-	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
+	if (bp->smem_start) {
+		if (request_mem_region(bp->smem_start,  \
+			bp->smem_size, "macb")) {
+			bp->tx_ring_dma = bp->smem_start;
+		}
+		bp->tx_ring = ioremap(bp->tx_ring_dma, bp->smem_size);
+		if (bp->tx_ring) {
+			bp->tx_buffers_dma = bp->tx_ring_dma + \
+			TX_RING_BYTES(bp);
+			bp->tx_buffers = (char *) bp->tx_ring + \
+			TX_RING_BYTES(bp);
+		}
+	}
+
+	if (!bp->tx_ring) {
+		size = TX_RING_BYTES(bp);
+	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size, \
 					 &bp->tx_ring_dma, GFP_KERNEL);
 	if (!bp->tx_ring)
 		goto out_err;
 	dev_dbg(&bp->pdev->dev,
 		"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->tx_ring_dma, bp->tx_ring);
+	}
 
 	size = RX_RING_SIZE * RX_BUFFER_SIZE;
 	bp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,
@@ -712,12 +799,16 @@
 	}
 	bp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);
 
-	for (i = 0; i < TX_RING_SIZE; i++) {
-		bp->tx_ring[i].addr = 0;
+	for (i = 0; i < bp->tx_ring_size; i++) {
+		bp->tx_ring[i].addr = (bp->smem_start) ? \
+			bp->tx_buffers_dma + i * TX_MAX_PKT_SIZE : 0;
 		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
+
+		bp->tx_ring[i].addr = (u32) (bp->tx_buffers_dma + \
+					(i * TX_MAX_PKT_SIZE));
 	}
-	bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
+	bp->tx_ring[bp->tx_ring_size - 1].ctrl |= MACB_BIT(TX_WRAP);
 	bp->rx_tail = bp->tx_head = bp->tx_tail = 0;
 }
 
@@ -998,6 +1089,7 @@
 {
 	struct eth_platform_data *pdata;
 	struct resource *regs;
+	struct resource *smem;
 	struct net_device *dev;
 	struct macb *bp;
 	unsigned long pclk_hz;
@@ -1045,7 +1137,7 @@
 	bp->hclk = clk_get(&pdev->dev, "hclk");
 	if (IS_ERR(bp->hclk)) {
 		dev_err(&pdev->dev, "failed to get hclk\n");
-		goto err_out_put_pclk;
+		//goto err_out_put_pclk;
 	}
 
 	clk_enable(bp->pclk);
@@ -1123,7 +1215,22 @@
 		macb_writel(bp, USRIO, MACB_BIT(MII));
 #endif
 
-	bp->tx_pending = DEF_TX_RING_PENDING;
+	/* Check  mem region for TX buffers */
+	smem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (smem) {
+		bp->smem_start = smem->start;
+		bp->smem_size  = smem->end - smem->start + 1;
+		bp->tx_ring_size = bp->smem_size / (TX_MAX_PKT_SIZE + \
+				sizeof(struct dma_desc));
+	}
+
+	/* if ring_size == 0 then mem to small and use standard memory */
+	if (!bp->tx_ring_size) {
+		bp->smem_start = 0;
+		bp->tx_ring_size = TX_DEFAULT_RING_SIZE;
+	}
+
+	bp->tx_pending   = DEF_TX_RING_PENDING(bp);
 
 	err = register_netdev(dev);
 	if (err) {
@@ -1153,8 +1260,10 @@
 	clk_put(bp->hclk);
 #endif
 	clk_disable(bp->pclk);
-err_out_put_pclk:
+//dissable useless warnning message by WenJing 20090625
+/*err_out_put_pclk:
 	clk_put(bp->pclk);
+*/
 err_out_free_dev:
 	free_netdev(dev);
 err_out:
@@ -1198,6 +1307,8 @@
 
 static int __init macb_init(void)
 {
+        gpio_direction_input( SIM_SLOT_1 );
+        gpio_direction_input( SIM_SLOT_2 );
 	return platform_driver_register(&macb_driver);
 }
 
diff -uNrbBw linux-2.6.22/drivers/net/macb.h linux-2.6.22_9260/drivers/net/macb.h
--- linux-2.6.22/drivers/net/macb.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/net/macb.h	2014-08-26 16:23:12.727388257 +0800
@@ -364,11 +364,13 @@
 	unsigned int		rx_tail;
 	struct dma_desc		*rx_ring;
 	void			*rx_buffers;
-
+	void			*tx_buffers;
+	unsigned int 		tx_ring_size;
 	unsigned int		tx_head, tx_tail;
 	struct dma_desc		*tx_ring;
 	struct ring_info	*tx_skb;
-
+	unsigned int		smem_start;
+	unsigned int		smem_size;
 	spinlock_t		lock;
 	struct platform_device	*pdev;
 	struct clk		*pclk;
@@ -380,7 +382,7 @@
 	dma_addr_t		rx_ring_dma;
 	dma_addr_t		tx_ring_dma;
 	dma_addr_t		rx_buffers_dma;
-
+	dma_addr_t		tx_buffers_dma;
 	unsigned int		rx_pending, tx_pending;
 
 	struct delayed_work	periodic_task;
diff -uNrbBw linux-2.6.22/drivers/net/mii.c linux-2.6.22_9260/drivers/net/mii.c
--- linux-2.6.22/drivers/net/mii.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/net/mii.c	2014-08-26 16:23:29.804386180 +0800
@@ -296,6 +296,12 @@
 		netif_carrier_off(mii->dev);
 }
 
+
+/* modified on 08-12-15 */
+int eth0_link_state = 0;
+static DEFINE_SPINLOCK(eth0_state_lock);
+extern wait_queue_head_t wait_if_state_changed;
+
 /**
  * mii_check_media - check the MII interface for a duplex change
  * @mii: the MII interface
@@ -330,8 +336,17 @@
 	/* no carrier, nothing much to do */
 	if (!new_carrier) {
 		netif_carrier_off(mii->dev);
-		if (ok_to_print)
+		if (ok_to_print) {
 			printk(KERN_INFO "%s: link down\n", mii->dev->name);
+                        /* modified on 08-12-15 */
+                        if (NULL!=strstr(mii->dev->name, "eth0")) {
+                             spin_lock_irq(&eth0_state_lock);
+                             eth0_link_state = 0;
+                             wake_up(&wait_if_state_changed);
+                             spin_unlock_irq(&eth0_state_lock);
+                        }
+
+                }
 		return 0; /* duplex did not change */
 	}
 
@@ -357,13 +372,21 @@
 	if (lpa2 & LPA_1000FULL)
 		duplex = 1;
 
-	if (ok_to_print)
+	if (ok_to_print) {
 		printk(KERN_INFO "%s: link up, %sMbps, %s-duplex, lpa 0x%04X\n",
 		       mii->dev->name,
 		       lpa2 & (LPA_1000FULL | LPA_1000HALF) ? "1000" :
 		       media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? "100" : "10",
 		       duplex ? "full" : "half",
 		       lpa);
+                /* modified on 08-12-15 */
+                if (NULL!=strstr(mii->dev->name, "eth0")) {
+                       spin_lock_irq(&eth0_state_lock);
+                       eth0_link_state = 1;
+                       wake_up(&wait_if_state_changed);
+                       spin_unlock_irq(&eth0_state_lock);
+                }
+        }
 
 	if ((init_media) || (mii->full_duplex != duplex)) {
 		mii->full_duplex = duplex;
@@ -373,6 +396,9 @@
 	return 0; /* duplex did not change */
 }
 
+/* modified on 08-12-15 */ 
+EXPORT_SYMBOL(eth0_link_state); 
+
 /**
  * generic_mii_ioctl - main MII ioctl interface
  * @mii_if: the MII interface
diff -uNrbBw linux-2.6.22/drivers/rtc/Kconfig linux-2.6.22_9260/drivers/rtc/Kconfig
--- linux-2.6.22/drivers/rtc/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/rtc/Kconfig	2014-08-26 16:23:29.806399637 +0800
@@ -122,8 +122,8 @@
 	depends on RTC_CLASS
 
 config RTC_DRV_DS1307
-	tristate "Dallas/Maxim DS1307/37/38/39/40, ST M41T00"
-	depends on RTC_CLASS && I2C
+	tristate "Dallas DS1307 GPIO support only"
+	depends on RTC_CLASS
 	help
 	  If you say yes here you get support for various compatible RTC
 	  chips (often with battery backup) connected with I2C.  This driver
@@ -139,6 +139,8 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1307.
 
+	  Standard driver support Dallas/Maxim DS1307/37/38/39/40, ST M41T00 are replaced
+
 config RTC_DRV_DS1672
 	tristate "Dallas/Maxim DS1672"
 	depends on RTC_CLASS && I2C
diff -uNrbBw linux-2.6.22/drivers/rtc/L350GpioRtc.c linux-2.6.22_9260/drivers/rtc/L350GpioRtc.c
--- linux-2.6.22/drivers/rtc/L350GpioRtc.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/rtc/L350GpioRtc.c	2014-08-26 16:23:29.808423248 +0800
@@ -0,0 +1,501 @@
+
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/gpio.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/rtc.h>
+#include <asm/delay.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#define SDA  AT91_PIN_PA23
+#define SCL  AT91_PIN_PA24
+
+#define SET_SDA_OUT_HIGH   at91_set_gpio_output(SDA, 1)
+#define SET_SDA_OUT_LOW    at91_set_gpio_output(SDA, 0)
+#define SET_SCL_OUT_HIGH   at91_set_gpio_output(SCL, 1)
+#define SET_SCL_OUT_LOW    at91_set_gpio_output(SCL, 0)
+#define GET_SDA            at91_get_gpio_value(SDA)
+#define I2C_WAIT           udelay(25)
+#define CFG_SDA_IN         at91_set_gpio_input(SDA, 0);\
+                           at91_set_multi_drive(SDA, 1)
+
+
+/* RTC registers don't differ much, except for the century flag */
+#define DS1307_REG_SECS        0x00 /* 00-59 */
+#define DS1307_BIT_CH          0x80
+#define DS1307_REG_MIN         0x01 /* 00-59 */
+#define DS1307_REG_HOUR        0x02 /* 00-23, or 1-12{am,pm} */
+#define DS1307_REG_WDAY        0x03 /* 01-07 */
+#define DS1307_REG_MDAY        0x04 /* 01-31 */
+#define DS1307_REG_MONTH       0x05 /* 01-12 */
+#define DS1337_BIT_CENTURY     0x80 /* in REG_MONTH */
+#define DS1307_REG_YEAR        0x06 /* 00-99 */
+
+static struct platform_device *gpio_rtc_dev = NULL;
+
+typedef unsigned char uchar;
+
+static struct proc_dir_entry * rtc_simu;
+
+static void Start_I2c(void)
+{
+     SET_SDA_OUT_HIGH;   
+     I2C_WAIT;
+     SET_SCL_OUT_HIGH;
+     I2C_WAIT;   
+
+     SET_SDA_OUT_LOW;  
+     I2C_WAIT;   
+     SET_SCL_OUT_LOW; 
+     I2C_WAIT;
+}
+
+static void Stop_I2c(void)
+{
+     SET_SDA_OUT_LOW; 
+     I2C_WAIT;   
+     SET_SCL_OUT_HIGH; 
+     I2C_WAIT;
+     SET_SDA_OUT_HIGH; 
+     I2C_WAIT;
+}
+
+static uchar SendByte(uchar c)
+{
+     uchar BitCnt;
+     uchar ack; 
+ 
+     for (BitCnt=0; BitCnt<8; BitCnt++) 
+     {
+	  if ( (c<<BitCnt) & 0x80 )
+	       SET_SDA_OUT_HIGH;   
+	  else  
+	       SET_SDA_OUT_LOW;                
+
+	  I2C_WAIT;
+	  SET_SCL_OUT_HIGH;        
+
+	  I2C_WAIT; 
+	  SET_SCL_OUT_LOW; 
+     }
+    
+     I2C_WAIT;
+     SET_SDA_OUT_HIGH;             
+     I2C_WAIT;   
+     SET_SCL_OUT_HIGH;
+     I2C_WAIT;
+
+///     CFG_SDA_IN;
+     if(GET_SDA == 1)
+	  ack=0;
+     else
+ 	  ack=1;        
+     SET_SCL_OUT_LOW;
+     I2C_WAIT;
+
+     return ack;
+}
+
+ 
+static uchar  RcvByte(void)
+{
+     uchar retc;
+     uchar BitCnt;
+     
+     retc = 0; 
+     SET_SDA_OUT_HIGH;            
+     for ( BitCnt=0; BitCnt<8; BitCnt++ )
+     {
+	  I2C_WAIT;           
+	  SET_SCL_OUT_LOW;      
+	  I2C_WAIT;
+	  SET_SCL_OUT_HIGH; 
+	  I2C_WAIT;
+	  retc=retc<<1;
+	  ///  CFG_SDA_IN;
+
+	  if(GET_SDA==1)
+	       retc=retc+1; 
+	  I2C_WAIT; 
+     }
+
+     SET_SCL_OUT_LOW;    
+     I2C_WAIT;
+     I2C_WAIT;
+
+     return(retc);
+}
+ 
+static void Ack_I2c(uchar a)
+{
+  
+     if(a==0)
+	  SET_SDA_OUT_LOW;   
+     else 
+	  SET_SDA_OUT_HIGH;
+     I2C_WAIT;      
+
+     SET_SCL_OUT_HIGH;
+     I2C_WAIT;  
+
+     SET_SCL_OUT_LOW;        
+     I2C_WAIT;    
+}
+
+/* static uchar ISendByte(uchar sla,uchar c) */
+/* { */
+/*      Start_I2c();             */
+
+/*      if ( 0 == SendByte(sla) )  */
+/*      { */
+/* 	  return (0); */
+/*      } */
+/*      if ( 0 == SendByte(c) ) */
+/*      { */
+/* 	  return (0); */
+/*      } */
+
+/*      Stop_I2c();                */
+/*      return(1); */
+/* } */
+
+/* Success: return 1
+   Fail   : return 0 */
+static uchar ISendStr(uchar sla,uchar suba,uchar *s,uchar no)
+{
+     uchar i;
+     
+     Start_I2c();              
+     if ( 0 == SendByte(sla) ) 
+     {
+	  return (0);
+     }
+     if ( 0 == SendByte(suba) )
+     {
+	  return (0);
+     }
+
+     for(i=0;i<no;i++)
+     {   
+	  if ( 0 == SendByte(*s) )
+	  {
+	       return (0);
+	  }
+	  s++;
+     } 
+     Stop_I2c();               
+
+     return 1;
+}
+
+/* static uchar IRcvByte(uchar sla,uchar *c) */
+/* { */
+/*      Start_I2c();               */
+   
+/*      if ( 0 == SendByte(sla+1) ) */
+/*      { */
+/* 	  return (0); */
+/*      } */
+     
+/*      *c=RcvByte();              */
+   
+/*      Ack_I2c(1);                */
+/*      Stop_I2c();                */
+
+/*      return(1); */
+/* } */
+
+/* Success: return 1
+   Fail   : return 0 */
+static uchar IRcvStr(uchar sla,uchar suba,uchar *s,uchar no)
+{
+     uchar i;
+     
+     Start_I2c();         
+     if ( 0 == SendByte(sla) )
+     {
+	  return (0);
+     }
+     if ( 0 == SendByte(suba) )
+     {
+	  return (0);
+     }
+
+     Start_I2c();
+     if ( 0 == SendByte(sla+1) )
+     {
+	  return (0);
+     }
+     
+
+     for(i=0;i<no-1;i++)
+     {   
+	  *s=RcvByte();   
+	  Ack_I2c(0);     
+	  s++;
+     } 
+     *s=RcvByte();
+     Ack_I2c(1);    
+     Stop_I2c();    
+
+     return(1);
+}
+
+/* Init line status and enable ds1307 */
+static int simu_i2c_init(void)
+{
+     uchar reg0;
+
+     at91_set_multi_drive(SDA, 1);
+     at91_set_multi_drive(SCL, 1);
+
+     if (!IRcvStr(0xd0, 0, &reg0, 1))
+	  return -1;
+     reg0 &= 0x7f;
+     if (!ISendStr(0xd0, 0, &reg0, 1))
+	  return -1;
+
+     SET_SDA_OUT_HIGH;
+     I2C_WAIT;
+     SET_SCL_OUT_HIGH;
+     I2C_WAIT;
+
+     return 0;
+}
+  
+static int read_rtc_status(char *buffer, char **start, off_t offset, int length, int *eof, void *data)
+{
+///     int i;
+    uchar regs[7];
+    int year, month, day, hour, min, sec, week;
+
+    memset(regs, 0, sizeof (regs));
+    if (!IRcvStr(0xd0, 0, regs, 7))
+	printk("Read rtc error\n");
+
+/*     for (i=0; i<7; i++)  */
+/*      {  */
+/* 	  printk ("%02x ", regs[i]);  */
+/*      }  */
+/*      printk("\n");  */
+
+    year = 2000 + (regs[6] & 0x0f) + ((regs[6] & 0xf0) >> 4) * 10;
+    month = (regs[5] & 0x0f) + ((regs[5] & 0x10)>>4) * 10;
+    day = (regs[4] & 0x0f) + ((regs[4] & 0x30)>>4) * 10;
+    week = regs[3] & 0x07;
+
+    hour = (regs[2] & 0x0f) + ((regs[2] & 0x10)>>4) * 10 + ((regs[2] & 0x20)>>5) * 10;
+    min = (regs[1] & 0x0f) + ((regs[1] & 0x70)>>4) * 10;
+    sec = (regs[0] & 0x0f) + ((regs[0] & 0x70)>>4) * 10;
+
+    sprintf(buffer, "%04d-%02d-%02d %02d:%02d:%02d %01d\n", \
+	    year, month, day, hour, min, sec, week);
+    return 23;
+}
+
+static int write_rtc_status(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+    char *buf;
+    uchar regs[7];
+    int year, month, day, week, hour, min, sec;
+
+    memset(regs, 0, 7);
+    buf = (char*)kmalloc(count, GFP_KERNEL);
+    if (!buf)
+	return -ENOMEM;
+
+    if (copy_from_user(buf, buffer, count))
+	return -EFAULT;
+
+    sscanf(buf, "%04d-%02d-%02d %02d:%02d:%02d %01d", &year, &month, &day, &hour, &min, &sec, &week);
+
+    regs[0] |= (sec % 10) | ((sec / 10) & 0x07)<<4;
+    regs[1] |= (min % 10) | ((min / 10) & 0x07)<<4;
+    if (hour>19)		/* The hour must be in 24 hour mode */
+    {
+	 regs[2] |= 0x20;
+	 hour -= 10;
+    }
+    regs[2] |= (hour % 10) | ((hour / 10) & 0x01)<<4;
+    regs[3] |= (week & 0x07);  	/* Monday;0 Tuesday:1 ... Sunday:7 */
+
+    regs[4] |= (day % 10) | ((day / 10) & 0x03)<<4;
+    regs[5] |= (month % 10) | ((month / 10) & 0x01)<<4;
+
+    year -= 2000;
+    regs[6] |= (year % 10) | ((year / 10) & 0x0f)<<4;
+
+    if (!ISendStr(0xd0, 0, regs, 7))
+	 printk("Set time error\n");
+
+    kfree(buf);
+
+    return count;    
+}
+
+#define BCD2BIN(val)  (((val) & 0x0f) + ((val)>>4)*10)
+#define BIN2BCD(val)  ((((val)/10)<<4) + (val)%10)
+
+static int gpio_get_time(struct device *dev, struct rtc_time *t)
+{
+    uchar regs[7];
+    uchar tmp;
+///    int i;
+
+    memset(regs, 0, sizeof (regs));
+    if (!IRcvStr(0xd0, 0, regs, 7))
+	 printk("Rtc get time error\n");
+
+/*     for (i=0; i<8; i++) */
+/*     { */
+/* 	 printk ("%02x ", regs[i]); */
+/*     } */
+/*     printk("\n"); */
+
+    t->tm_sec = BCD2BIN(regs[DS1307_REG_SECS] & 0x7f);
+    t->tm_min = BCD2BIN(regs[DS1307_REG_MIN] & 0x7f);
+
+    tmp = regs[DS1307_REG_HOUR] & 0x3f;
+    t->tm_hour = BCD2BIN(tmp);
+
+    t->tm_wday = BCD2BIN(regs[DS1307_REG_WDAY] & 0x07) - 1;
+    t->tm_mday = BCD2BIN(regs[DS1307_REG_MDAY] & 0x3f);
+
+    tmp = regs[DS1307_REG_MONTH] & 0x1f;
+    t->tm_mon = BCD2BIN(tmp) - 1;
+
+    /* assume 20YY not 19YY, and ignore DS1337_BIT_CENTURY */
+    t->tm_year = BCD2BIN(regs[DS1307_REG_YEAR]) + 100;
+
+    return 0;
+}
+
+static int gpio_set_time(struct device *dev, struct rtc_time *t)
+{
+    uchar regs[7];
+    uchar tmp;
+
+/*     printk("secs=%d, mins=%d, hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n write", \ */
+/* 	   t->tm_sec, t->tm_min,  t->tm_hour, t->tm_mday,\ */
+/* 	   t->tm_mon, t->tm_year, t->tm_wday); */
+
+    regs[DS1307_REG_SECS]  = BIN2BCD(t->tm_sec);
+    regs[DS1307_REG_MIN]   = BIN2BCD(t->tm_min);
+    regs[DS1307_REG_HOUR]  = BIN2BCD(t->tm_hour);
+    regs[DS1307_REG_WDAY]  = BIN2BCD(t->tm_wday + 1);
+    regs[DS1307_REG_MDAY]  = BIN2BCD(t->tm_mday);
+    regs[DS1307_REG_MONTH] = BIN2BCD(t->tm_mon + 1);
+
+    /* assume 20YY not 19YY */
+    tmp = t->tm_year - 100;
+    regs[DS1307_REG_YEAR] = BIN2BCD(tmp);
+
+/*     printk("%02x %02x %02x %02x %02x %02x %02x write", \ */
+/* 	   regs[0], regs[1], regs[2], regs[3], regs[4], regs[5], regs[6]); */
+
+    if (!ISendStr(0xd0, 0, regs, 7))
+	 printk("Rtc set time error\n");
+    
+    return 0;
+}
+
+
+
+static const struct rtc_class_ops gpio_rtc_ops =
+{
+     .read_time = gpio_get_time,
+     .set_time  = gpio_set_time,
+};
+
+static int gpio_rtc_probe(struct platform_device *plat_dev)
+{
+     int err;
+     struct rtc_device *rtc = rtc_device_register("gpio_rtc", &plat_dev->dev,
+						  &gpio_rtc_ops, THIS_MODULE);
+     if (IS_ERR(rtc)) {
+	  err = PTR_ERR(rtc);
+	  return err;
+     }
+
+     platform_set_drvdata(plat_dev, rtc);
+
+     return 0;
+}
+
+static int __devexit gpio_rtc_remove(struct platform_device *plat_dev)
+{
+     struct rtc_device *rtc = platform_get_drvdata(plat_dev);
+
+     rtc_device_unregister(rtc);
+
+     return 0;
+}
+
+static struct platform_driver gpio_rtc_drv = {
+     .probe  = gpio_rtc_probe,
+     .remove = __devexit_p(gpio_rtc_remove),
+     .driver = {
+	  .name = "rtc-simu",
+	  .owner = THIS_MODULE,
+     },
+};
+
+static int __init rtc_simu_init(void)
+{
+     int err;
+     struct proc_dir_entry * res;
+
+     if (simu_i2c_init() < 0)
+	  return -EFAULT;
+
+     rtc_simu = proc_mkdir("rtc_simu", 0);
+     if (!rtc_simu)
+	 return -ENOMEM;
+
+     res = create_proc_entry("ds1307_regs", S_IRUGO | S_IWUGO, rtc_simu);
+     if (!res)
+	 return -ENOMEM;
+     res->read_proc  = read_rtc_status;
+     res->write_proc = write_rtc_status;
+     res->data = 0;
+
+     if ((err = platform_driver_register(&gpio_rtc_drv)))
+	  return err;
+
+     if ((gpio_rtc_dev = platform_device_alloc("rtc-simu", 0)) == NULL) {
+	  err = -ENOMEM;
+	  goto exit_driver_unregister;
+     }
+
+     if ((err = platform_device_add(gpio_rtc_dev)))
+	  goto exit_free_dev;
+
+     return 0;
+
+ exit_free_dev:
+     platform_device_put(gpio_rtc_dev);
+
+ exit_driver_unregister:
+     platform_driver_unregister(&gpio_rtc_drv);
+     return 0;
+}
+
+static void __exit rtc_simu_exit(void)
+{
+    remove_proc_entry("ds1307_regs", rtc_simu);
+    remove_proc_entry("rtc_simu", 0); 
+
+    platform_device_unregister(gpio_rtc_dev);
+    platform_driver_unregister(&gpio_rtc_drv);
+}
+
+module_init(rtc_simu_init);
+module_exit(rtc_simu_exit);
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/drivers/rtc/Makefile linux-2.6.22_9260/drivers/rtc/Makefile
--- linux-2.6.22/drivers/rtc/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/rtc/Makefile	2014-08-26 16:23:29.809383356 +0800
@@ -19,7 +19,7 @@
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
 obj-$(CONFIG_RTC_DRV_ISL1208)	+= rtc-isl1208.o
 obj-$(CONFIG_RTC_DRV_TEST)	+= rtc-test.o
-obj-$(CONFIG_RTC_DRV_DS1307)	+= rtc-ds1307.o
+obj-$(CONFIG_RTC_DRV_DS1307)	+= L350GpioRtc.o
 obj-$(CONFIG_RTC_DRV_DS1672)	+= rtc-ds1672.o
 obj-$(CONFIG_RTC_DRV_DS1742)	+= rtc-ds1742.o
 obj-$(CONFIG_RTC_DRV_OMAP)	+= rtc-omap.o
diff -uNrbBw linux-2.6.22/drivers/rtc/rtc-ds1307.c linux-2.6.22_9260/drivers/rtc/rtc-ds1307.c
--- linux-2.6.22/drivers/rtc/rtc-ds1307.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/rtc/rtc-ds1307.c	2014-08-26 16:23:29.810412071 +0800
@@ -93,17 +93,52 @@
 {
 	struct ds1307	*ds1307 = dev_get_drvdata(dev);
 	int		tmp;
+    u8 badtime = 1, regs[8] = {0};
 
 	/* read the RTC registers all at once */
 	ds1307->msg[1].flags = I2C_M_RD;
 	ds1307->msg[1].len = 7;
 
+    while (badtime)
+    {
+		int i = 0, loop = 3;
+
+		while (i < loop)
+		{
+			preempt_disable();
 	tmp = i2c_transfer(ds1307->client.adapter, ds1307->msg, 2);
+			preempt_enable();
 	if (tmp != 2) {
 		dev_err(dev, "%s error %d\n", "read", tmp);
 		return -EIO;
 	}
 
+			if (0 == i)
+			{
+				regs[DS1307_REG_SECS] = ds1307->regs[DS1307_REG_SECS];
+				regs[DS1307_REG_MIN] = ds1307->regs[DS1307_REG_MIN];
+				regs[DS1307_REG_HOUR] = ds1307->regs[DS1307_REG_HOUR];
+				regs[DS1307_REG_WDAY] = ds1307->regs[DS1307_REG_WDAY];
+				regs[DS1307_REG_MDAY] = ds1307->regs[DS1307_REG_MDAY];
+				regs[DS1307_REG_MONTH] = ds1307->regs[DS1307_REG_MONTH];
+				regs[DS1307_REG_YEAR] = ds1307->regs[DS1307_REG_YEAR];
+			}
+			else if (ds1307->regs[DS1307_REG_SECS] < regs[DS1307_REG_SECS]
+					|| ds1307->regs[DS1307_REG_MIN] != regs[DS1307_REG_MIN]
+					|| ds1307->regs[DS1307_REG_HOUR] != regs[DS1307_REG_HOUR]
+					|| ds1307->regs[DS1307_REG_WDAY] != regs[DS1307_REG_WDAY]
+					|| ds1307->regs[DS1307_REG_MDAY] != regs[DS1307_REG_MDAY]
+					|| ds1307->regs[DS1307_REG_MONTH] != regs[DS1307_REG_MONTH]
+					|| ds1307->regs[DS1307_REG_YEAR] != regs[DS1307_REG_YEAR])
+			{
+				i = 0;
+				printk(KERN_ERR "rtc no match, try again\n");
+				continue;
+			}
+
+			i++;
+		}
+
 	dev_dbg(dev, "%s: %02x %02x %02x %02x %02x %02x %02x\n",
 			"read",
 			ds1307->regs[0], ds1307->regs[1],
@@ -119,9 +154,7 @@
 	t->tm_mday = BCD2BIN(ds1307->regs[DS1307_REG_MDAY] & 0x3f);
 	tmp = ds1307->regs[DS1307_REG_MONTH] & 0x1f;
 	t->tm_mon = BCD2BIN(tmp) - 1;
-
-	/* assume 20YY not 19YY, and ignore DS1337_BIT_CENTURY */
-	t->tm_year = BCD2BIN(ds1307->regs[DS1307_REG_YEAR]) + 100;
+		t->tm_year = BCD2BIN(ds1307->regs[DS1307_REG_YEAR]) + 100;/* assume 20YY not 19YY, and ignore DS1337_BIT_CENTURY */    
 
 	dev_dbg(dev, "%s secs=%d, mins=%d, "
 		"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",
@@ -129,6 +162,9 @@
 		t->tm_hour, t->tm_mday,
 		t->tm_mon, t->tm_year, t->tm_wday);
 
+		badtime = 0;
+    }
+
 	return 0;
 }
 
@@ -170,7 +206,9 @@
 		"write", buf[0], buf[1], buf[2], buf[3],
 		buf[4], buf[5], buf[6]);
 
+	preempt_disable();
 	result = i2c_transfer(ds1307->client.adapter, &ds1307->msg[1], 1);
+	preempt_enable();
 	if (result != 1) {
 		dev_err(dev, "%s error %d\n", "write", tmp);
 		return -EIO;
@@ -223,7 +261,9 @@
 		ds1307->reg_addr = DS1337_REG_CONTROL;
 		ds1307->msg[1].len = 2;
 
+		preempt_disable();
 		tmp = i2c_transfer(client->adapter, ds1307->msg, 2);
+		preempt_enable();
 		if (tmp != 2) {
 			pr_debug("read error %d\n", tmp);
 			err = -EIO;
@@ -245,7 +285,9 @@
 read_rtc:
 	/* read RTC registers */
 
+	preempt_disable();
 	tmp = i2c_transfer(client->adapter, ds1307->msg, 2);
+	preempt_enable();
 	if (tmp != 2) {
 		pr_debug("read error %d\n", tmp);
 		err = -EIO;
@@ -268,7 +310,9 @@
 		 * ds1338, ds1340, st m41t00, and more.
 		 */
 		dev_warn(&client->dev, "oscillator started; SET TIME!\n");
+		preempt_disable();
 		i2c_smbus_write_byte_data(client, 0, 0);
+		preempt_enable();
 		goto read_rtc;
 	}
 	tmp = BCD2BIN(tmp & 0x7f);
@@ -295,9 +339,11 @@
 			tmp = BCD2BIN(tmp & 0x1f) + 12;
 		else
 			tmp = BCD2BIN(tmp);
+		preempt_disable();
 		i2c_smbus_write_byte_data(client,
 				DS1307_REG_HOUR,
 				BIN2BCD(tmp));
+		preempt_enable();
 	}
 
 	/* FIXME chips like 1337 can generate alarm irqs too; those are
diff -uNrbBw linux-2.6.22/drivers/rtc/rtc-pcf8563.c linux-2.6.22_9260/drivers/rtc/rtc-pcf8563.c
--- linux-2.6.22/drivers/rtc/rtc-pcf8563.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/rtc/rtc-pcf8563.c	2014-08-26 16:23:29.814393840 +0800
@@ -25,7 +25,7 @@
  * located at 0x51 will pass the validation routine due to
  * the way the registers are implemented.
  */
-static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short normal_i2c[] = { 0x51, I2C_CLIENT_END };
 
 /* Module parameters */
 I2C_CLIENT_INSMOD;
@@ -90,10 +90,13 @@
 	};
 
 	/* read registers */
+	preempt_disable();
 	if ((i2c_transfer(client->adapter, msgs, 2)) != 2) {
+		preempt_enable();
 		dev_err(&client->dev, "%s: read error\n", __FUNCTION__);
 		return -EIO;
 	}
+	preempt_enable();
 
 	if (buf[PCF8563_REG_SC] & PCF8563_SC_LV)
 		dev_info(&client->dev,
@@ -170,13 +173,16 @@
 		unsigned char data[2] = { PCF8563_REG_SC + i,
 						buf[PCF8563_REG_SC + i] };
 
+		preempt_disable();
 		err = i2c_master_send(client, data, sizeof(data));
 		if (err != sizeof(data)) {
+			preempt_enable();
 			dev_err(&client->dev,
 				"%s: err=%d addr=%02x, data=%02x\n",
 				__FUNCTION__, err, data[0], data[1]);
 			return -EIO;
 		}
+		preempt_enable();
 	};
 
 	return 0;
@@ -214,7 +220,9 @@
 			{ client->addr, I2C_M_RD, 1, &buf },
 		};
 
+		preempt_disable();
 		xfer = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+		preempt_enable();
 
 		if (xfer != ARRAY_SIZE(msgs)) {
 			dev_err(&client->dev,
diff -uNrbBw linux-2.6.22/drivers/scsi/sd.c linux-2.6.22_9260/drivers/scsi/sd.c
--- linux-2.6.22/drivers/scsi/sd.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/scsi/sd.c	2014-08-26 16:23:29.815386776 +0800
@@ -1563,6 +1563,11 @@
 	return 0;
 }
 
+
+/* modified on 08-12-08 */
+int usb_state = 0;
+static DEFINE_SPINLOCK(usb_state_lock);
+extern wait_queue_head_t wait_if_state_changed;
 /**
  *	sd_probe - called during driver initialization and whenever a
  *	new scsi device is attached to the system. It is called once
@@ -1674,6 +1679,13 @@
 	sd_printk(KERN_NOTICE, sdkp, "Attached SCSI %sdisk\n",
 		  sdp->removable ? "removable " : "");
 
+        /* modified on 08-12-08 */
+        spin_lock_irq(&usb_state_lock);
+        usb_state = 1;
+        wake_up(&wait_if_state_changed);
+        spin_unlock_irq(&usb_state_lock);
+       // printk("usb_state=%d\n", usb_state);
+
 	return 0;
 
  out_put:
@@ -1708,9 +1720,20 @@
 	class_device_put(&sdkp->cdev);
 	mutex_unlock(&sd_ref_mutex);
 
+
+        /* modified on 08-12-08 */
+        spin_lock_irq(&usb_state_lock);
+        usb_state = 0;
+        wake_up(&wait_if_state_changed);
+        spin_unlock_irq(&usb_state_lock);
+        //printk("usb_state=%d\n", usb_state);
+
 	return 0;
 }
 
+/* modified on 08-12-08 */
+EXPORT_SYMBOL(usb_state);
+
 /**
  *	scsi_disk_release - Called to free the scsi_disk structure
  *	@cdev: pointer to embedded class device
diff -uNrbBw linux-2.6.22/drivers/serial/atmel_serial.c linux-2.6.22_9260/drivers/serial/atmel_serial.c
--- linux-2.6.22/drivers/serial/atmel_serial.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/serial/atmel_serial.c	2014-08-26 16:22:54.447423104 +0800
@@ -7,6 +7,8 @@
  *  Based on drivers/char/serial_sa1100.c, by Deep Blue Solutions Ltd.
  *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
  *
+ *  DMA support added by Chip Coldwell.
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -33,6 +35,7 @@
 #include <linux/sysrq.h>
 #include <linux/tty_flip.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #include <linux/atmel_pdc.h>
 
 #include <asm/io.h>
@@ -47,6 +50,11 @@
 
 #include "atmel_serial.h"
 
+#define SUPPORT_PDC
+#define PDC_BUFFER_SIZE		(L1_CACHE_BYTES << 3)
+#warning "Revisit"
+#define PDC_RX_TIMEOUT		(3 * 10)		/* 3 bytes */
+
 #if defined(CONFIG_SERIAL_ATMEL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
@@ -107,6 +115,13 @@
 static int (*atmel_open_hook)(struct uart_port *);
 static void (*atmel_close_hook)(struct uart_port *);
 
+struct atmel_dma_buffer {
+	unsigned char	*buf;
+	dma_addr_t	dma_addr;
+	size_t		dma_size;
+	unsigned int	ofs;
+};
+
 /*
  * We wrap our port structure around the generic uart_port.
  */
@@ -114,10 +129,20 @@
 	struct uart_port	uart;		/* uart */
 	struct clk		*clk;		/* uart clock */
 	unsigned short		suspended;	/* is port suspended? */
+
+	short			use_dma_rx;	/* enable PDC receiver */
+	short			pdc_rx_idx;	/* current PDC RX buffer */
+	struct atmel_dma_buffer	pdc_rx[2];	/* PDC receier */
+
+	short			use_dma_tx;	/* enable PDC transmitter */
+	struct atmel_dma_buffer	pdc_tx;		/* PDC transmitter */
 };
 
 static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
 
+#define PDC_RX_BUF(port)	&(port)->pdc_rx[(port)->pdc_rx_idx]
+#define PDC_RX_SWITCH(port)	(port)->pdc_rx_idx = !(port)->pdc_rx_idx
+
 #ifdef SUPPORT_SYSRQ
 static struct console atmel_console;
 #endif
@@ -205,6 +230,11 @@
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
+	if (atmel_port->use_dma_tx) {
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);		/* disable PDC transmit */
+		UART_PUT_IDR(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+	}
+	else
 	UART_PUT_IDR(port, ATMEL_US_TXRDY);
 }
 
@@ -215,6 +245,16 @@
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
+	if (atmel_port->use_dma_tx) {
+		if (UART_GET_PTSR(port) & ATMEL_PDC_TXTEN)
+			/* The transmitter is already running.  Yes, we
+			   really need this.*/
+			return;
+
+		UART_PUT_IER(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);		/* re-enable PDC transmit */
+	}
+	else
 	UART_PUT_IER(port, ATMEL_US_TXRDY);
 }
 
@@ -225,6 +265,11 @@
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
+	if (atmel_port->use_dma_rx) {
+		UART_PUT_PTCR(port, ATMEL_PDC_RXTDIS);		/* disable PDC receive */
+		UART_PUT_IDR(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);
+	}
+	else
 	UART_PUT_IDR(port, ATMEL_US_RXRDY);
 }
 
@@ -248,6 +293,134 @@
 }
 
 /*
+ * Receive data via the PDC.  A buffer has been fulled.
+ */
+static void atmel_pdc_endrx(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct tty_struct *tty = port->info->tty;
+	struct atmel_dma_buffer *pdc = PDC_RX_BUF(atmel_port);
+	unsigned int count;
+
+	count = pdc->dma_size - pdc->ofs;
+	if (likely(count > 0)) {
+		dma_sync_single_for_cpu(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+		tty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);
+		tty_flip_buffer_push(tty);
+
+		port->icount.rx += count;
+	}
+
+	/* Set this buffer as the next receive buffer */
+	pdc->ofs = 0;
+	UART_PUT_RNPR(port, pdc->dma_addr);
+	UART_PUT_RNCR(port, pdc->dma_size);
+
+	/* Switch to next buffer */
+	PDC_RX_SWITCH(atmel_port);		/* next PDC buffer */
+}
+
+/*
+ * Receive data via the PDC.  At least one byte was received, but the
+ * buffer was not full when the inter-character timeout expired.
+ */
+static void atmel_pdc_timeout(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct tty_struct *tty = port->info->tty;
+	struct atmel_dma_buffer *pdc = PDC_RX_BUF(atmel_port);
+	/* unsigned */ int ofs, count;
+
+	ofs = UART_GET_RPR(port) - pdc->dma_addr;	/* current DMA adress */
+	count = ofs - pdc->ofs;
+
+	if (likely(count > 0)) {
+		dma_sync_single_for_cpu(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+		tty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);
+		tty_flip_buffer_push(tty);
+
+		pdc->ofs = ofs;
+		port->icount.rx += count;
+	}
+
+	/* reset the UART timeout */
+	UART_PUT_CR(port, ATMEL_US_STTTO);
+}
+
+/*
+ * Deal with parity, framing and overrun errors.
+ */
+static void atmel_pdc_rxerr(struct uart_port *port, unsigned int status)
+{
+	/* clear error */
+	UART_PUT_CR(port, ATMEL_US_RSTSTA);
+
+	if (status & ATMEL_US_RXBRK) {
+		status &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);	/* ignore side-effect */
+		port->icount.brk++;
+	}
+	if (status & ATMEL_US_PARE)
+		port->icount.parity++;
+	if (status & ATMEL_US_FRAME)
+		port->icount.frame++;
+	if (status & ATMEL_US_OVRE)
+		port->icount.overrun++;
+}
+
+/*
+ * A transmission via the PDC is complete.
+ */
+static void atmel_pdc_endtx(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct circ_buf *xmit = &port->info->xmit;
+	struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+
+	xmit->tail += pdc->ofs;
+	if (xmit->tail >= SERIAL_XMIT_SIZE)
+		xmit->tail -= SERIAL_XMIT_SIZE;
+
+	port->icount.tx += pdc->ofs;
+	pdc->ofs = 0;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+/*
+ * The PDC transmitter is idle, so either start the next transfer or
+ * disable the transmitter.
+ */
+static void atmel_pdc_txbufe(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct circ_buf *xmit = &port->info->xmit;
+	struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+	int count;
+
+	if (!uart_circ_empty(xmit)) {
+		/* more to transmit - setup next transfer */
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);			/* disable PDC transmit */
+		dma_sync_single_for_device(port->dev, pdc->dma_addr, pdc->dma_size, DMA_TO_DEVICE);
+
+		if (xmit->tail < xmit->head)
+			count = xmit->head - xmit->tail;
+		else
+			count = SERIAL_XMIT_SIZE - xmit->tail;
+		pdc->ofs = count;
+
+		UART_PUT_TPR(port, pdc->dma_addr + xmit->tail);
+		UART_PUT_TCR(port, count);
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);			/* re-enable PDC transmit */
+	}
+	else {
+		/* nothing left to transmit - disable the transmitter */
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);			/* disable PDC transmit */
+		UART_PUT_IDR(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+	}
+}
+
+/*
  * Characters received (called from interrupt handler)
  */
 static void atmel_rx_chars(struct uart_port *port)
@@ -349,6 +522,14 @@
 	status = UART_GET_CSR(port);
 	pending = status & UART_GET_IMR(port);
 	while (pending) {
+		/* PDC receive */
+		if (pending & ATMEL_US_ENDRX)
+			atmel_pdc_endrx(port);
+		if (pending & ATMEL_US_TIMEOUT)
+			atmel_pdc_timeout(port);
+		if (atmel_port->use_dma_rx && pending & (ATMEL_US_RXBRK | ATMEL_US_OVRE | ATMEL_US_FRAME | ATMEL_US_PARE))
+			atmel_pdc_rxerr(port, pending);
+
 		/* Interrupt receive */
 		if (pending & ATMEL_US_RXRDY)
 			atmel_rx_chars(port);
@@ -363,6 +544,12 @@
 		if (pending & (ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC | ATMEL_US_CTSIC))
 			wake_up_interruptible(&port->info->delta_msr_wait);
 
+		/* PDC transmit */
+		if (pending & ATMEL_US_ENDTX)
+			atmel_pdc_endtx(port);
+		if (pending & ATMEL_US_TXBUFE)
+			atmel_pdc_txbufe(port);
+
 		/* Interrupt transmit */
 		if (pending & ATMEL_US_TXRDY)
 			atmel_tx_chars(port);
@@ -401,6 +588,47 @@
 	}
 
 	/*
+	 * Initialize DMA (if necessary)
+	 */
+	if (atmel_port->use_dma_rx) {
+		int i;
+
+		for (i = 0; i < 2; i++) {
+			struct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];
+
+			pdc->buf = kmalloc(PDC_BUFFER_SIZE, GFP_KERNEL);
+			if (pdc->buf == NULL) {
+				if (i != 0) {
+					dma_unmap_single(port->dev, atmel_port->pdc_rx[0].dma_addr, PDC_BUFFER_SIZE, DMA_FROM_DEVICE);
+					kfree(atmel_port->pdc_rx[0].buf);
+				}
+				free_irq(port->irq, port);
+				return -ENOMEM;
+			}
+			pdc->dma_addr = dma_map_single(port->dev, pdc->buf, PDC_BUFFER_SIZE, DMA_FROM_DEVICE);
+			pdc->dma_size = PDC_BUFFER_SIZE;
+			pdc->ofs = 0;
+		}
+
+		atmel_port->pdc_rx_idx = 0;
+
+		UART_PUT_RPR(port, atmel_port->pdc_rx[0].dma_addr);
+		UART_PUT_RCR(port, PDC_BUFFER_SIZE);
+
+		UART_PUT_RNPR(port, atmel_port->pdc_rx[1].dma_addr);
+		UART_PUT_RNCR(port, PDC_BUFFER_SIZE);
+	}
+	if (atmel_port->use_dma_tx) {
+		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+		struct circ_buf *xmit = &port->info->xmit;
+
+		pdc->buf = xmit->buf;
+		pdc->dma_addr = dma_map_single(port->dev, pdc->buf, SERIAL_XMIT_SIZE, DMA_TO_DEVICE);
+		pdc->dma_size = SERIAL_XMIT_SIZE;
+		pdc->ofs = 0;
+	}
+
+	/*
 	 * If there is a specific "open" function (to register
 	 * control line interrupts)
 	 */
@@ -418,6 +646,14 @@
 	UART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);
 	UART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);		/* enable xmit & rcvr */
 
+	if (atmel_port->use_dma_rx) {
+		UART_PUT_RTOR(port, PDC_RX_TIMEOUT);		/* set UART timeout */
+		UART_PUT_CR(port, ATMEL_US_STTTO);
+
+		UART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);
+		UART_PUT_PTCR(port, ATMEL_PDC_RXTEN);		/* enable PDC controller */
+	}
+	else
 	UART_PUT_IER(port, ATMEL_US_RXRDY);		/* enable receive only */
 
 	return 0;
@@ -431,6 +667,31 @@
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
 	/*
+	 * Ensure everything is stopped.
+	 */
+	atmel_stop_rx(port);
+	atmel_stop_tx(port);
+
+	/*
+	 * Shut-down the DMA.
+	 */
+	if (atmel_port->use_dma_rx) {
+		int i;
+
+		for (i = 0; i < 2; i++) {
+			struct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];
+
+			dma_unmap_single(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+			kfree(pdc->buf);
+		}
+	}
+	if (atmel_port->use_dma_tx) {
+		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+
+		dma_unmap_single(port->dev, pdc->dma_addr, pdc->dma_size, DMA_TO_DEVICE);
+	}
+
+	/*
 	 * Disable all interrupts, port and break condition.
 	 */
 	UART_PUT_CR(port, ATMEL_US_RSTSTA);
@@ -481,6 +742,7 @@
  */
 static void atmel_set_termios(struct uart_port *port, struct ktermios * termios, struct ktermios * old)
 {
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 	unsigned long flags;
 	unsigned int mode, imr, quot, baud;
 
@@ -539,6 +801,9 @@
 	if (termios->c_iflag & (BRKINT | PARMRK))
 		port->read_status_mask |= ATMEL_US_RXBRK;
 
+	if (atmel_port->use_dma_rx)	/* need to enable error interrupts */
+		UART_PUT_IER(port, port->read_status_mask);
+
 	/*
 	 * Characters to ignore
 	 */
@@ -717,6 +982,13 @@
 		clk_enable(atmel_port->clk);
 		port->uartclk = clk_get_rate(atmel_port->clk);
 	}
+
+#ifdef SUPPORT_PDC
+	atmel_port->use_dma_rx = data->use_dma_rx;
+	atmel_port->use_dma_tx = data->use_dma_tx;
+	if (atmel_port->use_dma_tx)
+		port->fifosize = PDC_BUFFER_SIZE;
+#endif
 }
 
 /*
@@ -893,7 +1165,8 @@
 	struct uart_port *port = platform_get_drvdata(pdev);
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
-	if (device_may_wakeup(&pdev->dev) && !at91_suspend_entering_slow_clock())
+	if (device_may_wakeup(&pdev->dev)
+			&& !clk_must_disable(atmel_port->clk))
 		enable_irq_wake(port->irq);
 	else {
 		uart_suspend_port(&atmel_uart, port);
diff -uNrbBw linux-2.6.22/drivers/spi/Kconfig linux-2.6.22_9260/drivers/spi/Kconfig
--- linux-2.6.22/drivers/spi/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/spi/Kconfig	2014-08-26 16:22:54.452383002 +0800
@@ -55,6 +55,7 @@
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on (ARCH_AT91 || AVR32) && SPI_MASTER
+	select SPI_AT91_MANUAL_CS if ARCH_AT91RM9200
 	help
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
@@ -100,6 +101,24 @@
 	  inexpensive battery powered microcontroller evaluation board.
 	  This same cable can be used to flash new firmware.
 
+config SPI_AT91
+	tristate "AT91RM9200 Bitbang SPI Master"
+	depends on SPI_MASTER && ARCH_AT91RM9200 && !SPI_ATMEL && EXPERIMENTAL
+	select SPI_BITBANG
+	select SPI_AT91_MANUAL_CS
+	help
+	  This is dumb PIO bitbanging driver for the Atmel AT91RM9200.
+	  The SPI_ATMEL driver will be its replacement, using the native
+	  SPI hardware and its DMA controller.
+
+config SPI_AT91_MANUAL_CS
+	bool
+	depends on ARCH_AT91RM9200
+	help
+	  Works around an AT91RM9200 problem whereby the SPI chip-select
+	  will be wrongly disabled.  The workaround uses those pins as
+	  GPIOs instead of letting the SPI controller manage them.
+
 config SPI_IMX
 	tristate "Freescale iMX SPI controller"
 	depends on SPI_MASTER && ARCH_IMX && EXPERIMENTAL
diff -uNrbBw linux-2.6.22/drivers/spi/Makefile linux-2.6.22_9260/drivers/spi/Makefile
--- linux-2.6.22/drivers/spi/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/spi/Makefile	2014-08-26 16:22:54.453387024 +0800
@@ -23,6 +23,7 @@
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
+obj-$(CONFIG_SPI_AT91)			+= spi_at91_bitbang.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff -uNrbBw linux-2.6.22/drivers/spi/spi_at91_bitbang.c linux-2.6.22_9260/drivers/spi/spi_at91_bitbang.c
--- linux-2.6.22/drivers/spi/spi_at91_bitbang.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/spi/spi_at91_bitbang.c	2014-08-26 16:22:54.452383002 +0800
@@ -0,0 +1,207 @@
+/*
+ * at91_spi.c - at91 SPI driver (BOOTSTRAP/BITBANG VERSION)
+ *
+ * Copyright (C) 2006 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/arch/gpio.h>
+
+
+/*
+ * FIXME this bitbanging version is just to help bootstrap systems until
+ * there's a native SPI+IRQ+DMA controller driver ... such a driver should
+ * be a drop-in replacement for this one, and much faster.
+ *
+ * remember:
+ *
+ *	- other at91 parts (like at91sam9) have multiple controllers
+ *	  and different pin muxing; this version is at91rm9200 specfic.
+ *
+ *	- at91sam9261 SPI0 pins are directly muxed with MMC/SD pins.
+ *
+ *	- rm9200 spi chipselects drop wrongly, so the native driver
+ *	  will need to use gpios much like this does.
+ *
+ *	- real hardware only allows 8..16 bits per word, while this
+ *	  bitbanger allows 1..32 (incompatible superset).
+ *
+ *	- this disregards clock parameters.  with inlined gpio calls,
+ *	  gcc 3.4.4 produces about 1.5 mbit/sec, more than 2x faster
+ *	  than using the subroutined veresion from txrx_word().
+ *
+ *	- suspend/resume and <linux/clk.h> support is missing ...
+ */
+
+#define	spi_miso_bit	AT91_PIN_PA0
+#define	spi_mosi_bit	AT91_PIN_PA1
+#define	spi_sck_bit	AT91_PIN_PA2
+
+struct at91_spi {
+	struct spi_bitbang	bitbang;
+	struct platform_device	*pdev;
+};
+
+/*----------------------------------------------------------------------*/
+
+static inline void setsck(struct spi_device *spi, int is_on)
+{
+	at91_set_gpio_value(spi_sck_bit, is_on);
+}
+
+static inline void setmosi(struct spi_device *spi, int is_on)
+{
+	at91_set_gpio_value(spi_mosi_bit, is_on);
+}
+
+static inline int getmiso(struct spi_device *spi)
+{
+	return at91_get_gpio_value(spi_miso_bit);
+}
+
+static void at91_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	unsigned long cs = (unsigned long) spi->controller_data;
+
+	/* set default clock polarity */
+	if (is_active)
+		setsck(spi, spi->mode & SPI_CPOL);
+
+	/* only support active-low (default) */
+	at91_set_gpio_value(cs, !is_active);
+}
+
+/*
+ * NOTE:  this is "as fast as we can"; it should be a function of
+ * the device clock ...
+ */
+#define	spidelay(X)	do{} while(0)
+
+#define	EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 at91_spi_txrx_word_mode0(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode1(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode2(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode3(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, 8);
+}
+
+/*----------------------------------------------------------------------*/
+
+static int __init at91_spi_probe(struct platform_device *pdev)
+{
+	int			status;
+	struct spi_master	*master;
+	struct at91_spi		*at91_spi;
+
+	if (pdev->id != 0)	/* SPI0 bus */
+		return -EINVAL;
+
+	master = spi_alloc_master(&pdev->dev, sizeof *at91_spi);
+	if (!master)
+		return -ENOMEM;
+
+	at91_spi = spi_master_get_devdata(master);
+	at91_spi->pdev = pdev;
+	platform_set_drvdata(pdev, at91_spi);
+
+	/* SPI and bitbang hookup */
+	master->bus_num = 0;
+	master->num_chipselect = 4;
+
+	at91_spi->bitbang.master = spi_master_get(master);
+	at91_spi->bitbang.chipselect = at91_spi_chipselect;
+	at91_spi->bitbang.txrx_word[SPI_MODE_0] = at91_spi_txrx_word_mode0;
+	at91_spi->bitbang.txrx_word[SPI_MODE_1] = at91_spi_txrx_word_mode1;
+	at91_spi->bitbang.txrx_word[SPI_MODE_2] = at91_spi_txrx_word_mode2;
+	at91_spi->bitbang.txrx_word[SPI_MODE_3] = at91_spi_txrx_word_mode3;
+
+	status = spi_bitbang_start(&at91_spi->bitbang);
+	if (status < 0)
+		(void) spi_master_put(at91_spi->bitbang.master);
+
+	return status;
+}
+
+static int __exit at91_spi_remove(struct platform_device *pdev)
+{
+	struct at91_spi	*at91_spi = platform_get_drvdata(pdev);
+	int status;
+
+	/* stop() unregisters child devices too */
+	status = spi_bitbang_stop(&at91_spi->bitbang);
+	(void) spi_master_put(at91_spi->bitbang.master);
+
+	platform_set_drvdata(pdev, NULL);
+	return status;
+}
+
+static struct platform_driver at91_spi_driver = {
+	.probe		= at91_spi_probe,
+	.remove		= __exit_p(at91_spi_remove),
+	.driver		= {
+		.name	= "at91_spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91_spi_init(void)
+{
+	at91_set_gpio_output(spi_sck_bit, 0);
+	at91_set_gpio_output(spi_mosi_bit, 0);
+	at91_set_gpio_input(spi_miso_bit, 1 /* pullup */);
+
+	/* register driver */
+	return platform_driver_register(&at91_spi_driver);
+}
+
+static void __exit at91_spi_exit(void)
+{
+	platform_driver_unregister(&at91_spi_driver);
+}
+
+device_initcall(at91_spi_init);
+module_exit(at91_spi_exit);
+
+MODULE_ALIAS("at91_spi.0");
+
+MODULE_DESCRIPTION("AT91 SPI support (BOOTSTRAP/BITBANG VERSION)");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/drivers/usb/core/hub.c linux-2.6.22_9260/drivers/usb/core/hub.c
--- linux-2.6.22/drivers/usb/core/hub.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/usb/core/hub.c	2014-08-26 16:23:29.819381620 +0800
@@ -31,6 +31,8 @@
 #include "hcd.h"
 #include "hub.h"
 
+u16 ralinkID = 0; /* Add By WENJING 2010-04-15, call by L350Detect Driver */
+
 struct usb_hub {
 	struct device		*intfdev;	/* the "interface" device */
 	struct usb_device	*hdev;
@@ -1182,6 +1184,11 @@
 
 #endif
 
+
+/* modified on 08-12-02 */
+int device_disconnected = 0;
+DECLARE_WAIT_QUEUE_HEAD(wait_ttyUSB0_disconnect);
+
 /**
  * usb_disconnect - disconnect a device (usbcore-internal)
  * @pdev: pointer to device being disconnected
@@ -1251,8 +1258,18 @@
 	usb_stop_pm(udev);
 
 	put_device(&udev->dev);
+
+        /* modified on 08-12-02 */
+	spin_lock_irq(&device_state_lock);
+        device_disconnected = 1;	
+        wake_up(&wait_ttyUSB0_disconnect);
+	spin_unlock_irq(&device_state_lock);
 }
 
+/* modified on 08-12-02 */
+EXPORT_SYMBOL(device_disconnected);
+EXPORT_SYMBOL(wait_ttyUSB0_disconnect);
+
 #ifdef DEBUG
 static void show_string(struct usb_device *udev, char *id, char *string)
 {
@@ -1312,7 +1329,17 @@
 			udev->descriptor.iManufacturer);
 	udev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);
 
+    /*Add by guoqingdong 2011.4.20*/
+    printk("%s ##idVendor = 0x%04x,idProduct = 0x%04x\n", \
+                           __FILE__, udev->descriptor.idVendor,udev->descriptor.idProduct);
+    /*Add end*/
+
 	/* Tell the world! */
+	if(0x148f == udev->descriptor.idVendor)
+	{
+	    ralinkID = udev->descriptor.idProduct;
+	}
+	
 	dev_dbg(&udev->dev, "new device strings: Mfr=%d, Product=%d, "
 			"SerialNumber=%d\n",
 			udev->descriptor.iManufacturer,
@@ -3119,4 +3146,5 @@
 	usb_autosuspend_device(udev);
 	return ret;
 }
+EXPORT_SYMBOL(ralinkID);
 EXPORT_SYMBOL(usb_reset_composite_device);
diff -uNrbBw linux-2.6.22/drivers/usb/gadget/at91_udc.c linux-2.6.22_9260/drivers/usb/gadget/at91_udc.c
--- linux-2.6.22/drivers/usb/gadget/at91_udc.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/usb/gadget/at91_udc.c	2014-08-26 16:22:54.475390718 +0800
@@ -1803,7 +1803,7 @@
 	 */
 	if ((!udc->suspended && udc->addr)
 			|| !wake
-			|| at91_suspend_entering_slow_clock()) {
+			|| clk_must_disable(udc->fclk)) {
 		pullup(udc, 0);
 		wake = 0;
 	} else
diff -uNrbBw linux-2.6.22/drivers/usb/host/ohci-at91.c linux-2.6.22_9260/drivers/usb/host/ohci-at91.c
--- linux-2.6.22/drivers/usb/host/ohci-at91.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/usb/host/ohci-at91.c	2014-08-26 16:22:54.476387033 +0800
@@ -299,7 +299,7 @@
 	 *
 	 * REVISIT: some boards will be able to turn VBUS off...
 	 */
-	if (at91_suspend_entering_slow_clock()) {
+	if (clk_must_disable(fclk)) {
 		ohci_usb_reset (ohci);
 		at91_stop_clock();
 	}
diff -uNrbBw linux-2.6.22/drivers/usb/serial/option.c linux-2.6.22_9260/drivers/usb/serial/option.c
--- linux-2.6.22/drivers/usb/serial/option.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/usb/serial/option.c	2014-08-26 16:23:29.820817591 +0800
@@ -120,6 +120,17 @@
 
 #define DELL_VENDOR_ID				0x413C
 
+/*Add by guoqingdong 2011.4.20*/
+#define TELIT_VENDOR_ID                 0x1bc7
+#define TELIT_PRODUCT_UC864E            0x1003
+#define SIMCOM_VENDOR_ID                0x05C6
+#define SIMCOM_PRODUCT_SIM5215          0x9000
+#define GHL_VENDOR_ID1                  0x0416  /*The new USB PBX, written by LuYijie*/
+#define GHL_PRODUCT_USBPBX1             0x5011
+#define GHL_VENDOR_ID2                  0x10c4  /*The old USB PBX, written by MeiLei*/
+#define GHL_PRODUCT_USBPBX2             0x0003
+/*Add end*/
+
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -158,6 +169,12 @@
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_ETNA_KOI_NETWORK) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E600) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E220) },
+    /*Add by guoqingdong 2011.4.20*/
+    { USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UC864E) },
+    { USB_DEVICE(SIMCOM_VENDOR_ID, SIMCOM_PRODUCT_SIM5215) },
+    { USB_DEVICE(GHL_VENDOR_ID1, GHL_PRODUCT_USBPBX1) },
+    { USB_DEVICE(GHL_VENDOR_ID2, GHL_PRODUCT_USBPBX2) },
+    /*Add end*/    
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1100) }, /* Novatel Merlin XS620/S640 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1110) }, /* Novatel Merlin S620 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1120) }, /* Novatel Merlin EX720 */
diff -uNrbBw linux-2.6.22/drivers/usb/serial/usb-serial.c linux-2.6.22_9260/drivers/usb/serial/usb-serial.c
--- linux-2.6.22/drivers/usb/serial/usb-serial.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/usb/serial/usb-serial.c	2014-08-26 16:23:29.823384996 +0800
@@ -39,6 +39,39 @@
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/"
 #define DRIVER_DESC "USB Serial Driver core"
 
+
+/*Add by guoqingdong*/
+#define GHL_USB_SERIAL  1
+
+#define TELIT_VENDOR_ID                 0x1bc7
+#define TELIT_PRODUCT_UC864E            0x1003
+#define SIMCOM_VENDOR_ID                0x05C6
+#define SIMCOM_PRODUCT_SIM5215          0x9000
+#define GHL_VENDOR_ID1                  0x0416  /*The new USB PBX, written by LuYijie*/
+#define GHL_PRODUCT_USBPBX1             0x5011
+#define GHL_VENDOR_ID2                  0x10c4  /*The old USB PBX, written by MeiLei*/
+#define GHL_PRODUCT_USBPBX2             0x0003
+
+#ifdef GHL_USB_SERIAL
+#define GSM_MODEM     0
+#define USB_PBX       1
+#define USB_RS232     2
+
+struct ghl_usb_gadget
+{
+    int   type;
+    int   minor_start;
+    int   minor_end;
+};
+
+static struct ghl_usb_gadget gadget[] = {
+    {GSM_MODEM, 0, 10},
+    {USB_PBX, 10, 20},
+    {USB_RS232, 20, 30},
+};
+#endif
+/*Add end*/
+
 static void port_free(struct usb_serial_port *port);
 
 /* Driver structure we register with the USB core */
@@ -78,18 +111,62 @@
 {
 	unsigned int i, j;
 	int good_spot;
+    int iVendorID;
+    int iProductID;
+    int type = -1;
+
+    iVendorID = serial->dev->descriptor.idVendor;
+    iProductID = serial->dev->descriptor.idProduct;
 
 	dbg("%s %d", __FUNCTION__, num_ports);
 
+    /*Add by guoqingdong 2011.5.23*/
+    if( SIMCOM_VENDOR_ID == iVendorID && SIMCOM_PRODUCT_SIM5215 == iProductID) {
+        type = GSM_MODEM;
+    }
+    else if( TELIT_VENDOR_ID == iVendorID && TELIT_PRODUCT_UC864E == iProductID) {
+        type = GSM_MODEM;
+    }
+    else if((GHL_VENDOR_ID1 == iVendorID && GHL_PRODUCT_USBPBX1 == iProductID) \
+            || (GHL_VENDOR_ID2 == iVendorID && GHL_PRODUCT_USBPBX2 == iProductID)) {
+        type = USB_PBX;
+    }
+    /*Add end*/
+
 	*minor = 0;
 	spin_lock(&table_lock);
-	for (i = 0; i < SERIAL_TTY_MINORS; ++i) {
+#ifdef GHL_USB_SERIAL
+    for (i = gadget[type].minor_start; i < gadget[type].minor_end; ++i) 
+#else    
+    for (i = 0; i < SERIAL_TTY_MINORS; ++i) 
+#endif
+    {
 		if (serial_table[i])
 			continue;
-
+#if 0
+        if( SIMCOM_VENDOR_ID == iVendorID && SIMCOM_PRODUCT_SIM5215 == iProductID) {
+            if(0 == i || 1 == i || 4 == i)
+            {
+                printk("++INFO: SIM5215 USB #%d doesn't support.\n",i);
+                continue;
+            } 
+        } 
+        else if( TELIT_VENDOR_ID == iVendorID && TELIT_PRODUCT_UC864E == iProductID) {
+            if(1 == i)
+            {
+                printk("++INFO: UC864E USB #%d doesn't support.\n", i);
+                continue;
+            } 
+        }     
+#endif
 		good_spot = 1;
 		for (j = 1; j <= num_ports-1; ++j)
-			if ((i+j >= SERIAL_TTY_MINORS) || (serial_table[i+j])) {
+#ifdef GHL_USB_SERIAL
+            if ((i+j >= gadget[type].minor_end) || (serial_table[i+j])) 
+#else               
+            if ((i+j >= SERIAL_TTY_MINORS) || (serial_table[i+j])) 
+#endif                
+            {
 				good_spot = 0;
 				i += j;
 				break;
@@ -100,7 +177,12 @@
 		*minor = i;
 		j = 0;
 		dbg("%s - minor base = %d", __FUNCTION__, *minor);
-		for (i = *minor; (i < (*minor + num_ports)) && (i < SERIAL_TTY_MINORS); ++i) {
+#ifdef GHL_USB_SERIAL
+        for (i = *minor; (i < (*minor + num_ports)) && (i < gadget[type].minor_end); ++i) 
+#else
+        for (i = *minor; (i < (*minor + num_ports)) && (i < SERIAL_TTY_MINORS); ++i) 
+#endif
+        {
 			serial_table[i] = serial;
 			serial->port[j++]->number = i;
 		}
@@ -688,6 +770,24 @@
 	int num_ports = 0;
 	int max_endpoints;
 
+    /*Add by guoqingdong 2011.5.23*/
+    int iVendorID;
+    int iProductID;
+                
+    iVendorID = dev->descriptor.idVendor;
+    iProductID = dev->descriptor.idProduct;
+
+    if( SIMCOM_VENDOR_ID == iVendorID && SIMCOM_PRODUCT_SIM5215 == iProductID) {
+        if(interface == dev->actconfig->interface[0] || interface == dev->actconfig->interface[1] \
+            || interface == dev->actconfig->interface[4])
+            return -ENODEV; 
+    }
+    else if( TELIT_VENDOR_ID == iVendorID && TELIT_PRODUCT_UC864E == iProductID) {
+        if(interface == dev->actconfig->interface[1])
+            return -ENODEV;
+    }    
+    /*Add end*/
+
 	lock_kernel(); /* guard against unloading a serial driver module */
 	type = search_serial_device(interface);
 	if (!type) {
diff -uNrbBw linux-2.6.22/drivers/video/atmel_lcdfb.c linux-2.6.22_9260/drivers/video/atmel_lcdfb.c
--- linux-2.6.22/drivers/video/atmel_lcdfb.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/atmel_lcdfb.c	2014-08-26 16:23:12.722380813 +0800
@@ -79,6 +79,29 @@
 	.accel		= FB_ACCEL_NONE,
 };
 
+static unsigned long compute_hozval(unsigned long xres, unsigned long lcdcon2)
+{
+	unsigned long value;
+
+	if (!(cpu_is_at91sam9261() || cpu_is_at32ap7000()))
+		return xres;
+
+	value = xres;
+	if ((lcdcon2 & ATMEL_LCDC_DISTYPE) != ATMEL_LCDC_DISTYPE_TFT) {
+		/* STN display */
+		if ((lcdcon2 & ATMEL_LCDC_DISTYPE) == ATMEL_LCDC_DISTYPE_STNCOLOR) {
+			value *= 3;
+		}
+		if ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_4
+		   || ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_8
+		      && (lcdcon2 & ATMEL_LCDC_SCANMOD) == ATMEL_LCDC_SCANMOD_DUAL ))
+			value = DIV_ROUND_UP(value, 4);
+		else
+			value = DIV_ROUND_UP(value, 8);
+	}
+
+	return value;
+}
 
 static void atmel_lcdfb_update_dma(struct fb_info *info,
 			       struct fb_var_screeninfo *var)
@@ -181,6 +204,7 @@
 	var->xoffset = var->yoffset = 0;
 
 	switch (var->bits_per_pixel) {
+	case 1:
 	case 2:
 	case 4:
 	case 8:
@@ -195,8 +219,11 @@
 		var->blue.offset = 10;
 		var->red.length = var->green.length = var->blue.length = 5;
 		break;
-	case 24:
 	case 32:
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		/* fall through */
+	case 24:
 		var->red.offset = 0;
 		var->green.offset = 8;
 		var->blue.offset = 16;
@@ -228,8 +255,10 @@
 static int atmel_lcdfb_set_par(struct fb_info *info)
 {
 	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long hozval_linesz;
 	unsigned long value;
 	unsigned long clk_value_khz;
+	unsigned long bits_per_line;
 
 	dev_dbg(info->device, "%s:\n", __func__);
 	dev_dbg(info->device, "  * resolution: %ux%u (%ux%u virtual)\n",
@@ -241,12 +270,15 @@
 
 	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
 
-	if (info->var.bits_per_pixel <= 8)
+	if (info->var.bits_per_pixel == 1)
+		info->fix.visual = FB_VISUAL_MONO01;
+	else if (info->var.bits_per_pixel <= 8)
 		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
 	else
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 
-	info->fix.line_length = info->var.xres_virtual * (info->var.bits_per_pixel / 8);
+	bits_per_line = info->var.xres_virtual * info->var.bits_per_pixel;
+	info->fix.line_length = DIV_ROUND_UP(bits_per_line, 8);
 
 	/* Re-initialize the DMA engine... */
 	dev_dbg(info->device, "  * update DMA engine\n");
@@ -262,18 +294,21 @@
 	/* Set pixel clock */
 	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
 
-	value = clk_value_khz / PICOS2KHZ(info->var.pixclock);
-
-	if (clk_value_khz % PICOS2KHZ(info->var.pixclock))
-		value++;
+	value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
 
 	value = (value / 2) - 1;
+	dev_dbg(info->device, "  * programming CLKVAL = 0x%08lx\n", value);
 
 	if (value <= 0) {
 		dev_notice(info->device, "Bypassing pixel clock divider\n");
 		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
-	} else
+	} else {
 		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, value << ATMEL_LCDC_CLKVAL_OFFSET);
+		info->var.pixclock = KHZ2PICOS(clk_value_khz / (2 * (value + 1)));
+		dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
+					PICOS2KHZ(info->var.pixclock));
+	}
+
 
 	/* Initialize control register 2 */
 	value = sinfo->default_lcdcon2;
@@ -311,9 +346,14 @@
 	dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
 	lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
 
+	/* Horizontal value (aka line size) */
+	hozval_linesz = compute_hozval(info->var.xres,
+					lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2));
+
 	/* Display size */
-	value = (info->var.xres - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
+	value = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
 	value |= info->var.yres - 1;
+	dev_dbg(info->device, "  * LCDFRMCFG = %08lx\n", value);
 	lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
 
 	/* FIFO Threshold: Use formula from data sheet */
@@ -421,6 +461,15 @@
 			ret = 0;
 		}
 		break;
+
+	case FB_VISUAL_MONO01:
+		if (regno < 2) {
+			val = (regno == 0) ? 0x00 : 0x1F;
+			lcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);
+			ret = 0;
+		}
+		break;
+
 	}
 
 	return ret;
diff -uNrbBw linux-2.6.22/drivers/video/backlight/kb920x_bl.c linux-2.6.22_9260/drivers/video/backlight/kb920x_bl.c
--- linux-2.6.22/drivers/video/backlight/kb920x_bl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/backlight/kb920x_bl.c	2014-08-26 16:22:54.459403713 +0800
@@ -0,0 +1,164 @@
+/*
+ * Backlight Driver for KB9202
+ *
+ * Copyright (c) 2006 KwikByte
+ *
+ * Based on Sharp's Corgi Backlight Driver
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+
+#include <asm/arch/gpio.h>
+
+/* The backlight is on(1)/off(0) */
+#define	KB9202_DEFAULT_INTENSITY	1
+#define	KB9202_MAX_INTENSITY		1
+
+static int kb9202bl_suspended;
+static int current_intensity = 0;
+static DEFINE_SPINLOCK(bl_lock);
+
+static int kb9202bl_set_intensity(struct backlight_device *bd)
+{
+	unsigned long flags;
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (kb9202bl_suspended)
+		intensity = 0;
+
+	if ((!current_intensity) && (bd->props.power == FB_BLANK_UNBLANK))
+		intensity = 1;
+
+	spin_lock_irqsave(&bl_lock, flags);
+	if (intensity)
+		gpio_set_value(AT91_PIN_PC23, 1);
+	else
+		gpio_set_value(AT91_PIN_PC23, 0);
+	spin_unlock_irqrestore(&bl_lock, flags);
+
+	current_intensity = intensity;
+
+	return 0;
+}
+
+static int kb9202bl_get_intensity(struct backlight_device *bd)
+{
+	return current_intensity;
+}
+
+static struct backlight_ops kb9202bl_ops = {
+	.get_brightness	= kb9202bl_get_intensity,
+	.update_status	= kb9202bl_set_intensity,
+};
+
+static int __init kb9202bl_probe(struct platform_device *pdev)
+{
+	struct backlight_device *bd;
+
+	bd = backlight_device_register ("kb9202-bl", &pdev->dev, NULL, &kb9202bl_ops);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
+
+	platform_set_drvdata(pdev, bd);
+
+	bd->props.max_brightness = KB9202_MAX_INTENSITY;
+	bd->props.brightness = KB9202_DEFAULT_INTENSITY;
+	(void) kb9202bl_set_intensity(bd);
+
+	return 0;
+}
+
+static int kb9202bl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	bd->props.brightness = 0;
+	bd->props.power = 0;
+	(void) kb9202bl_set_intensity(bd);
+
+	backlight_device_unregister(bd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int kb9202bl_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	kb9202bl_suspended = 1;
+	(void) kb9202bl_set_intensity(bd);
+	return 0;
+}
+
+static int kb9202bl_resume(struct platform_device *dev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	kb9202bl_suspended = 0;
+	(void) kb9202bl_set_intensity(bd);
+	return 0;
+}
+#else
+#define kb9202bl_suspend	NULL
+#define kb9202bl_resume		NULL
+#endif
+
+static struct platform_driver kb9202bl_driver = {
+	.probe		= kb9202bl_probe,
+	.remove		= kb9202bl_remove,
+	.suspend	= kb9202bl_suspend,
+	.resume		= kb9202bl_resume,
+	.driver		= {
+		.name	= "kb9202-bl",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_device *kb9202bl_device;
+
+static int __init kb9202bl_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&kb9202bl_driver);
+	if (!ret) {
+		kb9202bl_device = platform_device_alloc("kb9202-bl", -1);
+		if (!kb9202bl_device)
+			return -ENOMEM;
+
+		ret = platform_device_add(kb9202bl_device);
+		if (ret) {
+			platform_device_put(kb9202bl_device);
+			platform_driver_unregister(&kb9202bl_driver);
+		}
+	}
+	return ret;
+}
+
+static void __exit kb9202bl_exit(void)
+{
+	platform_device_unregister(kb9202bl_device);
+	platform_driver_unregister(&kb9202bl_driver);
+}
+
+module_init(kb9202bl_init);
+module_exit(kb9202bl_exit);
+
+MODULE_AUTHOR("KwikByte <kb9200_dev@kwikbyte.com>");
+MODULE_DESCRIPTION("KB9202 Backlight Driver");
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/drivers/video/backlight/Kconfig linux-2.6.22_9260/drivers/video/backlight/Kconfig
--- linux-2.6.22/drivers/video/backlight/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/backlight/Kconfig	2014-08-26 16:22:54.459403713 +0800
@@ -71,3 +71,11 @@
 	help
 	  If you have a Intel LE80578 (Carillo Ranch) say Y to enable the
 	  backlight driver.
+
+config BACKLIGHT_KB920x
+	tristate "KwikByte KB9202 Backlight Driver"
+	depends on BACKLIGHT_CLASS_DEVICE && MACH_KB9200
+	default y
+	help
+	  If you have a KwikByte KB9202 board, say Y to enable the
+	  backlight driver.
diff -uNrbBw linux-2.6.22/drivers/video/backlight/Makefile linux-2.6.22_9260/drivers/video/backlight/Makefile
--- linux-2.6.22/drivers/video/backlight/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/backlight/Makefile	2014-08-26 16:22:54.459403713 +0800
@@ -7,3 +7,4 @@
 obj-$(CONFIG_BACKLIGHT_LOCOMO)	+= locomolcd.o
 obj-$(CONFIG_BACKLIGHT_PROGEAR) += progear_bl.o
 obj-$(CONFIG_BACKLIGHT_CARILLO_RANCH) += cr_bllcd.o
+obj-$(CONFIG_BACKLIGHT_KB920x)	+= kb920x_bl.o
diff -uNrbBw linux-2.6.22/drivers/video/Kconfig linux-2.6.22_9260/drivers/video/Kconfig
--- linux-2.6.22/drivers/video/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/Kconfig	2014-08-26 16:23:12.720504233 +0800
@@ -822,6 +822,17 @@
 	  framebuffer.  Product specs at
 	  <http://www.erd.epson.com/vdc/html/products.htm>.
 
+config FB_S1D15605
+	tristate "Epson S1D15605 framebuffer support"
+	depends on FB
+	default m if MACH_KB9200
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Build in support for the S1D15605 Epson Research 128x64
+	  LCD controller as a framebuffer.
+
 config FB_S1D13XXX
 	tristate "Epson S1D13XXX framebuffer support"
 	depends on FB
@@ -835,7 +846,7 @@
 
 config FB_ATMEL
 	tristate "AT91/AT32 LCD Controller support"
-	depends on FB && (ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || AVR32)
+	depends on FB && (ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || AVR32)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
@@ -849,6 +860,16 @@
 	  Say Y if you want to map Frame Buffer in internal SRAM. Say N if you want
 	  to let frame buffer in external SDRAM.
 
+config FB_ATMEL_STN
+	bool "Use a STN display with AT91/AT32 LCD Controller"
+	depends on FB_ATMEL && MACH_AT91SAM9261EK
+	default n
+	help
+	  Say Y if you want to connect a STN LCD display to the AT91/AT32 LCD
+	  Controller. Say N if you want to connect a TFT.
+
+	  If unsure, say N.
+
 config FB_NVIDIA
 	tristate "nVidia Framebuffer Support"
 	depends on FB && PCI
diff -uNrbBw linux-2.6.22/drivers/video/Makefile linux-2.6.22_9260/drivers/video/Makefile
--- linux-2.6.22/drivers/video/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/Makefile	2014-08-26 16:22:54.457387455 +0800
@@ -87,6 +87,7 @@
 obj-$(CONFIG_FB_SA1100)           += sa1100fb.o
 obj-$(CONFIG_FB_HIT)              += hitfb.o
 obj-$(CONFIG_FB_EPSON1355)	  += epson1355fb.o
+obj-$(CONFIG_FB_S1D15605)	  += s1d15605fb.o
 obj-$(CONFIG_FB_ATMEL)		  += atmel_lcdfb.o
 obj-$(CONFIG_FB_PVR2)             += pvr2fb.o
 obj-$(CONFIG_FB_VOODOO1)          += sstfb.o
diff -uNrbBw linux-2.6.22/drivers/video/s1d15605fb.c linux-2.6.22_9260/drivers/video/s1d15605fb.c
--- linux-2.6.22/drivers/video/s1d15605fb.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/drivers/video/s1d15605fb.c	2014-08-26 16:22:54.456394791 +0800
@@ -0,0 +1,659 @@
+/*
+ *  drivers/video/s1d15605.c
+ *
+ * Adapted from several sources including:
+ * 1) Driver for AT91 LCD Controller
+ *    Copyright (C) 2006 Atmel
+ *
+ * 2) Copyright (C) 2005 S. Kevin Hester
+ *
+ *   This file is subject to the terms and conditions of the GNU General Public
+ *   License. See the file COPYING in the main directory of this archive for
+ *   more details.
+ *
+ *   This is a basic framebuffer driver for the Optrex F-51320 128x64 mono LCD
+ *   display.  This display uses a clone of the common Epson SED 1531 display
+ *   controller.
+ *
+ *   I've heavily borrowed code from the vfb.c driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef DEBUG
+#define MSG(string, args...) printk("s1d15605fb:" string, ##args)
+#else
+#define MSG(string, args...)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+#include <asm/backlight.h>
+#endif
+
+#define VIDEOWIDTH		128
+#define VIDEOHEIGHT		64
+#define VIDEODEPTH		1	/* bits/pixel */
+#define VIDEOWIDTH_BYTES	((VIDEOWIDTH * VIDEODEPTH) / 8)
+
+/* The number of bytes that actually go to the device */
+#define ACTUALVIDEOMEMSIZE	(VIDEOWIDTH_BYTES * VIDEOHEIGHT)
+#define VIDEOMEMSIZE		PAGE_SIZE
+
+static struct fb_var_screeninfo s1d15605_default __initdata = {
+	.xres		= VIDEOWIDTH,
+	.yres		= VIDEOHEIGHT,
+	.xres_virtual	= VIDEOWIDTH,
+	.yres_virtual	= VIDEOHEIGHT,
+	.bits_per_pixel	= VIDEODEPTH,
+	.red		= { 0, 1, 0 },
+	.green		= { 0, 1, 0 },
+	.blue		= { 0, 1, 0 },
+	.activate	= FB_ACTIVATE_NOW,
+	.pixclock	= 20000,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo s1d15605_fix __initdata = {
+	.id		= "s1d15605",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_MONO10,
+	.xpanstep	= 0,
+	.ypanstep	= 0,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+struct s1d15605fb_info {
+	struct fb_info		*info;
+	char			*mmio;
+	unsigned long		reset_pin;
+	struct platform_device	*pdev;
+};
+
+/*
+ * LCD device interface
+ */
+#define	RESET_DISPLAY		0xE2
+#define	LCD_BIAS_1_9		0xA2
+#define	ADC_SELECT_REVERSE	0xA1
+#define	COMMON_OUTPUT_NORMAL	0xC0
+#define	V5_RESISTOR_RATIO	0x26
+#define	ELECTRONIC_VOLUME_SET	0x81
+#define	ELECTRONIC_VOLUME_INIT	0x20
+#define	POWER_CONTROL_SET	0x28
+#define	VOLTAGE_REGULATOR	0x02
+#define	VOLTAGE_FOLLOWER	0x01
+#define	BOOSTER_CIRCUIT		0x04
+#define	DISPLAY_ON		0xAF
+#define	START_LINE_SET		0x40
+#define	PAGE_ADDRESS_SET	0xB0
+#define	COLUMN_ADDRESS_HIGH	0x10
+#define	COLUMN_ADDRESS_LOW	0x00
+#define	RESISTOR_RATIO_START	0x20
+
+#define	NUM_OF_PAGES		8
+#define	NUM_OF_COLUMNS		128
+
+#define	WRITE_COMMAND(x)	__raw_writeb((x), (sinfo)->mmio)
+#define	READ_COMMAND		__raw_readb((sinfo)->mmio)
+#define	WRITE_DATA(x)		__raw_writeb((x), (sinfo)->mmio + (0x10000))
+#define	READ_DATA		__raw_readb((sinfo)->mmio + (0x10000))
+
+
+/*
+ *	s1d15605fb_resize_framebuffer
+ *
+ *	Free allocated space if different.  Allocate on new of changed.
+ *	Returns -ENOMEM if the new framebuffer can not be allocated,
+ *	zero on success.
+ */
+static int s1d15605fb_resize_framebuffer(struct s1d15605fb_info *sinfo)
+{
+	struct fb_info			*info = sinfo->info;
+	struct fb_fix_screeninfo	*fix = &info->fix;
+	struct fb_var_screeninfo	*var = &info->var;
+	unsigned int			new_size;
+	void				*new_vaddr;
+
+	new_size = ((var->xres_virtual * var->yres_virtual * var->bits_per_pixel) / 8);
+
+	MSG("%s: x (%d) y (%d) bpp (%d): new size 0x%08x\n", __FUNCTION__,
+		var->xres_virtual, var->yres_virtual, var->bits_per_pixel, new_size);
+
+	if (new_size == fix->smem_len)
+		return 0;
+
+	if (fix->smem_len) {
+		kfree(info->screen_base);
+	}
+
+	new_vaddr = kmalloc(new_size, GFP_KERNEL);
+
+	if (!new_vaddr) {
+		fix->smem_len = 0;
+		return -ENOMEM;
+	}
+
+	info->screen_base = new_vaddr;
+	fix->smem_start = (unsigned)new_vaddr;
+	fix->smem_len = new_size;
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+
+	dev_info(info->device,
+		"%luKiB frame buffer at %08lx (mapped at %p)\n",
+		(unsigned long)info->fix.smem_len / 1024,
+		(unsigned long)info->fix.smem_start,
+		info->screen_base);
+
+	return 0;
+}
+
+
+/*
+ * The s1d15605 seems to be divided into eight 128 pixel wide pages (from top to
+ * bottom) each page seems to be eight pixels high, where these eight pixels are
+ * one byte
+ */
+static void s1d15605_update(struct fb_info *info)
+{
+	struct s1d15605fb_info	*sinfo = info->par;
+	int			page, i, row, colmask;
+	u8			retVal, *rowPtr;
+
+	WRITE_COMMAND(START_LINE_SET);
+	for (page = 0; page < NUM_OF_PAGES; ++page) {
+		WRITE_COMMAND(PAGE_ADDRESS_SET + page);
+		WRITE_COMMAND(COLUMN_ADDRESS_HIGH);
+		WRITE_COMMAND(COLUMN_ADDRESS_LOW);
+
+		for (i = 0; i < NUM_OF_COLUMNS; ++i)
+		{
+			/* point of opportunity: optimization */
+			colmask = (1 << (i & 0x7));
+			rowPtr = (u8*)(info->screen_base);
+			rowPtr += (VIDEOWIDTH_BYTES * 8 * page);
+			rowPtr += (i >> 3);
+			retVal = 0;
+			for (row = 0; row < 8; ++row)
+			{
+				retVal = (retVal >> 1) | (((*rowPtr) & colmask) ? 0x80 : 0);
+				rowPtr += VIDEOWIDTH_BYTES;
+			}
+			WRITE_DATA(retVal);
+		}
+	}
+
+	WRITE_COMMAND(DISPLAY_ON);
+}
+
+
+/*
+ * Setting the video mode has been split into two parts.
+ * First part, xxxfb_check_var, must not write anything
+ * to hardware, it should only verify and adjust var.
+ * This means it doesn't alter par but it does use hardware
+ * data from it to check this var.
+ */
+static int s1d15605_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	/*
+	 * Some very basic checks
+	 */
+	if (!var->xres)
+		var->xres = 1;
+	if (!var->yres)
+		var->yres = 1;
+	if (var->xres > var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (var->yres > var->yres_virtual)
+		var->yres_virtual = var->yres;
+
+	if(var->bits_per_pixel > VIDEODEPTH)
+		return -EINVAL;
+
+	/*
+	 * Memory limit
+	 */
+	if (((var->yres_virtual * var->bits_per_pixel * var->yres_virtual) >> 3) >
+			ACTUALVIDEOMEMSIZE)
+		return -ENOMEM;
+
+	/*
+	 * Now that we checked it we alter var. The reason being is that the video
+	 * mode passed in might not work but slight changes to it might make it
+	 * work. This way we let the user know what is acceptable.
+	 */
+	switch (var->bits_per_pixel) {
+	case 1:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length
+			= var->bits_per_pixel;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	var->xoffset = var->yoffset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right =
+		var->transp.msb_right = 0;
+
+	return 0;
+}
+
+
+/*
+ * This routine actually sets the video mode. It's in here where we
+ * the hardware state info->par and fix which can be affected by the
+ * change in par. For this driver it doesn't do much.
+ */
+static int s1d15605_set_par(struct fb_info *info)
+{
+	int	ret;
+
+	MSG("%s:\n", __func__);
+	MSG("  * resolution: %ux%u (%ux%u virtual)\n",
+		 info->var.xres, info->var.yres,
+		 info->var.xres_virtual, info->var.yres_virtual);
+
+	ret = s1d15605fb_resize_framebuffer(info->par);
+
+	info->fix.visual = FB_VISUAL_MONO10;
+	return ret;
+}
+
+
+/*
+ * Set a single color register. The values supplied are already
+ * rounded down to the hardware's capabilities (according to the
+ * entries in the var structure). Return != 0 for invalid regno.
+ */
+static int s1d15605_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			u_int transp, struct fb_info *info)
+{
+	if (regno > 1)	/* no. of hw registers - we only do mono now */
+		return 1;
+
+	return 0;
+}
+
+
+/*
+ * Currently, the routine will simply shut-off the backlight and prevent
+ * updates/refreshes.  Modify according to application.
+ *
+ * 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off
+ */
+static int s1d15605_blank(int blank, struct fb_info *info)
+{
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if (blank)
+		pmac_backlight->props.power = FB_BLANK_POWERDOWN;
+	else
+		pmac_backlight->props.power = FB_BLANK_UNBLANK;
+	backlight_update_status(pmac_backlight);
+#endif
+	return 1;
+}
+
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ */
+/*
+static int s1d15605_pan_display(struct fb_var_screeninfo *var,
+			struct fb_info *info)
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset)
+			return -EINVAL;
+	} else {
+		if (var->xoffset + var->xres > info->var.xres_virtual ||
+		    var->yoffset + var->yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	return 0;
+}
+*/
+
+
+static void s1d15605_copyarea(struct fb_info *info, const struct fb_copyarea *region)
+{
+	cfb_copyarea(info, region);
+	s1d15605_update(info);
+}
+
+
+static void s1d15605_fillrect (struct fb_info *info, const struct fb_fillrect *rect)
+{
+	cfb_fillrect(info, rect);
+	s1d15605_update(info);
+}
+
+
+static void s1d15605_imageblit(struct fb_info *p, const struct fb_image *image)
+{
+	cfb_imageblit(p, image);
+	s1d15605_update(p);
+}
+
+
+/*
+ * Write the users data to our framebuffer, and then trigger a psuedo DMA
+ */
+static ssize_t s1d15605_write(struct file *file, const char *buf,
+			size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	int err;
+
+	if (p > info->fix.smem_len)
+		return -ENOSPC;
+	if (count >= info->fix.smem_len)
+		count = info->fix.smem_len;
+	err = 0;
+	if (count + p > info->fix.smem_len) {
+		count = info->fix.smem_len - p;
+		err = -ENOSPC;
+	}
+	if (count) {
+		char *base_addr;
+
+		base_addr = info->screen_base;
+		count -= copy_from_user(base_addr+p, buf, count);
+		*ppos += count;
+		err = -EFAULT;
+	}
+
+	s1d15605_update(info);
+
+	if (count)
+		return count;
+
+	return err;
+}
+
+#ifdef	USE_PRIVATE_VMA_FXS
+static void s1d15605_vma_open(struct vm_area_struct *vma)
+{
+	// FIXME - store stats in the device data via vm_private_data
+}
+
+
+static void s1d15605_vma_close(struct vm_area_struct *vma)
+{
+	// FIXME - store stats in the device data via vm_private_data
+}
+
+
+static struct page *s1d15605_vma_nopage(struct vm_area_struct *vma,
+				unsigned long address, int *type)
+{
+	struct page *page;
+	struct fb_info *info = vma->vm_private_data;
+
+	page = virt_to_page(info->screen_base);
+	get_page(page);
+
+	// FIXME - now someone has a link to our page, start periodically blitting
+	// latest updates to the actual device.
+
+	return page;
+}
+
+
+static struct vm_operations_struct s1d15605_vm_ops = {
+	.open	= s1d15605_vma_open,
+	.close	= s1d15605_vma_close,
+	.nopage	= s1d15605_vma_nopage
+};
+
+
+/* We don't do much here - because we have special vm_ops */
+static int s1d15605_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	vma->vm_ops = &s1d15605_vm_ops;
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_private_data = info;
+	s1d15605_vma_open(vma);
+
+	return 0;
+}
+#endif /* USE_PRIVATE_VMA_FXS */
+
+
+static struct fb_ops s1d15605fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= s1d15605_check_var,
+	.fb_set_par	= s1d15605_set_par,
+	.fb_setcolreg	= s1d15605_setcolreg,
+	.fb_blank	= s1d15605_blank,
+//	.fb_pan_display	= s1d15605_pan_display,
+	.fb_fillrect	= s1d15605_fillrect,
+	.fb_copyarea	= s1d15605_copyarea,
+	.fb_imageblit	= s1d15605_imageblit,
+	.fb_write	= s1d15605_write,
+#ifdef	USE_PRIVATE_VMA_FXS
+	.fb_mmap	= s1d15605_mmap,
+#endif
+};
+
+
+static void s1d15605_device_init(struct s1d15605fb_info *sinfo) {
+
+	char	value;
+
+	/* release the reset line by reading the device - proto hardware */
+	value = READ_COMMAND;
+	value = READ_COMMAND;
+
+#ifdef CONFIG_MACH_KB9200
+	/* new boards have dedicated reset line */
+	gpio_set_value(sinfo->reset_pin, 1);
+#endif
+
+	/* initialize the device within 5ms */
+	WRITE_COMMAND(RESET_DISPLAY);
+	WRITE_COMMAND(LCD_BIAS_1_9);
+	WRITE_COMMAND(ADC_SELECT_REVERSE);
+	WRITE_COMMAND(COMMON_OUTPUT_NORMAL);
+	WRITE_COMMAND(V5_RESISTOR_RATIO);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_SET);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_INIT);
+	WRITE_COMMAND(POWER_CONTROL_SET | VOLTAGE_REGULATOR | VOLTAGE_FOLLOWER | BOOSTER_CIRCUIT);
+	WRITE_COMMAND(DISPLAY_ON);
+
+	WRITE_COMMAND(RESISTOR_RATIO_START + 4);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_SET);
+	WRITE_COMMAND(0x33);
+}
+
+
+static int s1d15605fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info;
+	struct s1d15605fb_info *sinfo;
+	int ret;
+
+	MSG("%s\n", __func__);
+
+	if (!(info = framebuffer_alloc(sizeof(struct s1d15605fb_info), dev))) {
+		dev_err(dev, "Cannot allocate framebuffer struct\n");
+		return -ENOMEM;
+	}
+
+	sinfo = info->par;
+	sinfo->info = info;
+	sinfo->pdev = pdev;
+
+	if (pdev->num_resources < 2) {
+		dev_err(dev, "Resources unusable\n");
+		ret = -ENODEV;
+		goto free_info;
+	}
+
+	info->fbops = &s1d15605fb_ops;
+	strcpy(info->fix.id, pdev->name);
+
+	info->fix.mmio_start = pdev->resource[0].start;
+	info->fix.mmio_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+	sinfo->reset_pin = pdev->resource[1].start;
+
+	ret = s1d15605fb_resize_framebuffer(sinfo);
+	if (ret < 0) {
+		dev_err(dev, "Cannot resize framebuffer: %d\n", ret);
+		goto free_fb;
+	}
+
+	if (!request_mem_region(info->fix.mmio_start,
+				info->fix.mmio_len, pdev->name)) {
+		ret = -EBUSY;
+		goto free_fb;
+	}
+
+	sinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);
+	if (!sinfo->mmio) {
+		dev_err(dev, "Cannot map LCD memory region\n");
+		goto release_mem;
+	}
+
+	s1d15605_device_init(sinfo);
+
+	ret = fb_find_mode(&info->var, info, NULL, NULL, 0, NULL, 1);
+
+	if (!ret || (ret == 4))
+		info->var = s1d15605_default;
+
+	info->fix = s1d15605_fix;
+	info->flags = FBINFO_FLAG_DEFAULT |
+/*		FBINFO_HWACCEL_YPAN | */
+		FBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;
+
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register framebuffer device: %d\n", ret);
+		goto unmap_mmio;
+	}
+
+	dev_set_drvdata(dev, info);
+
+	memset(info->screen_base, 0, info->fix.smem_len);
+	info->var.activate |= FB_ACTIVATE_NOW;
+	ret = fb_set_var(info, &info->var);
+	if (ret) {
+		dev_warn(dev, "Unable to set display parameters\n");
+	}
+
+	info->var.activate &= ~(FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);
+
+	dev_dbg(dev, "%s SUCCESS\n", __func__);
+
+	dev_info(dev, "Driver $Revision: 1.1 $\n");
+
+	return 0;
+
+unmap_mmio:
+	iounmap(sinfo->mmio);
+release_mem:
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+free_fb:
+	kfree(info->screen_base);
+
+free_info:
+	framebuffer_release(info);
+
+	dev_dbg(dev, "%s FAILED\n", __func__);
+	return ret;
+}
+
+
+static int s1d15605fb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct s1d15605fb_info *sinfo = info->par;
+
+	if (!sinfo)
+		return 0;
+
+	unregister_framebuffer(info);
+
+	iounmap(sinfo->mmio);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+
+	kfree(info->screen_base);
+
+	dev_set_drvdata(dev, NULL);
+	framebuffer_release(info);
+	return 0;
+}
+
+
+static struct platform_driver s1d15605fb_driver = {
+	.probe		= s1d15605fb_probe,
+	.remove		= s1d15605fb_remove,
+	.driver		= {
+		.name	= "s1d15605fb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+static int __init s1d15605fb_init(void)
+{
+	return platform_driver_register(&s1d15605fb_driver);
+}
+
+
+static void __exit s1d15605fb_exit(void)
+{
+	platform_driver_unregister(&s1d15605fb_driver);
+}
+
+
+module_init(s1d15605fb_init);
+module_exit(s1d15605fb_exit);
+
+
+MODULE_AUTHOR("KwikByte");
+MODULE_DESCRIPTION("Epson S1D15605 LCD Controller framebuffer driver");
+MODULE_LICENSE("GPL");
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/at91_mci.h linux-2.6.22_9260/include/asm-arm/arch-at91/at91_mci.h
--- linux-2.6.22/include/asm-arm/arch-at91/at91_mci.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/at91_mci.h	2014-08-26 16:22:54.385401922 +0800
@@ -26,6 +26,9 @@
 #define AT91_MCI_MR		0x04		/* Mode Register */
 #define		AT91_MCI_CLKDIV		(0xff  <<  0)	/* Clock Divider */
 #define		AT91_MCI_PWSDIV		(7     <<  8)	/* Power Saving Divider */
+#define		AT91_MCI_RDPROOF	(1     << 11)	/* Read Proof Enable [SAM926[03] only] */
+#define		AT91_MCI_WRPROOF	(1     << 12)	/* Write Proof Enable [SAM926[03] only] */
+#define		AT91_MCI_PDCFBYTE	(1     << 13)	/* PDC Force Byte Transfer [SAM926[03] only] */
 #define		AT91_MCI_PDCPADV	(1     << 14)	/* PDC Padding Value */
 #define		AT91_MCI_PDCMODE	(1     << 15)	/* PDC-orientated Mode */
 #define		AT91_MCI_BLKLEN		(0xfff << 18)	/* Data Block Length */
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/at91_pmc.h linux-2.6.22_9260/include/asm-arm/arch-at91/at91_pmc.h
--- linux-2.6.22/include/asm-arm/arch-at91/at91_pmc.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/at91_pmc.h	2014-08-26 16:22:54.386394781 +0800
@@ -37,7 +37,9 @@
 #define	AT91_PMC_PCDR		(AT91_PMC + 0x14)	/* Peripheral Clock Disable Register */
 #define	AT91_PMC_PCSR		(AT91_PMC + 0x18)	/* Peripheral Clock Status Register */
 
-#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register */
+#define AT91_CKGR_UCKR		(AT91_PMC + 0x1C)	/* UTMI Clock Register [SAM9RL only] */
+
+#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register [not on SAM9RL] */
 #define		AT91_PMC_MOSCEN		(1    << 0)		/* Main Oscillator Enable */
 #define		AT91_PMC_OSCBYPASS	(1    << 1)		/* Oscillator Bypass [AT91SAM926x only] */
 #define		AT91_PMC_OSCOUNT	(0xff << 8)		/* Main Oscillator Start-up Time */
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/at91sam9260.h linux-2.6.22_9260/include/asm-arm/arch-at91/at91sam9260.h
--- linux-2.6.22/include/asm-arm/arch-at91/at91sam9260.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/at91sam9260.h	2014-08-26 16:23:29.829380557 +0800
@@ -1,20 +1,3766 @@
-/*
- * include/asm-arm/arch-at91/at91sam9260.h
- *
- * (C) 2006 Andrew Victor
- *
- * Common definitions.
- * Based on AT91SAM9260 datasheet revision A (Preliminary).
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
 #ifndef AT91SAM9260_H
 #define AT91SAM9260_H
 
+#ifndef __ASSEMBLY__
+typedef volatile unsigned int AT91_REG;
+#define AT91_CAST(a) (a)
+#else
+#define AT91_CAST(a)
+#endif
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SYS {
+	AT91_REG	 SDRAMC_MR; 	
+	AT91_REG	 SDRAMC_TR; 	
+	AT91_REG	 SDRAMC_CR; 	
+	AT91_REG	 SDRAMC_HSR; 	
+	AT91_REG	 SDRAMC_LPR; 	
+	AT91_REG	 SDRAMC_IER; 	
+	AT91_REG	 SDRAMC_IDR; 	
+	AT91_REG	 SDRAMC_IMR; 	
+	AT91_REG	 SDRAMC_ISR; 	
+	AT91_REG	 SDRAMC_MDR; 	
+	AT91_REG	 Reserved0[118]; 	
+	AT91_REG	 SMC_SETUP0; 	
+	AT91_REG	 SMC_PULSE0; 	
+	AT91_REG	 SMC_CYCLE0; 	
+	AT91_REG	 SMC_CTRL0; 	
+	AT91_REG	 SMC_SETUP1; 	
+	AT91_REG	 SMC_PULSE1; 	
+	AT91_REG	 SMC_CYCLE1; 	
+	AT91_REG	 SMC_CTRL1; 	
+	AT91_REG	 SMC_SETUP2; 	
+	AT91_REG	 SMC_PULSE2; 	
+	AT91_REG	 SMC_CYCLE2; 	
+	AT91_REG	 SMC_CTRL2; 	
+	AT91_REG	 SMC_SETUP3; 	
+	AT91_REG	 SMC_PULSE3; 	
+	AT91_REG	 SMC_CYCLE3; 	
+	AT91_REG	 SMC_CTRL3; 	
+	AT91_REG	 SMC_SETUP4; 	
+	AT91_REG	 SMC_PULSE4; 	
+	AT91_REG	 SMC_CYCLE4; 	
+	AT91_REG	 SMC_CTRL4; 	
+	AT91_REG	 SMC_SETUP5; 	
+	AT91_REG	 SMC_PULSE5; 	
+	AT91_REG	 SMC_CYCLE5; 	
+	AT91_REG	 SMC_CTRL5; 	
+	AT91_REG	 SMC_SETUP6; 	
+	AT91_REG	 SMC_PULSE6; 	
+	AT91_REG	 SMC_CYCLE6; 	
+	AT91_REG	 SMC_CTRL6; 	
+	AT91_REG	 SMC_SETUP7; 	
+	AT91_REG	 SMC_PULSE7; 	
+	AT91_REG	 SMC_CYCLE7; 	
+	AT91_REG	 SMC_CTRL7; 	
+	AT91_REG	 Reserved1[96]; 	
+	AT91_REG	 MATRIX_MCFG0; 	
+	AT91_REG	 MATRIX_MCFG1; 	
+	AT91_REG	 MATRIX_MCFG2; 	
+	AT91_REG	 MATRIX_MCFG3; 	
+	AT91_REG	 MATRIX_MCFG4; 	
+	AT91_REG	 MATRIX_MCFG5; 	
+	AT91_REG	 MATRIX_MCFG6; 	
+	AT91_REG	 MATRIX_MCFG7; 	
+	AT91_REG	 Reserved2[8]; 	
+	AT91_REG	 MATRIX_SCFG0; 	
+	AT91_REG	 MATRIX_SCFG1; 	
+	AT91_REG	 MATRIX_SCFG2; 	
+	AT91_REG	 MATRIX_SCFG3; 	
+	AT91_REG	 MATRIX_SCFG4; 	
+	AT91_REG	 Reserved3[11]; 	
+	AT91_REG	 MATRIX_PRAS0; 	
+	AT91_REG	 MATRIX_PRBS0; 	
+	AT91_REG	 MATRIX_PRAS1; 	
+	AT91_REG	 MATRIX_PRBS1; 	
+	AT91_REG	 MATRIX_PRAS2; 	
+	AT91_REG	 MATRIX_PRBS2; 	
+	AT91_REG	 Reserved4[26]; 	
+	AT91_REG	 MATRIX_MRCR; 	
+	AT91_REG	 Reserved5[6]; 	
+	AT91_REG	 CCFG_EBICSA; 	
+	AT91_REG	 Reserved6[3]; 	
+	AT91_REG	 MATRIX_TEAKCFG; 	
+	AT91_REG	 Reserved7[51]; 	
+	AT91_REG	 CCFG_MATRIXVERSION; 	
+	AT91_REG	 AIC_SMR[32]; 	
+	AT91_REG	 AIC_SVR[32]; 	
+	AT91_REG	 AIC_IVR; 	
+	AT91_REG	 AIC_FVR; 	
+	AT91_REG	 AIC_ISR; 	
+	AT91_REG	 AIC_IPR; 	
+	AT91_REG	 AIC_IMR; 	
+	AT91_REG	 AIC_CISR; 	
+	AT91_REG	 Reserved8[2]; 	
+	AT91_REG	 AIC_IECR; 	
+	AT91_REG	 AIC_IDCR; 	
+	AT91_REG	 AIC_ICCR; 	
+	AT91_REG	 AIC_ISCR; 	
+	AT91_REG	 AIC_EOICR; 	
+	AT91_REG	 AIC_SPU; 	
+	AT91_REG	 AIC_DCR; 	
+	AT91_REG	 Reserved9[1]; 	
+	AT91_REG	 AIC_FFER; 	
+	AT91_REG	 AIC_FFDR; 	
+	AT91_REG	 AIC_FFSR; 	
+	AT91_REG	 Reserved10[45]; 	
+	AT91_REG	 DBGU_CR; 	
+	AT91_REG	 DBGU_MR; 	
+	AT91_REG	 DBGU_IER; 	
+	AT91_REG	 DBGU_IDR; 	
+	AT91_REG	 DBGU_IMR; 	
+	AT91_REG	 DBGU_CSR; 	
+	AT91_REG	 DBGU_RHR; 	
+	AT91_REG	 DBGU_THR; 	
+	AT91_REG	 DBGU_BRGR; 	
+	AT91_REG	 Reserved11[7]; 	
+	AT91_REG	 DBGU_CIDR; 	
+	AT91_REG	 DBGU_EXID; 	
+	AT91_REG	 DBGU_FNTR; 	
+	AT91_REG	 Reserved12[45]; 	
+	AT91_REG	 DBGU_RPR; 	
+	AT91_REG	 DBGU_RCR; 	
+	AT91_REG	 DBGU_TPR; 	
+	AT91_REG	 DBGU_TCR; 	
+	AT91_REG	 DBGU_RNPR; 	
+	AT91_REG	 DBGU_RNCR; 	
+	AT91_REG	 DBGU_TNPR; 	
+	AT91_REG	 DBGU_TNCR; 	
+	AT91_REG	 DBGU_PTCR; 	
+	AT91_REG	 DBGU_PTSR; 	
+	AT91_REG	 Reserved13[54]; 	
+	AT91_REG	 PIOA_PER; 	
+	AT91_REG	 PIOA_PDR; 	
+	AT91_REG	 PIOA_PSR; 	
+	AT91_REG	 Reserved14[1]; 	
+	AT91_REG	 PIOA_OER; 	
+	AT91_REG	 PIOA_ODR; 	
+	AT91_REG	 PIOA_OSR; 	
+	AT91_REG	 Reserved15[1]; 	
+	AT91_REG	 PIOA_IFER; 	
+	AT91_REG	 PIOA_IFDR; 	
+	AT91_REG	 PIOA_IFSR; 	
+	AT91_REG	 Reserved16[1]; 	
+	AT91_REG	 PIOA_SODR; 	
+	AT91_REG	 PIOA_CODR; 	
+	AT91_REG	 PIOA_ODSR; 	
+	AT91_REG	 PIOA_PDSR; 	
+	AT91_REG	 PIOA_IER; 	
+	AT91_REG	 PIOA_IDR; 	
+	AT91_REG	 PIOA_IMR; 	
+	AT91_REG	 PIOA_ISR; 	
+	AT91_REG	 PIOA_MDER; 	
+	AT91_REG	 PIOA_MDDR; 	
+	AT91_REG	 PIOA_MDSR; 	
+	AT91_REG	 Reserved17[1]; 	
+	AT91_REG	 PIOA_PPUDR; 	
+	AT91_REG	 PIOA_PPUER; 	
+	AT91_REG	 PIOA_PPUSR; 	
+	AT91_REG	 Reserved18[1]; 	
+	AT91_REG	 PIOA_ASR; 	
+	AT91_REG	 PIOA_BSR; 	
+	AT91_REG	 PIOA_ABSR; 	
+	AT91_REG	 Reserved19[9]; 	
+	AT91_REG	 PIOA_OWER; 	
+	AT91_REG	 PIOA_OWDR; 	
+	AT91_REG	 PIOA_OWSR; 	
+	AT91_REG	 Reserved20[85]; 	
+	AT91_REG	 PIOB_PER; 	
+	AT91_REG	 PIOB_PDR; 	
+	AT91_REG	 PIOB_PSR; 	
+	AT91_REG	 Reserved21[1]; 	
+	AT91_REG	 PIOB_OER; 	
+	AT91_REG	 PIOB_ODR; 	
+	AT91_REG	 PIOB_OSR; 	
+	AT91_REG	 Reserved22[1]; 	
+	AT91_REG	 PIOB_IFER; 	
+	AT91_REG	 PIOB_IFDR; 	
+	AT91_REG	 PIOB_IFSR; 	
+	AT91_REG	 Reserved23[1]; 	
+	AT91_REG	 PIOB_SODR; 	
+	AT91_REG	 PIOB_CODR; 	
+	AT91_REG	 PIOB_ODSR; 	
+	AT91_REG	 PIOB_PDSR; 	
+	AT91_REG	 PIOB_IER; 	
+	AT91_REG	 PIOB_IDR; 	
+	AT91_REG	 PIOB_IMR; 	
+	AT91_REG	 PIOB_ISR; 	
+	AT91_REG	 PIOB_MDER; 	
+	AT91_REG	 PIOB_MDDR; 	
+	AT91_REG	 PIOB_MDSR; 	
+	AT91_REG	 Reserved24[1]; 	
+	AT91_REG	 PIOB_PPUDR; 	
+	AT91_REG	 PIOB_PPUER; 	
+	AT91_REG	 PIOB_PPUSR; 	
+	AT91_REG	 Reserved25[1]; 	
+	AT91_REG	 PIOB_ASR; 	
+	AT91_REG	 PIOB_BSR; 	
+	AT91_REG	 PIOB_ABSR; 	
+	AT91_REG	 Reserved26[9]; 	
+	AT91_REG	 PIOB_OWER; 	
+	AT91_REG	 PIOB_OWDR; 	
+	AT91_REG	 PIOB_OWSR; 	
+	AT91_REG	 Reserved27[85]; 	
+	AT91_REG	 PIOC_PER; 	
+	AT91_REG	 PIOC_PDR; 	
+	AT91_REG	 PIOC_PSR; 	
+	AT91_REG	 Reserved28[1]; 	
+	AT91_REG	 PIOC_OER; 	
+	AT91_REG	 PIOC_ODR; 	
+	AT91_REG	 PIOC_OSR; 	
+	AT91_REG	 Reserved29[1]; 	
+	AT91_REG	 PIOC_IFER; 	
+	AT91_REG	 PIOC_IFDR; 	
+	AT91_REG	 PIOC_IFSR; 	
+	AT91_REG	 Reserved30[1]; 	
+	AT91_REG	 PIOC_SODR; 	
+	AT91_REG	 PIOC_CODR; 	
+	AT91_REG	 PIOC_ODSR; 	
+	AT91_REG	 PIOC_PDSR; 	
+	AT91_REG	 PIOC_IER; 	
+	AT91_REG	 PIOC_IDR; 	
+	AT91_REG	 PIOC_IMR; 	
+	AT91_REG	 PIOC_ISR; 	
+	AT91_REG	 PIOC_MDER; 	
+	AT91_REG	 PIOC_MDDR; 	
+	AT91_REG	 PIOC_MDSR; 	
+	AT91_REG	 Reserved31[1]; 	
+	AT91_REG	 PIOC_PPUDR; 	
+	AT91_REG	 PIOC_PPUER; 	
+	AT91_REG	 PIOC_PPUSR; 	
+	AT91_REG	 Reserved32[1]; 	
+	AT91_REG	 PIOC_ASR; 	
+	AT91_REG	 PIOC_BSR; 	
+	AT91_REG	 PIOC_ABSR; 	
+	AT91_REG	 Reserved33[9]; 	
+	AT91_REG	 PIOC_OWER; 	
+	AT91_REG	 PIOC_OWDR; 	
+	AT91_REG	 PIOC_OWSR; 	
+	AT91_REG	 Reserved34[213]; 	
+	AT91_REG	 PMC_SCER; 	
+	AT91_REG	 PMC_SCDR; 	
+	AT91_REG	 PMC_SCSR; 	
+	AT91_REG	 Reserved35[1]; 	
+	AT91_REG	 PMC_PCER; 	
+	AT91_REG	 PMC_PCDR; 	
+	AT91_REG	 PMC_PCSR; 	
+	AT91_REG	 Reserved36[1]; 	
+	AT91_REG	 PMC_MOR; 	
+	AT91_REG	 PMC_MCFR; 	
+	AT91_REG	 PMC_PLLAR; 	
+	AT91_REG	 PMC_PLLBR; 	
+	AT91_REG	 PMC_MCKR; 	
+	AT91_REG	 Reserved37[3]; 	
+	AT91_REG	 PMC_PCKR[8]; 	
+	AT91_REG	 PMC_IER; 	
+	AT91_REG	 PMC_IDR; 	
+	AT91_REG	 PMC_SR; 	
+	AT91_REG	 PMC_IMR; 	
+	AT91_REG	 Reserved38[36]; 	
+	AT91_REG	 RSTC_RCR; 	
+	AT91_REG	 RSTC_RSR; 	
+	AT91_REG	 RSTC_RMR; 	
+	AT91_REG	 Reserved39[1]; 	
+	AT91_REG	 SHDWC_SHCR; 	
+	AT91_REG	 SHDWC_SHMR; 	
+	AT91_REG	 SHDWC_SHSR; 	
+	AT91_REG	 Reserved40[1]; 	
+	AT91_REG	 RTTC_RTMR; 	
+	AT91_REG	 RTTC_RTAR; 	
+	AT91_REG	 RTTC_RTVR; 	
+	AT91_REG	 RTTC_RTSR; 	
+	AT91_REG	 PITC_PIMR; 	
+	AT91_REG	 PITC_PISR; 	
+	AT91_REG	 PITC_PIVR; 	
+	AT91_REG	 PITC_PIIR; 	
+	AT91_REG	 WDTC_WDCR; 	
+	AT91_REG	 WDTC_WDMR; 	
+	AT91_REG	 WDTC_WDSR; 	
+	AT91_REG	 Reserved41[1]; 	
+	AT91_REG	 SYS_GPBR0; 	
+	AT91_REG	 SYS_GPBR1; 	
+	AT91_REG	 SYS_GPBR2; 	
+	AT91_REG	 SYS_GPBR3; 	
+} AT91S_SYS, *AT91PS_SYS;
+#else
+#define SYS_GPBR0       (AT91_CAST(AT91_REG *) 	0x00001350) 
+#define SYS_GPBR1       (AT91_CAST(AT91_REG *) 	0x00001354) 
+#define SYS_GPBR2       (AT91_CAST(AT91_REG *) 	0x00001358) 
+#define SYS_GPBR3       (AT91_CAST(AT91_REG *) 	0x0000135C) 
+
+#endif
+
+
+
+
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_EBI {
+	AT91_REG	 EBI_DUMMY; 	
+} AT91S_EBI, *AT91PS_EBI;
+#else
+#define EBI_DUMMY       (AT91_CAST(AT91_REG *) 	0x00000000) 
+
+#endif
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_ECC {
+	AT91_REG	 ECC_CR; 	
+	AT91_REG	 ECC_MR; 	
+	AT91_REG	 ECC_SR; 	
+	AT91_REG	 ECC_PR; 	
+	AT91_REG	 ECC_NPR; 	
+	AT91_REG	 Reserved0[58]; 	
+	AT91_REG	 ECC_VR; 	
+} AT91S_ECC, *AT91PS_ECC;
+#else
+#define ECC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define ECC_MR          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define ECC_SR          (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define ECC_PR          (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define ECC_NPR         (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define ECC_VR          (AT91_CAST(AT91_REG *) 	0x000000FC) 
+
+#endif
+
+#define AT91C_ECC_RST         (0x1 <<  0) 
+
+#define AT91C_ECC_PAGE_SIZE   (0x3 <<  0) 
+
+#define AT91C_ECC_RECERR      (0x1 <<  0) 
+#define AT91C_ECC_ECCERR      (0x1 <<  1) 
+#define AT91C_ECC_MULERR      (0x1 <<  2) 
+
+#define AT91C_ECC_BITADDR     (0xF <<  0) 
+#define AT91C_ECC_WORDADDR    (0xFFF <<  4) 
+
+#define AT91C_ECC_NPARITY     (0xFFFF <<  0) 
+
+#define AT91C_ECC_VR          (0xF <<  0) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SDRAMC {
+	AT91_REG	 SDRAMC_MR; 	
+	AT91_REG	 SDRAMC_TR; 	
+	AT91_REG	 SDRAMC_CR; 	
+	AT91_REG	 SDRAMC_HSR; 	
+	AT91_REG	 SDRAMC_LPR; 	
+	AT91_REG	 SDRAMC_IER; 	
+	AT91_REG	 SDRAMC_IDR; 	
+	AT91_REG	 SDRAMC_IMR; 	
+	AT91_REG	 SDRAMC_ISR; 	
+	AT91_REG	 SDRAMC_MDR; 	
+} AT91S_SDRAMC, *AT91PS_SDRAMC;
+#else
+#define SDRAMC_MR       (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define SDRAMC_TR       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define SDRAMC_CR       (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define SDRAMC_HSR      (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define SDRAMC_LPR      (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define SDRAMC_IER      (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define SDRAMC_IDR      (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define SDRAMC_IMR      (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define SDRAMC_ISR      (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define SDRAMC_MDR      (AT91_CAST(AT91_REG *) 	0x00000024) 
+
+#endif
+
+#define AT91C_SDRAMC_MODE     (0xF <<  0) 
+#define 	AT91C_SDRAMC_MODE_NORMAL_CMD           (0x0) 
+#define 	AT91C_SDRAMC_MODE_NOP_CMD              (0x1) 
+#define 	AT91C_SDRAMC_MODE_PRCGALL_CMD          (0x2) 
+#define 	AT91C_SDRAMC_MODE_LMR_CMD              (0x3) 
+#define 	AT91C_SDRAMC_MODE_RFSH_CMD             (0x4) 
+#define 	AT91C_SDRAMC_MODE_EXT_LMR_CMD          (0x5) 
+#define 	AT91C_SDRAMC_MODE_DEEP_CMD             (0x6) 
+
+#define AT91C_SDRAMC_COUNT    (0xFFF <<  0) 
+
+#define AT91C_SDRAMC_NC       (0x3 <<  0) 
+#define 	AT91C_SDRAMC_NC_8                    (0x0) 
+#define 	AT91C_SDRAMC_NC_9                    (0x1) 
+#define 	AT91C_SDRAMC_NC_10                   (0x2) 
+#define 	AT91C_SDRAMC_NC_11                   (0x3) 
+#define AT91C_SDRAMC_NR       (0x3 <<  2) 
+#define 	AT91C_SDRAMC_NR_11                   (0x0 <<  2) 
+#define 	AT91C_SDRAMC_NR_12                   (0x1 <<  2) 
+#define 	AT91C_SDRAMC_NR_13                   (0x2 <<  2) 
+#define AT91C_SDRAMC_NB       (0x1 <<  4) 
+#define 	AT91C_SDRAMC_NB_2_BANKS              (0x0 <<  4) 
+#define 	AT91C_SDRAMC_NB_4_BANKS              (0x1 <<  4) 
+#define AT91C_SDRAMC_CAS      (0x3 <<  5) 
+#define 	AT91C_SDRAMC_CAS_2                    (0x2 <<  5) 
+#define 	AT91C_SDRAMC_CAS_3                    (0x3 <<  5) 
+#define AT91C_SDRAMC_DBW      (0x1 <<  7) 
+#define 	AT91C_SDRAMC_DBW_32_BITS              (0x0 <<  7) 
+#define 	AT91C_SDRAMC_DBW_16_BITS              (0x1 <<  7) 
+#define AT91C_SDRAMC_TWR      (0xF <<  8) 
+#define 	AT91C_SDRAMC_TWR_0                    (0x0 <<  8) 
+#define 	AT91C_SDRAMC_TWR_1                    (0x1 <<  8) 
+#define 	AT91C_SDRAMC_TWR_2                    (0x2 <<  8) 
+#define 	AT91C_SDRAMC_TWR_3                    (0x3 <<  8) 
+#define 	AT91C_SDRAMC_TWR_4                    (0x4 <<  8) 
+#define 	AT91C_SDRAMC_TWR_5                    (0x5 <<  8) 
+#define 	AT91C_SDRAMC_TWR_6                    (0x6 <<  8) 
+#define 	AT91C_SDRAMC_TWR_7                    (0x7 <<  8) 
+#define 	AT91C_SDRAMC_TWR_8                    (0x8 <<  8) 
+#define 	AT91C_SDRAMC_TWR_9                    (0x9 <<  8) 
+#define 	AT91C_SDRAMC_TWR_10                   (0xA <<  8) 
+#define 	AT91C_SDRAMC_TWR_11                   (0xB <<  8) 
+#define 	AT91C_SDRAMC_TWR_12                   (0xC <<  8) 
+#define 	AT91C_SDRAMC_TWR_13                   (0xD <<  8) 
+#define 	AT91C_SDRAMC_TWR_14                   (0xE <<  8) 
+#define 	AT91C_SDRAMC_TWR_15                   (0xF <<  8) 
+#define AT91C_SDRAMC_TRC      (0xF << 12) 
+#define 	AT91C_SDRAMC_TRC_0                    (0x0 << 12) 
+#define 	AT91C_SDRAMC_TRC_1                    (0x1 << 12) 
+#define 	AT91C_SDRAMC_TRC_2                    (0x2 << 12) 
+#define 	AT91C_SDRAMC_TRC_3                    (0x3 << 12) 
+#define 	AT91C_SDRAMC_TRC_4                    (0x4 << 12) 
+#define 	AT91C_SDRAMC_TRC_5                    (0x5 << 12) 
+#define 	AT91C_SDRAMC_TRC_6                    (0x6 << 12) 
+#define 	AT91C_SDRAMC_TRC_7                    (0x7 << 12) 
+#define 	AT91C_SDRAMC_TRC_8                    (0x8 << 12) 
+#define 	AT91C_SDRAMC_TRC_9                    (0x9 << 12) 
+#define 	AT91C_SDRAMC_TRC_10                   (0xA << 12) 
+#define 	AT91C_SDRAMC_TRC_11                   (0xB << 12) 
+#define 	AT91C_SDRAMC_TRC_12                   (0xC << 12) 
+#define 	AT91C_SDRAMC_TRC_13                   (0xD << 12) 
+#define 	AT91C_SDRAMC_TRC_14                   (0xE << 12) 
+#define 	AT91C_SDRAMC_TRC_15                   (0xF << 12) 
+#define AT91C_SDRAMC_TRP      (0xF << 16) 
+#define 	AT91C_SDRAMC_TRP_0                    (0x0 << 16) 
+#define 	AT91C_SDRAMC_TRP_1                    (0x1 << 16) 
+#define 	AT91C_SDRAMC_TRP_2                    (0x2 << 16) 
+#define 	AT91C_SDRAMC_TRP_3                    (0x3 << 16) 
+#define 	AT91C_SDRAMC_TRP_4                    (0x4 << 16) 
+#define 	AT91C_SDRAMC_TRP_5                    (0x5 << 16) 
+#define 	AT91C_SDRAMC_TRP_6                    (0x6 << 16) 
+#define 	AT91C_SDRAMC_TRP_7                    (0x7 << 16) 
+#define 	AT91C_SDRAMC_TRP_8                    (0x8 << 16) 
+#define 	AT91C_SDRAMC_TRP_9                    (0x9 << 16) 
+#define 	AT91C_SDRAMC_TRP_10                   (0xA << 16) 
+#define 	AT91C_SDRAMC_TRP_11                   (0xB << 16) 
+#define 	AT91C_SDRAMC_TRP_12                   (0xC << 16) 
+#define 	AT91C_SDRAMC_TRP_13                   (0xD << 16) 
+#define 	AT91C_SDRAMC_TRP_14                   (0xE << 16) 
+#define 	AT91C_SDRAMC_TRP_15                   (0xF << 16) 
+#define AT91C_SDRAMC_TRCD     (0xF << 20) 
+#define 	AT91C_SDRAMC_TRCD_0                    (0x0 << 20) 
+#define 	AT91C_SDRAMC_TRCD_1                    (0x1 << 20) 
+#define 	AT91C_SDRAMC_TRCD_2                    (0x2 << 20) 
+#define 	AT91C_SDRAMC_TRCD_3                    (0x3 << 20) 
+#define 	AT91C_SDRAMC_TRCD_4                    (0x4 << 20) 
+#define 	AT91C_SDRAMC_TRCD_5                    (0x5 << 20) 
+#define 	AT91C_SDRAMC_TRCD_6                    (0x6 << 20) 
+#define 	AT91C_SDRAMC_TRCD_7                    (0x7 << 20) 
+#define 	AT91C_SDRAMC_TRCD_8                    (0x8 << 20) 
+#define 	AT91C_SDRAMC_TRCD_9                    (0x9 << 20) 
+#define 	AT91C_SDRAMC_TRCD_10                   (0xA << 20) 
+#define 	AT91C_SDRAMC_TRCD_11                   (0xB << 20) 
+#define 	AT91C_SDRAMC_TRCD_12                   (0xC << 20) 
+#define 	AT91C_SDRAMC_TRCD_13                   (0xD << 20) 
+#define 	AT91C_SDRAMC_TRCD_14                   (0xE << 20) 
+#define 	AT91C_SDRAMC_TRCD_15                   (0xF << 20) 
+#define AT91C_SDRAMC_TRAS     (0xF << 24) 
+#define 	AT91C_SDRAMC_TRAS_0                    (0x0 << 24) 
+#define 	AT91C_SDRAMC_TRAS_1                    (0x1 << 24) 
+#define 	AT91C_SDRAMC_TRAS_2                    (0x2 << 24) 
+#define 	AT91C_SDRAMC_TRAS_3                    (0x3 << 24) 
+#define 	AT91C_SDRAMC_TRAS_4                    (0x4 << 24) 
+#define 	AT91C_SDRAMC_TRAS_5                    (0x5 << 24) 
+#define 	AT91C_SDRAMC_TRAS_6                    (0x6 << 24) 
+#define 	AT91C_SDRAMC_TRAS_7                    (0x7 << 24) 
+#define 	AT91C_SDRAMC_TRAS_8                    (0x8 << 24) 
+#define 	AT91C_SDRAMC_TRAS_9                    (0x9 << 24) 
+#define 	AT91C_SDRAMC_TRAS_10                   (0xA << 24) 
+#define 	AT91C_SDRAMC_TRAS_11                   (0xB << 24) 
+#define 	AT91C_SDRAMC_TRAS_12                   (0xC << 24) 
+#define 	AT91C_SDRAMC_TRAS_13                   (0xD << 24) 
+#define 	AT91C_SDRAMC_TRAS_14                   (0xE << 24) 
+#define 	AT91C_SDRAMC_TRAS_15                   (0xF << 24) 
+#define AT91C_SDRAMC_TXSR     (0xF << 28) 
+#define 	AT91C_SDRAMC_TXSR_0                    (0x0 << 28) 
+#define 	AT91C_SDRAMC_TXSR_1                    (0x1 << 28) 
+#define 	AT91C_SDRAMC_TXSR_2                    (0x2 << 28) 
+#define 	AT91C_SDRAMC_TXSR_3                    (0x3 << 28) 
+#define 	AT91C_SDRAMC_TXSR_4                    (0x4 << 28) 
+#define 	AT91C_SDRAMC_TXSR_5                    (0x5 << 28) 
+#define 	AT91C_SDRAMC_TXSR_6                    (0x6 << 28) 
+#define 	AT91C_SDRAMC_TXSR_7                    (0x7 << 28) 
+#define 	AT91C_SDRAMC_TXSR_8                    (0x8 << 28) 
+#define 	AT91C_SDRAMC_TXSR_9                    (0x9 << 28) 
+#define 	AT91C_SDRAMC_TXSR_10                   (0xA << 28) 
+#define 	AT91C_SDRAMC_TXSR_11                   (0xB << 28) 
+#define 	AT91C_SDRAMC_TXSR_12                   (0xC << 28) 
+#define 	AT91C_SDRAMC_TXSR_13                   (0xD << 28) 
+#define 	AT91C_SDRAMC_TXSR_14                   (0xE << 28) 
+#define 	AT91C_SDRAMC_TXSR_15                   (0xF << 28) 
+
+#define AT91C_SDRAMC_DA       (0x1 <<  0) 
+#define 	AT91C_SDRAMC_DA_DISABLE              (0x0) 
+#define 	AT91C_SDRAMC_DA_ENABLE               (0x1) 
+
+#define AT91C_SDRAMC_LPCB     (0x3 <<  0) 
+#define 	AT91C_SDRAMC_LPCB_DISABLE              (0x0) 
+#define 	AT91C_SDRAMC_LPCB_SELF_REFRESH         (0x1) 
+#define 	AT91C_SDRAMC_LPCB_POWER_DOWN           (0x2) 
+#define 	AT91C_SDRAMC_LPCB_DEEP_POWER_DOWN      (0x3) 
+#define AT91C_SDRAMC_PASR     (0x7 <<  4) 
+#define AT91C_SDRAMC_TCSR     (0x3 <<  8) 
+#define AT91C_SDRAMC_DS       (0x3 << 10) 
+#define AT91C_SDRAMC_TIMEOUT  (0x3 << 12) 
+#define 	AT91C_SDRAMC_TIMEOUT_0_CLK_CYCLES         (0x0 << 12) 
+#define 	AT91C_SDRAMC_TIMEOUT_64_CLK_CYCLES        (0x1 << 12) 
+#define 	AT91C_SDRAMC_TIMEOUT_128_CLK_CYCLES       (0x2 << 12) 
+
+#define AT91C_SDRAMC_RES      (0x1 <<  0) 
+
+
+
+
+#define AT91C_SDRAMC_MD       (0x3 <<  0) 
+#define 	AT91C_SDRAMC_MD_SDRAM                (0x0) 
+#define 	AT91C_SDRAMC_MD_LOW_POWER_SDRAM      (0x1) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SMC {
+	AT91_REG	 SMC_SETUP0; 	
+	AT91_REG	 SMC_PULSE0; 	
+	AT91_REG	 SMC_CYCLE0; 	
+	AT91_REG	 SMC_CTRL0; 	
+	AT91_REG	 SMC_SETUP1; 	
+	AT91_REG	 SMC_PULSE1; 	
+	AT91_REG	 SMC_CYCLE1; 	
+	AT91_REG	 SMC_CTRL1; 	
+	AT91_REG	 SMC_SETUP2; 	
+	AT91_REG	 SMC_PULSE2; 	
+	AT91_REG	 SMC_CYCLE2; 	
+	AT91_REG	 SMC_CTRL2; 	
+	AT91_REG	 SMC_SETUP3; 	
+	AT91_REG	 SMC_PULSE3; 	
+	AT91_REG	 SMC_CYCLE3; 	
+	AT91_REG	 SMC_CTRL3; 	
+	AT91_REG	 SMC_SETUP4; 	
+	AT91_REG	 SMC_PULSE4; 	
+	AT91_REG	 SMC_CYCLE4; 	
+	AT91_REG	 SMC_CTRL4; 	
+	AT91_REG	 SMC_SETUP5; 	
+	AT91_REG	 SMC_PULSE5; 	
+	AT91_REG	 SMC_CYCLE5; 	
+	AT91_REG	 SMC_CTRL5; 	
+	AT91_REG	 SMC_SETUP6; 	
+	AT91_REG	 SMC_PULSE6; 	
+	AT91_REG	 SMC_CYCLE6; 	
+	AT91_REG	 SMC_CTRL6; 	
+	AT91_REG	 SMC_SETUP7; 	
+	AT91_REG	 SMC_PULSE7; 	
+	AT91_REG	 SMC_CYCLE7; 	
+	AT91_REG	 SMC_CTRL7; 	
+} AT91S_SMC, *AT91PS_SMC;
+#else
+#define SETUP0          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define PULSE0          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define CYCLE0          (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define CTRL0           (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define SETUP1          (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define PULSE1          (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define CYCLE1          (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define CTRL1           (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define SETUP2          (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define PULSE2          (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define CYCLE2          (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define CTRL2           (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define SETUP3          (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define PULSE3          (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define CYCLE3          (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define CTRL3           (AT91_CAST(AT91_REG *) 	0x0000003C) 
+#define SETUP4          (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define PULSE4          (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define CYCLE4          (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define CTRL4           (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define SETUP5          (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define PULSE5          (AT91_CAST(AT91_REG *) 	0x00000054) 
+#define CYCLE5          (AT91_CAST(AT91_REG *) 	0x00000058) 
+#define CTRL5           (AT91_CAST(AT91_REG *) 	0x0000005C) 
+#define SETUP6          (AT91_CAST(AT91_REG *) 	0x00000060) 
+#define PULSE6          (AT91_CAST(AT91_REG *) 	0x00000064) 
+#define CYCLE6          (AT91_CAST(AT91_REG *) 	0x00000068) 
+#define CTRL6           (AT91_CAST(AT91_REG *) 	0x0000006C) 
+#define SETUP7          (AT91_CAST(AT91_REG *) 	0x00000070) 
+#define PULSE7          (AT91_CAST(AT91_REG *) 	0x00000074) 
+#define CYCLE7          (AT91_CAST(AT91_REG *) 	0x00000078) 
+#define CTRL7           (AT91_CAST(AT91_REG *) 	0x0000007C) 
+
+#endif
+
+#define AT91C_SMC_NWESETUP    (0x3F <<  0) 
+#define AT91C_SMC_NCSSETUPWR  (0x3F <<  8) 
+#define AT91C_SMC_NRDSETUP    (0x3F << 16) 
+#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) 
+
+#define AT91C_SMC_NWEPULSE    (0x7F <<  0) 
+#define AT91C_SMC_NCSPULSEWR  (0x7F <<  8) 
+#define AT91C_SMC_NRDPULSE    (0x7F << 16) 
+#define AT91C_SMC_NCSPULSERD  (0x7F << 24) 
+
+#define AT91C_SMC_NWECYCLE    (0x1FF <<  0) 
+#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) 
+
+#define AT91C_SMC_READMODE    (0x1 <<  0) 
+#define AT91C_SMC_WRITEMODE   (0x1 <<  1) 
+#define AT91C_SMC_NWAITM      (0x3 <<  5) 
+#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) 
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) 
+#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) 
+#define AT91C_SMC_BAT         (0x1 <<  8) 
+#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) 
+#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) 
+#define AT91C_SMC_DBW         (0x3 << 12) 
+#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) 
+#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) 
+#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) 
+#define AT91C_SMC_TDF         (0xF << 16) 
+#define AT91C_SMC_TDFEN       (0x1 << 20) 
+#define AT91C_SMC_PMEN        (0x1 << 24) 
+#define AT91C_SMC_PS          (0x3 << 28) 
+#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) 
+#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) 
+#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) 
+#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) 
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_MATRIX {
+	AT91_REG	 MATRIX_MCFG0; 	
+	AT91_REG	 MATRIX_MCFG1; 	
+	AT91_REG	 MATRIX_MCFG2; 	
+	AT91_REG	 MATRIX_MCFG3; 	
+	AT91_REG	 MATRIX_MCFG4; 	
+	AT91_REG	 MATRIX_MCFG5; 	
+	AT91_REG	 MATRIX_MCFG6; 	
+	AT91_REG	 MATRIX_MCFG7; 	
+	AT91_REG	 Reserved0[8]; 	
+	AT91_REG	 MATRIX_SCFG0; 	
+	AT91_REG	 MATRIX_SCFG1; 	
+	AT91_REG	 MATRIX_SCFG2; 	
+	AT91_REG	 MATRIX_SCFG3; 	
+	AT91_REG	 MATRIX_SCFG4; 	
+	AT91_REG	 Reserved1[11]; 	
+	AT91_REG	 MATRIX_PRAS0; 	
+	AT91_REG	 MATRIX_PRBS0; 	
+	AT91_REG	 MATRIX_PRAS1; 	
+	AT91_REG	 MATRIX_PRBS1; 	
+	AT91_REG	 MATRIX_PRAS2; 	
+	AT91_REG	 MATRIX_PRBS2; 	
+	AT91_REG	 Reserved2[26]; 	
+	AT91_REG	 MATRIX_MRCR; 	
+	AT91_REG	 Reserved3[6]; 	
+	AT91_REG	 MATRIX_EBI; 	
+	AT91_REG	 Reserved4[3]; 	
+	AT91_REG	 MATRIX_TEAKCFG; 	
+	AT91_REG	 Reserved5[51]; 	
+	AT91_REG	 MATRIX_VERSION; 	
+} AT91S_MATRIX, *AT91PS_MATRIX;
+#else
+#define MATRIX_MCFG0    (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define MATRIX_MCFG1    (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define MATRIX_MCFG2    (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define MATRIX_MCFG3    (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define MATRIX_MCFG4    (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define MATRIX_MCFG5    (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define MATRIX_MCFG6    (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define MATRIX_MCFG7    (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define MATRIX_SCFG0    (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define MATRIX_SCFG1    (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define MATRIX_SCFG2    (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define MATRIX_SCFG3    (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define MATRIX_SCFG4    (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define MATRIX_PRAS0    (AT91_CAST(AT91_REG *) 	0x00000080) 
+#define MATRIX_PRBS0    (AT91_CAST(AT91_REG *) 	0x00000084) 
+#define MATRIX_PRAS1    (AT91_CAST(AT91_REG *) 	0x00000088) 
+#define MATRIX_PRBS1    (AT91_CAST(AT91_REG *) 	0x0000008C) 
+#define MATRIX_PRAS2    (AT91_CAST(AT91_REG *) 	0x00000090) 
+#define MATRIX_PRBS2    (AT91_CAST(AT91_REG *) 	0x00000094) 
+#define MATRIX_MRCR     (AT91_CAST(AT91_REG *) 	0x00000100) 
+#define MATRIX_EBI      (AT91_CAST(AT91_REG *) 	0x0000011C) 
+#define MATRIX_TEAKCFG  (AT91_CAST(AT91_REG *) 	0x0000012C) 
+#define MATRIX_VERSION  (AT91_CAST(AT91_REG *) 	0x000001FC) 
+
+#endif
+
+#define AT91C_MATRIX_SLOT_CYCLE (0xFF <<  0) 
+#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) 
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) 
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) 
+#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) 
+#define AT91C_MATRIX_FIXED_DEFMSTR0 (0x7 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_HPDC3                (0x2 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_LCDC                 (0x3 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR0_DMA                  (0x4 << 18) 
+
+#define AT91C_MATRIX_FIXED_DEFMSTR1 (0x7 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_HPDC3                (0x2 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_LCDC                 (0x3 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR1_DMA                  (0x4 << 18) 
+
+#define AT91C_MATRIX_FIXED_DEFMSTR2 (0x1 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926D              (0x1 << 18) 
+
+#define AT91C_MATRIX_FIXED_DEFMSTR3 (0x7 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926I              (0x0 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_HPDC3                (0x2 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_LCDC                 (0x3 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR3_DMA                  (0x4 << 18) 
+
+#define AT91C_MATRIX_FIXED_DEFMSTR4 (0x3 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926D              (0x1 << 18) 
+#define 	AT91C_MATRIX_FIXED_DEFMSTR4_HPDC3                (0x2 << 18) 
+
+#define AT91C_MATRIX_RCA926I  (0x1 <<  0) 
+#define AT91C_MATRIX_RCA926D  (0x1 <<  1) 
+
+#define AT91C_MATRIX_CS1A     (0x1 <<  1) 
+#define 	AT91C_MATRIX_CS1A_SMC                  (0x0 <<  1) 
+#define 	AT91C_MATRIX_CS1A_SDRAMC               (0x1 <<  1) 
+#define AT91C_MATRIX_CS3A     (0x1 <<  3) 
+#define 	AT91C_MATRIX_CS3A_SMC                  (0x0 <<  3) 
+#define 	AT91C_MATRIX_CS3A_SM                   (0x1 <<  3) 
+#define AT91C_MATRIX_CS4A     (0x1 <<  4) 
+#define 	AT91C_MATRIX_CS4A_SMC                  (0x0 <<  4) 
+#define 	AT91C_MATRIX_CS4A_CF                   (0x1 <<  4) 
+#define AT91C_MATRIX_CS5A     (0x1 <<  5) 
+#define 	AT91C_MATRIX_CS5A_SMC                  (0x0 <<  5) 
+#define 	AT91C_MATRIX_CS5A_CF                   (0x1 <<  5) 
+#define AT91C_MATRIX_DBPUC    (0x1 <<  8) 
+
+#define AT91C_TEAK_PROGRAM_ACCESS (0x1 <<  0) 
+#define 	AT91C_TEAK_PROGRAM_ACCESS_DISABLED             (0x0) 
+#define 	AT91C_TEAK_PROGRAM_ACCESS_ENABLED              (0x1) 
+#define AT91C_TEAK_BOOT       (0x1 <<  1) 
+#define 	AT91C_TEAK_BOOT_DISABLED             (0x0 <<  1) 
+#define 	AT91C_TEAK_BOOT_ENABLED              (0x1 <<  1) 
+#define AT91C_TEAK_NRESET     (0x1 <<  2) 
+#define 	AT91C_TEAK_NRESET_ENABLED              (0x0 <<  2) 
+#define 	AT91C_TEAK_NRESET_DISABLED             (0x1 <<  2) 
+#define AT91C_TEAK_LVECTORP   (0x3FFFF << 14) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_CCFG {
+	AT91_REG	 Reserved0[3]; 	
+	AT91_REG	 CCFG_EBICSA; 	
+	AT91_REG	 Reserved1[55]; 	
+	AT91_REG	 CCFG_MATRIXVERSION; 	
+} AT91S_CCFG, *AT91PS_CCFG;
+#else
+#define CCFG_EBICSA     (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define CCFG_MATRIXVERSION (AT91_CAST(AT91_REG *) 	0x000000EC) 
+
+#endif
+
+#define AT91C_EBI_CS1A        (0x1 <<  1) 
+#define 	AT91C_EBI_CS1A_SMC                  (0x0 <<  1) 
+#define 	AT91C_EBI_CS1A_SDRAMC               (0x1 <<  1) 
+#define AT91C_EBI_CS3A        (0x1 <<  3) 
+#define 	AT91C_EBI_CS3A_SMC                  (0x0 <<  3) 
+#define 	AT91C_EBI_CS3A_SM                   (0x1 <<  3) 
+#define AT91C_EBI_CS4A        (0x1 <<  4) 
+#define 	AT91C_EBI_CS4A_SMC                  (0x0 <<  4) 
+#define 	AT91C_EBI_CS4A_CF                   (0x1 <<  4) 
+#define AT91C_EBI_CS5A        (0x1 <<  5) 
+#define 	AT91C_EBI_CS5A_SMC                  (0x0 <<  5) 
+#define 	AT91C_EBI_CS5A_CF                   (0x1 <<  5) 
+#define AT91C_EBI_DBPUC       (0x1 <<  8) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_PDC {
+	AT91_REG	 PDC_RPR; 	
+	AT91_REG	 PDC_RCR; 	
+	AT91_REG	 PDC_TPR; 	
+	AT91_REG	 PDC_TCR; 	
+	AT91_REG	 PDC_RNPR; 	
+	AT91_REG	 PDC_RNCR; 	
+	AT91_REG	 PDC_TNPR; 	
+	AT91_REG	 PDC_TNCR; 	
+	AT91_REG	 PDC_PTCR; 	
+	AT91_REG	 PDC_PTSR; 	
+} AT91S_PDC, *AT91PS_PDC;
+#else
+#define PDC_RPR         (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define PDC_RCR         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define PDC_TPR         (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define PDC_TCR         (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define PDC_RNPR        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define PDC_RNCR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define PDC_TNPR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define PDC_TNCR        (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define PDC_PTCR        (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define PDC_PTSR        (AT91_CAST(AT91_REG *) 	0x00000024) 
+
+#endif
+
+#define AT91C_PDC_RXTEN       (0x1 <<  0) 
+#define AT91C_PDC_RXTDIS      (0x1 <<  1) 
+#define AT91C_PDC_TXTEN       (0x1 <<  8) 
+#define AT91C_PDC_TXTDIS      (0x1 <<  9) 
+
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_DBGU {
+	AT91_REG	 DBGU_CR; 	
+	AT91_REG	 DBGU_MR; 	
+	AT91_REG	 DBGU_IER; 	
+	AT91_REG	 DBGU_IDR; 	
+	AT91_REG	 DBGU_IMR; 	
+	AT91_REG	 DBGU_CSR; 	
+	AT91_REG	 DBGU_RHR; 	
+	AT91_REG	 DBGU_THR; 	
+	AT91_REG	 DBGU_BRGR; 	
+	AT91_REG	 Reserved0[7]; 	
+	AT91_REG	 DBGU_CIDR; 	
+	AT91_REG	 DBGU_EXID; 	
+	AT91_REG	 DBGU_FNTR; 	
+	AT91_REG	 Reserved1[45]; 	
+	AT91_REG	 DBGU_RPR; 	
+	AT91_REG	 DBGU_RCR; 	
+	AT91_REG	 DBGU_TPR; 	
+	AT91_REG	 DBGU_TCR; 	
+	AT91_REG	 DBGU_RNPR; 	
+	AT91_REG	 DBGU_RNCR; 	
+	AT91_REG	 DBGU_TNPR; 	
+	AT91_REG	 DBGU_TNCR; 	
+	AT91_REG	 DBGU_PTCR; 	
+	AT91_REG	 DBGU_PTSR; 	
+} AT91S_DBGU, *AT91PS_DBGU;
+#else
+#define DBGU_CR         (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define DBGU_MR         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define DBGU_IER        (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define DBGU_IDR        (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define DBGU_IMR        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define DBGU_CSR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define DBGU_RHR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define DBGU_THR        (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define DBGU_BRGR       (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define DBGU_CIDR       (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define DBGU_EXID       (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define DBGU_FNTR       (AT91_CAST(AT91_REG *) 	0x00000048) 
+
+#endif
+
+#define AT91C_US_RSTRX        (0x1 <<  2) 
+#define AT91C_US_RSTTX        (0x1 <<  3) 
+#define AT91C_US_RXEN         (0x1 <<  4) 
+#define AT91C_US_RXDIS        (0x1 <<  5) 
+#define AT91C_US_TXEN         (0x1 <<  6) 
+#define AT91C_US_TXDIS        (0x1 <<  7) 
+#define AT91C_US_RSTSTA       (0x1 <<  8) 
+
+#define AT91C_US_PAR          (0x7 <<  9) 
+#define 	AT91C_US_PAR_EVEN                 (0x0 <<  9) 
+#define 	AT91C_US_PAR_ODD                  (0x1 <<  9) 
+#define 	AT91C_US_PAR_SPACE                (0x2 <<  9) 
+#define 	AT91C_US_PAR_MARK                 (0x3 <<  9) 
+#define 	AT91C_US_PAR_NONE                 (0x4 <<  9) 
+#define 	AT91C_US_PAR_MULTI_DROP           (0x6 <<  9) 
+#define AT91C_US_CHMODE       (0x3 << 14) 
+#define 	AT91C_US_CHMODE_NORMAL               (0x0 << 14) 
+#define 	AT91C_US_CHMODE_AUTO                 (0x1 << 14) 
+#define 	AT91C_US_CHMODE_LOCAL                (0x2 << 14) 
+#define 	AT91C_US_CHMODE_REMOTE               (0x3 << 14) 
+
+#define AT91C_US_RXRDY        (0x1 <<  0) 
+#define AT91C_US_TXRDY        (0x1 <<  1) 
+#define AT91C_US_ENDRX        (0x1 <<  3) 
+#define AT91C_US_ENDTX        (0x1 <<  4) 
+#define AT91C_US_OVRE         (0x1 <<  5) 
+#define AT91C_US_FRAME        (0x1 <<  6) 
+#define AT91C_US_PARE         (0x1 <<  7) 
+#define AT91C_US_TXEMPTY      (0x1 <<  9) 
+#define AT91C_US_TXBUFE       (0x1 << 11) 
+#define AT91C_US_RXBUFF       (0x1 << 12) 
+#define AT91C_US_COMM_TX      (0x1 << 30) 
+#define AT91C_US_COMM_RX      (0x1 << 31) 
+
+
+
+
+#define AT91C_US_FORCE_NTRST  (0x1 <<  0) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_AIC {
+	AT91_REG	 AIC_SMR[32]; 	
+	AT91_REG	 AIC_SVR[32]; 	
+	AT91_REG	 AIC_IVR; 	
+	AT91_REG	 AIC_FVR; 	
+	AT91_REG	 AIC_ISR; 	
+	AT91_REG	 AIC_IPR; 	
+	AT91_REG	 AIC_IMR; 	
+	AT91_REG	 AIC_CISR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 AIC_IECR; 	
+	AT91_REG	 AIC_IDCR; 	
+	AT91_REG	 AIC_ICCR; 	
+	AT91_REG	 AIC_ISCR; 	
+	AT91_REG	 AIC_EOICR; 	
+	AT91_REG	 AIC_SPU; 	
+	AT91_REG	 AIC_DCR; 	
+	AT91_REG	 Reserved1[1]; 	
+	AT91_REG	 AIC_FFER; 	
+	AT91_REG	 AIC_FFDR; 	
+	AT91_REG	 AIC_FFSR; 	
+} AT91S_AIC, *AT91PS_AIC;
+#else
+#define AIC_SMR         (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define AIC_SVR         (AT91_CAST(AT91_REG *) 	0x00000080) 
+#define AIC_IVR         (AT91_CAST(AT91_REG *) 	0x00000100) 
+#define AIC_FVR         (AT91_CAST(AT91_REG *) 	0x00000104) 
+#define AIC_ISR         (AT91_CAST(AT91_REG *) 	0x00000108) 
+#define AIC_IPR         (AT91_CAST(AT91_REG *) 	0x0000010C) 
+#define AIC_IMR         (AT91_CAST(AT91_REG *) 	0x00000110) 
+#define AIC_CISR        (AT91_CAST(AT91_REG *) 	0x00000114) 
+#define AIC_IECR        (AT91_CAST(AT91_REG *) 	0x00000120) 
+#define AIC_IDCR        (AT91_CAST(AT91_REG *) 	0x00000124) 
+#define AIC_ICCR        (AT91_CAST(AT91_REG *) 	0x00000128) 
+#define AIC_ISCR        (AT91_CAST(AT91_REG *) 	0x0000012C) 
+#define AIC_EOICR       (AT91_CAST(AT91_REG *) 	0x00000130) 
+#define AIC_SPU         (AT91_CAST(AT91_REG *) 	0x00000134) 
+#define AIC_DCR         (AT91_CAST(AT91_REG *) 	0x00000138) 
+#define AIC_FFER        (AT91_CAST(AT91_REG *) 	0x00000140) 
+#define AIC_FFDR        (AT91_CAST(AT91_REG *) 	0x00000144) 
+#define AIC_FFSR        (AT91_CAST(AT91_REG *) 	0x00000148) 
+
+#endif
+
+#define AT91C_AIC_PRIOR       (0x7 <<  0) 
+#define 	AT91C_AIC_PRIOR_LOWEST               (0x0) 
+#define 	AT91C_AIC_PRIOR_HIGHEST              (0x7) 
+#define AT91C_AIC_SRCTYPE     (0x3 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL       (0x0 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_EXT_LOW_LEVEL        (0x0 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE    (0x1 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_EXT_NEGATIVE_EDGE    (0x1 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_HIGH_LEVEL           (0x2 <<  5) 
+#define 	AT91C_AIC_SRCTYPE_POSITIVE_EDGE        (0x3 <<  5) 
+
+#define AT91C_AIC_NFIQ        (0x1 <<  0) 
+#define AT91C_AIC_NIRQ        (0x1 <<  1) 
+
+#define AT91C_AIC_DCR_PROT    (0x1 <<  0) 
+#define AT91C_AIC_DCR_GMSK    (0x1 <<  1) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_PIO {
+	AT91_REG	 PIO_PER; 	
+	AT91_REG	 PIO_PDR; 	
+	AT91_REG	 PIO_PSR; 	
+	AT91_REG	 Reserved0[1]; 	
+	AT91_REG	 PIO_OER; 	
+	AT91_REG	 PIO_ODR; 	
+	AT91_REG	 PIO_OSR; 	
+	AT91_REG	 Reserved1[1]; 	
+	AT91_REG	 PIO_IFER; 	
+	AT91_REG	 PIO_IFDR; 	
+	AT91_REG	 PIO_IFSR; 	
+	AT91_REG	 Reserved2[1]; 	
+	AT91_REG	 PIO_SODR; 	
+	AT91_REG	 PIO_CODR; 	
+	AT91_REG	 PIO_ODSR; 	
+	AT91_REG	 PIO_PDSR; 	
+	AT91_REG	 PIO_IER; 	
+	AT91_REG	 PIO_IDR; 	
+	AT91_REG	 PIO_IMR; 	
+	AT91_REG	 PIO_ISR; 	
+	AT91_REG	 PIO_MDER; 	
+	AT91_REG	 PIO_MDDR; 	
+	AT91_REG	 PIO_MDSR; 	
+	AT91_REG	 Reserved3[1]; 	
+	AT91_REG	 PIO_PPUDR; 	
+	AT91_REG	 PIO_PPUER; 	
+	AT91_REG	 PIO_PPUSR; 	
+	AT91_REG	 Reserved4[1]; 	
+	AT91_REG	 PIO_ASR; 	
+	AT91_REG	 PIO_BSR; 	
+	AT91_REG	 PIO_ABSR; 	
+	AT91_REG	 Reserved5[9]; 	
+	AT91_REG	 PIO_OWER; 	
+	AT91_REG	 PIO_OWDR; 	
+	AT91_REG	 PIO_OWSR; 	
+} AT91S_PIO, *AT91PS_PIO;
+#else
+#define PIO_PER         (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define PIO_PDR         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define PIO_PSR         (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define PIO_OER         (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define PIO_ODR         (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define PIO_OSR         (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define PIO_IFER        (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define PIO_IFDR        (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define PIO_IFSR        (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define PIO_SODR        (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define PIO_CODR        (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define PIO_ODSR        (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define PIO_PDSR        (AT91_CAST(AT91_REG *) 	0x0000003C) 
+#define PIO_IER         (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define PIO_IDR         (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define PIO_IMR         (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define PIO_ISR         (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define PIO_MDER        (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define PIO_MDDR        (AT91_CAST(AT91_REG *) 	0x00000054) 
+#define PIO_MDSR        (AT91_CAST(AT91_REG *) 	0x00000058) 
+#define PIO_PPUDR       (AT91_CAST(AT91_REG *) 	0x00000060) 
+#define PIO_PPUER       (AT91_CAST(AT91_REG *) 	0x00000064) 
+#define PIO_PPUSR       (AT91_CAST(AT91_REG *) 	0x00000068) 
+#define PIO_ASR         (AT91_CAST(AT91_REG *) 	0x00000070) 
+#define PIO_BSR         (AT91_CAST(AT91_REG *) 	0x00000074) 
+#define PIO_ABSR        (AT91_CAST(AT91_REG *) 	0x00000078) 
+#define PIO_OWER        (AT91_CAST(AT91_REG *) 	0x000000A0) 
+#define PIO_OWDR        (AT91_CAST(AT91_REG *) 	0x000000A4) 
+#define PIO_OWSR        (AT91_CAST(AT91_REG *) 	0x000000A8) 
+
+#endif
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_CKGR {
+	AT91_REG	 CKGR_MOR; 	
+	AT91_REG	 CKGR_MCFR; 	
+	AT91_REG	 CKGR_PLLAR; 	
+	AT91_REG	 CKGR_PLLBR; 	
+} AT91S_CKGR, *AT91PS_CKGR;
+#else
+#define CKGR_MOR        (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define CKGR_MCFR       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define CKGR_PLLAR      (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define CKGR_PLLBR      (AT91_CAST(AT91_REG *) 	0x0000000C) 
+
+#endif
+
+#define AT91C_CKGR_MOSCEN     (0x1 <<  0) 
+#define AT91C_CKGR_OSCBYPASS  (0x1 <<  1) 
+#define AT91C_CKGR_OSCOUNT    (0xFF <<  8) 
+
+#define AT91C_CKGR_MAINF      (0xFFFF <<  0) 
+#define AT91C_CKGR_MAINRDY    (0x1 << 16) 
+
+#define AT91C_CKGR_DIVA       (0xFF <<  0) 
+#define 	AT91C_CKGR_DIVA_0                    (0x0) 
+#define 	AT91C_CKGR_DIVA_BYPASS               (0x1) 
+#define AT91C_CKGR_PLLACOUNT  (0x3F <<  8) 
+#define AT91C_CKGR_OUTA       (0x3 << 14) 
+#define 	AT91C_CKGR_OUTA_0                    (0x0 << 14) 
+#define 	AT91C_CKGR_OUTA_1                    (0x1 << 14) 
+#define 	AT91C_CKGR_OUTA_2                    (0x2 << 14) 
+#define 	AT91C_CKGR_OUTA_3                    (0x3 << 14) 
+#define AT91C_CKGR_MULA       (0x7FF << 16) 
+#define AT91C_CKGR_SRCA       (0x1 << 29) 
+
+#define AT91C_CKGR_DIVB       (0xFF <<  0) 
+#define 	AT91C_CKGR_DIVB_0                    (0x0) 
+#define 	AT91C_CKGR_DIVB_BYPASS               (0x1) 
+#define AT91C_CKGR_PLLBCOUNT  (0x3F <<  8) 
+#define AT91C_CKGR_OUTB       (0x3 << 14) 
+#define 	AT91C_CKGR_OUTB_0                    (0x0 << 14) 
+#define 	AT91C_CKGR_OUTB_1                    (0x1 << 14) 
+#define 	AT91C_CKGR_OUTB_2                    (0x2 << 14) 
+#define 	AT91C_CKGR_OUTB_3                    (0x3 << 14) 
+#define AT91C_CKGR_MULB       (0x7FF << 16) 
+#define AT91C_CKGR_USBDIV     (0x3 << 28) 
+#define 	AT91C_CKGR_USBDIV_0                    (0x0 << 28) 
+#define 	AT91C_CKGR_USBDIV_1                    (0x1 << 28) 
+#define 	AT91C_CKGR_USBDIV_2                    (0x2 << 28) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_PMC {
+	AT91_REG	 PMC_SCER; 	
+	AT91_REG	 PMC_SCDR; 	
+	AT91_REG	 PMC_SCSR; 	
+	AT91_REG	 Reserved0[1]; 	
+	AT91_REG	 PMC_PCER; 	
+	AT91_REG	 PMC_PCDR; 	
+	AT91_REG	 PMC_PCSR; 	
+	AT91_REG	 Reserved1[1]; 	
+	AT91_REG	 PMC_MOR; 	
+	AT91_REG	 PMC_MCFR; 	
+	AT91_REG	 PMC_PLLAR; 	
+	AT91_REG	 PMC_PLLBR; 	
+	AT91_REG	 PMC_MCKR; 	
+	AT91_REG	 Reserved2[3]; 	
+	AT91_REG	 PMC_PCKR[8]; 	
+	AT91_REG	 PMC_IER; 	
+	AT91_REG	 PMC_IDR; 	
+	AT91_REG	 PMC_SR; 	
+	AT91_REG	 PMC_IMR; 	
+} AT91S_PMC, *AT91PS_PMC;
+#else
+#define PMC_SCER        (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define PMC_SCDR        (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define PMC_SCSR        (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define PMC_PCER        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define PMC_PCDR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define PMC_PCSR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define PMC_MCKR        (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define PMC_PCKR        (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define PMC_IER         (AT91_CAST(AT91_REG *) 	0x00000060) 
+#define PMC_IDR         (AT91_CAST(AT91_REG *) 	0x00000064) 
+#define PMC_SR          (AT91_CAST(AT91_REG *) 	0x00000068) 
+#define PMC_IMR         (AT91_CAST(AT91_REG *) 	0x0000006C) 
+
+#endif
+
+#define AT91C_PMC_PCK         (0x1 <<  0) 
+#define AT91C_PMC_UHP         (0x1 <<  6) 
+#define AT91C_PMC_UDP         (0x1 <<  7) 
+#define AT91C_PMC_PCK0        (0x1 <<  8) 
+#define AT91C_PMC_PCK1        (0x1 <<  9) 
+#define AT91C_PMC_HCK0        (0x1 << 16) 
+#define AT91C_PMC_HCK1        (0x1 << 17) 
+
+
+#define AT91C_PMC_CSS         (0x3 <<  0) 
+#define 	AT91C_PMC_CSS_SLOW_CLK             (0x0) 
+#define 	AT91C_PMC_CSS_MAIN_CLK             (0x1) 
+#define 	AT91C_PMC_CSS_PLLA_CLK             (0x2) 
+#define 	AT91C_PMC_CSS_PLLB_CLK             (0x3) 
+#define AT91C_PMC_PRES        (0x7 <<  2) 
+#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) 
+#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) 
+#define AT91C_PMC_MDIV        (0x3 <<  8) 
+#define 	AT91C_PMC_MDIV_1                    (0x0 <<  8) 
+#define 	AT91C_PMC_MDIV_2                    (0x1 <<  8) 
+#define 	AT91C_PMC_MDIV_3                    (0x2 <<  8) 
+
+
+#define AT91C_PMC_MOSCS       (0x1 <<  0) 
+#define AT91C_PMC_LOCKA       (0x1 <<  1) 
+#define AT91C_PMC_LOCKB       (0x1 <<  2) 
+#define AT91C_PMC_MCKRDY      (0x1 <<  3) 
+#define AT91C_PMC_PCK0RDY     (0x1 <<  8) 
+#define AT91C_PMC_PCK1RDY     (0x1 <<  9) 
+
+
+#define AT91C_PMC_OSCSEL      (0x1 <<  7) 
+
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_RSTC {
+	AT91_REG	 RSTC_RCR; 	
+	AT91_REG	 RSTC_RSR; 	
+	AT91_REG	 RSTC_RMR; 	
+} AT91S_RSTC, *AT91PS_RSTC;
+#else
+#define RSTC_RCR        (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define RSTC_RSR        (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define RSTC_RMR        (AT91_CAST(AT91_REG *) 	0x00000008) 
+
+#endif
+
+#define AT91C_RSTC_PROCRST    (0x1 <<  0) 
+#define AT91C_RSTC_ICERST     (0x1 <<  1) 
+#define AT91C_RSTC_PERRST     (0x1 <<  2) 
+#define AT91C_RSTC_EXTRST     (0x1 <<  3) 
+#define AT91C_RSTC_KEY        (0xFF << 24) 
+
+#define AT91C_RSTC_URSTS      (0x1 <<  0) 
+#define AT91C_RSTC_RSTTYP     (0x7 <<  8) 
+#define 	AT91C_RSTC_RSTTYP_GENERAL              (0x0 <<  8) 
+#define 	AT91C_RSTC_RSTTYP_WAKEUP               (0x1 <<  8) 
+#define 	AT91C_RSTC_RSTTYP_WATCHDOG             (0x2 <<  8) 
+#define 	AT91C_RSTC_RSTTYP_SOFTWARE             (0x3 <<  8) 
+#define 	AT91C_RSTC_RSTTYP_USER                 (0x4 <<  8) 
+#define AT91C_RSTC_NRSTL      (0x1 << 16) 
+#define AT91C_RSTC_SRCMP      (0x1 << 17) 
+
+#define AT91C_RSTC_URSTEN     (0x1 <<  0) 
+#define AT91C_RSTC_URSTIEN    (0x1 <<  4) 
+#define AT91C_RSTC_ERSTL      (0xF <<  8) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SHDWC {
+	AT91_REG	 SHDWC_SHCR; 	
+	AT91_REG	 SHDWC_SHMR; 	
+	AT91_REG	 SHDWC_SHSR; 	
+} AT91S_SHDWC, *AT91PS_SHDWC;
+#else
+#define SHDWC_SHCR      (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define SHDWC_SHMR      (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define SHDWC_SHSR      (AT91_CAST(AT91_REG *) 	0x00000008) 
+
+#endif
+
+#define AT91C_SHDWC_SHDW      (0x1 <<  0) 
+#define AT91C_SHDWC_KEY       (0xFF << 24) 
+
+#define AT91C_SHDWC_WKMODE0   (0x3 <<  0) 
+#define 	AT91C_SHDWC_WKMODE0_NONE                 (0x0) 
+#define 	AT91C_SHDWC_WKMODE0_HIGH                 (0x1) 
+#define 	AT91C_SHDWC_WKMODE0_LOW                  (0x2) 
+#define 	AT91C_SHDWC_WKMODE0_ANYLEVEL             (0x3) 
+#define AT91C_SHDWC_CPTWK0    (0xF <<  4) 
+#define AT91C_SHDWC_WKMODE1   (0x3 <<  8) 
+#define 	AT91C_SHDWC_WKMODE1_NONE                 (0x0 <<  8) 
+#define 	AT91C_SHDWC_WKMODE1_HIGH                 (0x1 <<  8) 
+#define 	AT91C_SHDWC_WKMODE1_LOW                  (0x2 <<  8) 
+#define 	AT91C_SHDWC_WKMODE1_ANYLEVEL             (0x3 <<  8) 
+#define AT91C_SHDWC_CPTWK1    (0xF << 12) 
+#define AT91C_SHDWC_RTTWKEN   (0x1 << 16) 
+#define AT91C_SHDWC_RTCWKEN   (0x1 << 17) 
+
+#define AT91C_SHDWC_WAKEUP0   (0x1 <<  0) 
+#define AT91C_SHDWC_WAKEUP1   (0x1 <<  1) 
+#define AT91C_SHDWC_FWKUP     (0x1 <<  2) 
+#define AT91C_SHDWC_RTTWK     (0x1 << 16) 
+#define AT91C_SHDWC_RTCWK     (0x1 << 17) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_RTTC {
+	AT91_REG	 RTTC_RTMR; 	
+	AT91_REG	 RTTC_RTAR; 	
+	AT91_REG	 RTTC_RTVR; 	
+	AT91_REG	 RTTC_RTSR; 	
+} AT91S_RTTC, *AT91PS_RTTC;
+#else
+#define RTTC_RTMR       (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define RTTC_RTAR       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define RTTC_RTVR       (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define RTTC_RTSR       (AT91_CAST(AT91_REG *) 	0x0000000C) 
+
+#endif
+
+#define AT91C_RTTC_RTPRES     (0xFFFF <<  0) 
+#define AT91C_RTTC_ALMIEN     (0x1 << 16) 
+#define AT91C_RTTC_RTTINCIEN  (0x1 << 17) 
+#define AT91C_RTTC_RTTRST     (0x1 << 18) 
+
+#define AT91C_RTTC_ALMV       (0x0 <<  0) 
+
+#define AT91C_RTTC_CRTV       (0x0 <<  0) 
+
+#define AT91C_RTTC_ALMS       (0x1 <<  0) 
+#define AT91C_RTTC_RTTINC     (0x1 <<  1) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_PITC {
+	AT91_REG	 PITC_PIMR; 	
+	AT91_REG	 PITC_PISR; 	
+	AT91_REG	 PITC_PIVR; 	
+	AT91_REG	 PITC_PIIR; 	
+} AT91S_PITC, *AT91PS_PITC;
+#else
+#define PITC_PIMR       (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define PITC_PISR       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define PITC_PIVR       (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define PITC_PIIR       (AT91_CAST(AT91_REG *) 	0x0000000C) 
+
+#endif
+
+#define AT91C_PITC_PIV        (0xFFFFF <<  0) 
+#define AT91C_PITC_PITEN      (0x1 << 24) 
+#define AT91C_PITC_PITIEN     (0x1 << 25) 
+
+#define AT91C_PITC_PITS       (0x1 <<  0) 
+
+#define AT91C_PITC_CPIV       (0xFFFFF <<  0) 
+#define AT91C_PITC_PICNT      (0xFFF << 20) 
+
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_WDTC {
+	AT91_REG	 WDTC_WDCR; 	
+	AT91_REG	 WDTC_WDMR; 	
+	AT91_REG	 WDTC_WDSR; 	
+} AT91S_WDTC, *AT91PS_WDTC;
+#else
+#define WDTC_WDCR       (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define WDTC_WDMR       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define WDTC_WDSR       (AT91_CAST(AT91_REG *) 	0x00000008) 
+
+#endif
+
+#define AT91C_WDTC_WDRSTT     (0x1 <<  0) 
+#define AT91C_WDTC_KEY        (0xFF << 24) 
+
+#define AT91C_WDTC_WDV        (0xFFF <<  0) 
+#define AT91C_WDTC_WDFIEN     (0x1 << 12) 
+#define AT91C_WDTC_WDRSTEN    (0x1 << 13) 
+#define AT91C_WDTC_WDRPROC    (0x1 << 14) 
+#define AT91C_WDTC_WDDIS      (0x1 << 15) 
+#define AT91C_WDTC_WDD        (0xFFF << 16) 
+#define AT91C_WDTC_WDDBGHLT   (0x1 << 28) 
+#define AT91C_WDTC_WDIDLEHLT  (0x1 << 29) 
+
+#define AT91C_WDTC_WDUNF      (0x1 <<  0) 
+#define AT91C_WDTC_WDERR      (0x1 <<  1) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_TC {
+	AT91_REG	 TC_CCR; 	
+	AT91_REG	 TC_CMR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 TC_CV; 	
+	AT91_REG	 TC_RA; 	
+	AT91_REG	 TC_RB; 	
+	AT91_REG	 TC_RC; 	
+	AT91_REG	 TC_SR; 	
+	AT91_REG	 TC_IER; 	
+	AT91_REG	 TC_IDR; 	
+	AT91_REG	 TC_IMR; 	
+} AT91S_TC, *AT91PS_TC;
+#else
+#define TC_CCR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define TC_CMR          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define TC_CV           (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define TC_RA           (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define TC_RB           (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define TC_RC           (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define TC_SR           (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define TC_IER          (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define TC_IDR          (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define TC_IMR          (AT91_CAST(AT91_REG *) 	0x0000002C) 
+
+#endif
+
+#define AT91C_TC_CLKEN        (0x1 <<  0) 
+#define AT91C_TC_CLKDIS       (0x1 <<  1) 
+#define AT91C_TC_SWTRG        (0x1 <<  2) 
+
+#define AT91C_TC_CLKS         (0x7 <<  0) 
+#define 	AT91C_TC_CLKS_TIMER_DIV1_CLOCK     (0x0) 
+#define 	AT91C_TC_CLKS_TIMER_DIV2_CLOCK     (0x1) 
+#define 	AT91C_TC_CLKS_TIMER_DIV3_CLOCK     (0x2) 
+#define 	AT91C_TC_CLKS_TIMER_DIV4_CLOCK     (0x3) 
+#define 	AT91C_TC_CLKS_TIMER_DIV5_CLOCK     (0x4) 
+#define 	AT91C_TC_CLKS_XC0                  (0x5) 
+#define 	AT91C_TC_CLKS_XC1                  (0x6) 
+#define 	AT91C_TC_CLKS_XC2                  (0x7) 
+#define AT91C_TC_CLKI         (0x1 <<  3) 
+#define AT91C_TC_BURST        (0x3 <<  4) 
+#define 	AT91C_TC_BURST_NONE                 (0x0 <<  4) 
+#define 	AT91C_TC_BURST_XC0                  (0x1 <<  4) 
+#define 	AT91C_TC_BURST_XC1                  (0x2 <<  4) 
+#define 	AT91C_TC_BURST_XC2                  (0x3 <<  4) 
+#define AT91C_TC_CPCSTOP      (0x1 <<  6) 
+#define AT91C_TC_LDBSTOP      (0x1 <<  6) 
+#define AT91C_TC_CPCDIS       (0x1 <<  7) 
+#define AT91C_TC_LDBDIS       (0x1 <<  7) 
+#define AT91C_TC_ETRGEDG      (0x3 <<  8) 
+#define 	AT91C_TC_ETRGEDG_NONE                 (0x0 <<  8) 
+#define 	AT91C_TC_ETRGEDG_RISING               (0x1 <<  8) 
+#define 	AT91C_TC_ETRGEDG_FALLING              (0x2 <<  8) 
+#define 	AT91C_TC_ETRGEDG_BOTH                 (0x3 <<  8) 
+#define AT91C_TC_EEVTEDG      (0x3 <<  8) 
+#define 	AT91C_TC_EEVTEDG_NONE                 (0x0 <<  8) 
+#define 	AT91C_TC_EEVTEDG_RISING               (0x1 <<  8) 
+#define 	AT91C_TC_EEVTEDG_FALLING              (0x2 <<  8) 
+#define 	AT91C_TC_EEVTEDG_BOTH                 (0x3 <<  8) 
+#define AT91C_TC_EEVT         (0x3 << 10) 
+#define 	AT91C_TC_EEVT_TIOB                 (0x0 << 10) 
+#define 	AT91C_TC_EEVT_XC0                  (0x1 << 10) 
+#define 	AT91C_TC_EEVT_XC1                  (0x2 << 10) 
+#define 	AT91C_TC_EEVT_XC2                  (0x3 << 10) 
+#define AT91C_TC_ABETRG       (0x1 << 10) 
+#define AT91C_TC_ENETRG       (0x1 << 12) 
+#define AT91C_TC_WAVESEL      (0x3 << 13) 
+#define 	AT91C_TC_WAVESEL_UP                   (0x0 << 13) 
+#define 	AT91C_TC_WAVESEL_UPDOWN               (0x1 << 13) 
+#define 	AT91C_TC_WAVESEL_UP_AUTO              (0x2 << 13) 
+#define 	AT91C_TC_WAVESEL_UPDOWN_AUTO          (0x3 << 13) 
+#define AT91C_TC_CPCTRG       (0x1 << 14) 
+#define AT91C_TC_WAVE         (0x1 << 15) 
+#define AT91C_TC_ACPA         (0x3 << 16) 
+#define 	AT91C_TC_ACPA_NONE                 (0x0 << 16) 
+#define 	AT91C_TC_ACPA_SET                  (0x1 << 16) 
+#define 	AT91C_TC_ACPA_CLEAR                (0x2 << 16) 
+#define 	AT91C_TC_ACPA_TOGGLE               (0x3 << 16) 
+#define AT91C_TC_LDRA         (0x3 << 16) 
+#define 	AT91C_TC_LDRA_NONE                 (0x0 << 16) 
+#define 	AT91C_TC_LDRA_RISING               (0x1 << 16) 
+#define 	AT91C_TC_LDRA_FALLING              (0x2 << 16) 
+#define 	AT91C_TC_LDRA_BOTH                 (0x3 << 16) 
+#define AT91C_TC_ACPC         (0x3 << 18) 
+#define 	AT91C_TC_ACPC_NONE                 (0x0 << 18) 
+#define 	AT91C_TC_ACPC_SET                  (0x1 << 18) 
+#define 	AT91C_TC_ACPC_CLEAR                (0x2 << 18) 
+#define 	AT91C_TC_ACPC_TOGGLE               (0x3 << 18) 
+#define AT91C_TC_LDRB         (0x3 << 18) 
+#define 	AT91C_TC_LDRB_NONE                 (0x0 << 18) 
+#define 	AT91C_TC_LDRB_RISING               (0x1 << 18) 
+#define 	AT91C_TC_LDRB_FALLING              (0x2 << 18) 
+#define 	AT91C_TC_LDRB_BOTH                 (0x3 << 18) 
+#define AT91C_TC_AEEVT        (0x3 << 20) 
+#define 	AT91C_TC_AEEVT_NONE                 (0x0 << 20) 
+#define 	AT91C_TC_AEEVT_SET                  (0x1 << 20) 
+#define 	AT91C_TC_AEEVT_CLEAR                (0x2 << 20) 
+#define 	AT91C_TC_AEEVT_TOGGLE               (0x3 << 20) 
+#define AT91C_TC_ASWTRG       (0x3 << 22) 
+#define 	AT91C_TC_ASWTRG_NONE                 (0x0 << 22) 
+#define 	AT91C_TC_ASWTRG_SET                  (0x1 << 22) 
+#define 	AT91C_TC_ASWTRG_CLEAR                (0x2 << 22) 
+#define 	AT91C_TC_ASWTRG_TOGGLE               (0x3 << 22) 
+#define AT91C_TC_BCPB         (0x3 << 24) 
+#define 	AT91C_TC_BCPB_NONE                 (0x0 << 24) 
+#define 	AT91C_TC_BCPB_SET                  (0x1 << 24) 
+#define 	AT91C_TC_BCPB_CLEAR                (0x2 << 24) 
+#define 	AT91C_TC_BCPB_TOGGLE               (0x3 << 24) 
+#define AT91C_TC_BCPC         (0x3 << 26) 
+#define 	AT91C_TC_BCPC_NONE                 (0x0 << 26) 
+#define 	AT91C_TC_BCPC_SET                  (0x1 << 26) 
+#define 	AT91C_TC_BCPC_CLEAR                (0x2 << 26) 
+#define 	AT91C_TC_BCPC_TOGGLE               (0x3 << 26) 
+#define AT91C_TC_BEEVT        (0x3 << 28) 
+#define 	AT91C_TC_BEEVT_NONE                 (0x0 << 28) 
+#define 	AT91C_TC_BEEVT_SET                  (0x1 << 28) 
+#define 	AT91C_TC_BEEVT_CLEAR                (0x2 << 28) 
+#define 	AT91C_TC_BEEVT_TOGGLE               (0x3 << 28) 
+#define AT91C_TC_BSWTRG       (0x3 << 30) 
+#define 	AT91C_TC_BSWTRG_NONE                 (0x0 << 30) 
+#define 	AT91C_TC_BSWTRG_SET                  (0x1 << 30) 
+#define 	AT91C_TC_BSWTRG_CLEAR                (0x2 << 30) 
+#define 	AT91C_TC_BSWTRG_TOGGLE               (0x3 << 30) 
+
+#define AT91C_TC_COVFS        (0x1 <<  0) 
+#define AT91C_TC_LOVRS        (0x1 <<  1) 
+#define AT91C_TC_CPAS         (0x1 <<  2) 
+#define AT91C_TC_CPBS         (0x1 <<  3) 
+#define AT91C_TC_CPCS         (0x1 <<  4) 
+#define AT91C_TC_LDRAS        (0x1 <<  5) 
+#define AT91C_TC_LDRBS        (0x1 <<  6) 
+#define AT91C_TC_ETRGS        (0x1 <<  7) 
+#define AT91C_TC_CLKSTA       (0x1 << 16) 
+#define AT91C_TC_MTIOA        (0x1 << 17) 
+#define AT91C_TC_MTIOB        (0x1 << 18) 
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_TCB {
+	AT91S_TC	 TCB_TC0; 	
+	AT91_REG	 Reserved0[4]; 	
+	AT91S_TC	 TCB_TC1; 	
+	AT91_REG	 Reserved1[4]; 	
+	AT91S_TC	 TCB_TC2; 	
+	AT91_REG	 Reserved2[4]; 	
+	AT91_REG	 TCB_BCR; 	
+	AT91_REG	 TCB_BMR; 	
+} AT91S_TCB, *AT91PS_TCB;
+#else
+#define TCB_BCR         (AT91_CAST(AT91_REG *) 	0x000000C0) 
+#define TCB_BMR         (AT91_CAST(AT91_REG *) 	0x000000C4) 
+
+#endif
+
+#define AT91C_TCB_SYNC        (0x1 <<  0) 
+
+#define AT91C_TCB_TC0XC0S     (0x3 <<  0) 
+#define 	AT91C_TCB_TC0XC0S_TCLK0                (0x0) 
+#define 	AT91C_TCB_TC0XC0S_NONE                 (0x1) 
+#define 	AT91C_TCB_TC0XC0S_TIOA1                (0x2) 
+#define 	AT91C_TCB_TC0XC0S_TIOA2                (0x3) 
+#define AT91C_TCB_TC1XC1S     (0x3 <<  2) 
+#define 	AT91C_TCB_TC1XC1S_TCLK1                (0x0 <<  2) 
+#define 	AT91C_TCB_TC1XC1S_NONE                 (0x1 <<  2) 
+#define 	AT91C_TCB_TC1XC1S_TIOA0                (0x2 <<  2) 
+#define 	AT91C_TCB_TC1XC1S_TIOA2                (0x3 <<  2) 
+#define AT91C_TCB_TC2XC2S     (0x3 <<  4) 
+#define 	AT91C_TCB_TC2XC2S_TCLK2                (0x0 <<  4) 
+#define 	AT91C_TCB_TC2XC2S_NONE                 (0x1 <<  4) 
+#define 	AT91C_TCB_TC2XC2S_TIOA0                (0x2 <<  4) 
+#define 	AT91C_TCB_TC2XC2S_TIOA1                (0x3 <<  4) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_MCI {
+	AT91_REG	 MCI_CR; 	
+	AT91_REG	 MCI_MR; 	
+	AT91_REG	 MCI_DTOR; 	
+	AT91_REG	 MCI_SDCR; 	
+	AT91_REG	 MCI_ARGR; 	
+	AT91_REG	 MCI_CMDR; 	
+	AT91_REG	 MCI_BLKR; 	
+	AT91_REG	 Reserved0[1]; 	
+	AT91_REG	 MCI_RSPR[4]; 	
+	AT91_REG	 MCI_RDR; 	
+	AT91_REG	 MCI_TDR; 	
+	AT91_REG	 Reserved1[2]; 	
+	AT91_REG	 MCI_SR; 	
+	AT91_REG	 MCI_IER; 	
+	AT91_REG	 MCI_IDR; 	
+	AT91_REG	 MCI_IMR; 	
+	AT91_REG	 Reserved2[43]; 	
+	AT91_REG	 MCI_VR; 	
+	AT91_REG	 MCI_RPR; 	
+	AT91_REG	 MCI_RCR; 	
+	AT91_REG	 MCI_TPR; 	
+	AT91_REG	 MCI_TCR; 	
+	AT91_REG	 MCI_RNPR; 	
+	AT91_REG	 MCI_RNCR; 	
+	AT91_REG	 MCI_TNPR; 	
+	AT91_REG	 MCI_TNCR; 	
+	AT91_REG	 MCI_PTCR; 	
+	AT91_REG	 MCI_PTSR; 	
+} AT91S_MCI, *AT91PS_MCI;
+#else
+#define MCI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define MCI_MR          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define MCI_DTOR        (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define MCI_SDCR        (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define MCI_ARGR        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define MCI_CMDR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define MCI_BLKR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define MCI_RSPR        (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define MCI_RDR         (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define MCI_TDR         (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define MCI_SR          (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define MCI_IER         (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define MCI_IDR         (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define MCI_IMR         (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define MCI_VR          (AT91_CAST(AT91_REG *) 	0x000000FC) 
+
+#endif
+
+#define AT91C_MCI_MCIEN       (0x1 <<  0) 
+#define AT91C_MCI_MCIDIS      (0x1 <<  1) 
+#define AT91C_MCI_PWSEN       (0x1 <<  2) 
+#define AT91C_MCI_PWSDIS      (0x1 <<  3) 
+#define AT91C_MCI_SWRST       (0x1 <<  7) 
+
+#define AT91C_MCI_CLKDIV      (0xFF <<  0) 
+#define AT91C_MCI_PWSDIV      (0x7 <<  8) 
+#define AT91C_MCI_RDPROOF     (0x1 << 11) 
+#define AT91C_MCI_WRPROOF     (0x1 << 12) 
+#define AT91C_MCI_PDCFBYTE    (0x1 << 13) 
+#define AT91C_MCI_PDCPADV     (0x1 << 14) 
+#define AT91C_MCI_PDCMODE     (0x1 << 15) 
+#define AT91C_MCI_BLKLEN      (0xFFFF << 16) 
+
+#define AT91C_MCI_DTOCYC      (0xF <<  0) 
+#define AT91C_MCI_DTOMUL      (0x7 <<  4) 
+#define 	AT91C_MCI_DTOMUL_1                    (0x0 <<  4) 
+#define 	AT91C_MCI_DTOMUL_16                   (0x1 <<  4) 
+#define 	AT91C_MCI_DTOMUL_128                  (0x2 <<  4) 
+#define 	AT91C_MCI_DTOMUL_256                  (0x3 <<  4) 
+#define 	AT91C_MCI_DTOMUL_1024                 (0x4 <<  4) 
+#define 	AT91C_MCI_DTOMUL_4096                 (0x5 <<  4) 
+#define 	AT91C_MCI_DTOMUL_65536                (0x6 <<  4) 
+#define 	AT91C_MCI_DTOMUL_1048576              (0x7 <<  4) 
+
+#define AT91C_MCI_SCDSEL      (0x3 <<  0) 
+#define AT91C_MCI_SCDBUS      (0x1 <<  7) 
+
+#define AT91C_MCI_CMDNB       (0x3F <<  0) 
+#define AT91C_MCI_RSPTYP      (0x3 <<  6) 
+#define 	AT91C_MCI_RSPTYP_NO                   (0x0 <<  6) 
+#define 	AT91C_MCI_RSPTYP_48                   (0x1 <<  6) 
+#define 	AT91C_MCI_RSPTYP_136                  (0x2 <<  6) 
+#define AT91C_MCI_SPCMD       (0x7 <<  8) 
+#define 	AT91C_MCI_SPCMD_NONE                 (0x0 <<  8) 
+#define 	AT91C_MCI_SPCMD_INIT                 (0x1 <<  8) 
+#define 	AT91C_MCI_SPCMD_SYNC                 (0x2 <<  8) 
+#define 	AT91C_MCI_SPCMD_IT_CMD               (0x4 <<  8) 
+#define 	AT91C_MCI_SPCMD_IT_REP               (0x5 <<  8) 
+#define AT91C_MCI_OPDCMD      (0x1 << 11) 
+#define AT91C_MCI_MAXLAT      (0x1 << 12) 
+#define AT91C_MCI_TRCMD       (0x3 << 16) 
+#define 	AT91C_MCI_TRCMD_NO                   (0x0 << 16) 
+#define 	AT91C_MCI_TRCMD_START                (0x1 << 16) 
+#define 	AT91C_MCI_TRCMD_STOP                 (0x2 << 16) 
+#define AT91C_MCI_TRDIR       (0x1 << 18) 
+#define AT91C_MCI_TRTYP       (0x7 << 19) 
+#define 	AT91C_MCI_TRTYP_BLOCK                (0x0 << 19) 
+#define 	AT91C_MCI_TRTYP_MULTIPLE             (0x1 << 19) 
+#define 	AT91C_MCI_TRTYP_STREAM               (0x2 << 19) 
+#define 	AT91C_MCI_TRTYP_SDIO_BYTE            (0x4 << 19) 
+#define 	AT91C_MCI_TRTYP_SDIO_BLOCK           (0x5 << 19) 
+#define AT91C_MCI_IOSPCMD     (0x3 << 24) 
+#define 	AT91C_MCI_IOSPCMD_NONE                 (0x0 << 24) 
+#define 	AT91C_MCI_IOSPCMD_SUSPEND              (0x1 << 24) 
+#define 	AT91C_MCI_IOSPCMD_RESUME               (0x2 << 24) 
+
+#define AT91C_MCI_BCNT        (0xFFFF <<  0) 
+
+#define AT91C_MCI_CMDRDY      (0x1 <<  0) 
+#define AT91C_MCI_RXRDY       (0x1 <<  1) 
+#define AT91C_MCI_TXRDY       (0x1 <<  2) 
+#define AT91C_MCI_BLKE        (0x1 <<  3) 
+#define AT91C_MCI_DTIP        (0x1 <<  4) 
+#define AT91C_MCI_NOTBUSY     (0x1 <<  5) 
+#define AT91C_MCI_ENDRX       (0x1 <<  6) 
+#define AT91C_MCI_ENDTX       (0x1 <<  7) 
+#define AT91C_MCI_SDIOIRQA    (0x1 <<  8) 
+#define AT91C_MCI_SDIOIRQB    (0x1 <<  9) 
+#define AT91C_MCI_SDIOIRQC    (0x1 << 10) 
+#define AT91C_MCI_SDIOIRQD    (0x1 << 11) 
+#define AT91C_MCI_RXBUFF      (0x1 << 14) 
+#define AT91C_MCI_TXBUFE      (0x1 << 15) 
+#define AT91C_MCI_RINDE       (0x1 << 16) 
+#define AT91C_MCI_RDIRE       (0x1 << 17) 
+#define AT91C_MCI_RCRCE       (0x1 << 18) 
+#define AT91C_MCI_RENDE       (0x1 << 19) 
+#define AT91C_MCI_RTOE        (0x1 << 20) 
+#define AT91C_MCI_DCRCE       (0x1 << 21) 
+#define AT91C_MCI_DTOE        (0x1 << 22) 
+#define AT91C_MCI_OVRE        (0x1 << 30) 
+#define AT91C_MCI_UNRE        (0x1 << 31) 
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_TWI {
+	AT91_REG	 TWI_CR; 	
+	AT91_REG	 TWI_MMR; 	
+	AT91_REG	 TWI_SMR; 	
+	AT91_REG	 TWI_IADR; 	
+	AT91_REG	 TWI_CWGR; 	
+	AT91_REG	 Reserved0[3]; 	
+	AT91_REG	 TWI_SR; 	
+	AT91_REG	 TWI_IER; 	
+	AT91_REG	 TWI_IDR; 	
+	AT91_REG	 TWI_IMR; 	
+	AT91_REG	 TWI_RHR; 	
+	AT91_REG	 TWI_THR; 	
+	AT91_REG	 Reserved1[50]; 	
+	AT91_REG	 TWI_RPR; 	
+	AT91_REG	 TWI_RCR; 	
+	AT91_REG	 TWI_TPR; 	
+	AT91_REG	 TWI_TCR; 	
+	AT91_REG	 TWI_RNPR; 	
+	AT91_REG	 TWI_RNCR; 	
+	AT91_REG	 TWI_TNPR; 	
+	AT91_REG	 TWI_TNCR; 	
+	AT91_REG	 TWI_PTCR; 	
+	AT91_REG	 TWI_PTSR; 	
+} AT91S_TWI, *AT91PS_TWI;
+#else
+#define TWI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define TWI_MMR         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define TWI_SMR         (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define TWI_IADR        (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define TWI_CWGR        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define TWI_SR          (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define TWI_IER         (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define TWI_IDR         (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define TWI_IMR         (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define TWI_RHR         (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define TWI_THR         (AT91_CAST(AT91_REG *) 	0x00000034) 
+
+#endif
+
+#define AT91C_TWI_START       (0x1 <<  0) 
+#define AT91C_TWI_STOP        (0x1 <<  1) 
+#define AT91C_TWI_MSEN        (0x1 <<  2) 
+#define AT91C_TWI_MSDIS       (0x1 <<  3) 
+#define AT91C_TWI_SVEN        (0x1 <<  4) 
+#define AT91C_TWI_SVDIS       (0x1 <<  5) 
+#define AT91C_TWI_SWRST       (0x1 <<  7) 
+
+#define AT91C_TWI_IADRSZ      (0x3 <<  8) 
+#define 	AT91C_TWI_IADRSZ_NO                   (0x0 <<  8) 
+#define 	AT91C_TWI_IADRSZ_1_BYTE               (0x1 <<  8) 
+#define 	AT91C_TWI_IADRSZ_2_BYTE               (0x2 <<  8) 
+#define 	AT91C_TWI_IADRSZ_3_BYTE               (0x3 <<  8) 
+#define AT91C_TWI_MREAD       (0x1 << 12) 
+#define AT91C_TWI_DADR        (0x7F << 16) 
+
+#define AT91C_TWI_SADR        (0x7F << 16) 
+
+#define AT91C_TWI_CLDIV       (0xFF <<  0) 
+#define AT91C_TWI_CHDIV       (0xFF <<  8) 
+#define AT91C_TWI_CKDIV       (0x7 << 16) 
+
+#define AT91C_TWI_TXCOMP_SLAVE (0x1 <<  0) 
+#define AT91C_TWI_TXCOMP_MASTER (0x1 <<  0) 
+#define AT91C_TWI_RXRDY       (0x1 <<  1) 
+#define AT91C_TWI_TXRDY_MASTER (0x1 <<  2) 
+#define AT91C_TWI_TXRDY_SLAVE (0x1 <<  2) 
+#define AT91C_TWI_SVREAD      (0x1 <<  3) 
+#define AT91C_TWI_SVACC       (0x1 <<  4) 
+#define AT91C_TWI_GACC        (0x1 <<  5) 
+#define AT91C_TWI_OVRE        (0x1 <<  6) 
+#define AT91C_TWI_NACK_SLAVE  (0x1 <<  8) 
+#define AT91C_TWI_NACK_MASTER (0x1 <<  8) 
+#define AT91C_TWI_ARBLST_MULTI_MASTER (0x1 <<  9) 
+#define AT91C_TWI_SCLWS       (0x1 << 10) 
+#define AT91C_TWI_EOSACC      (0x1 << 11) 
+#define AT91C_TWI_ENDRX       (0x1 << 12) 
+#define AT91C_TWI_ENDTX       (0x1 << 13) 
+#define AT91C_TWI_RXBUFF      (0x1 << 14) 
+#define AT91C_TWI_TXBUFE      (0x1 << 15) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_USART {
+	AT91_REG	 US_CR; 	
+	AT91_REG	 US_MR; 	
+	AT91_REG	 US_IER; 	
+	AT91_REG	 US_IDR; 	
+	AT91_REG	 US_IMR; 	
+	AT91_REG	 US_CSR; 	
+	AT91_REG	 US_RHR; 	
+	AT91_REG	 US_THR; 	
+	AT91_REG	 US_BRGR; 	
+	AT91_REG	 US_RTOR; 	
+	AT91_REG	 US_TTGR; 	
+	AT91_REG	 Reserved0[5]; 	
+	AT91_REG	 US_FIDI; 	
+	AT91_REG	 US_NER; 	
+	AT91_REG	 Reserved1[1]; 	
+	AT91_REG	 US_IF; 	
+	AT91_REG	 Reserved2[44]; 	
+	AT91_REG	 US_RPR; 	
+	AT91_REG	 US_RCR; 	
+	AT91_REG	 US_TPR; 	
+	AT91_REG	 US_TCR; 	
+	AT91_REG	 US_RNPR; 	
+	AT91_REG	 US_RNCR; 	
+	AT91_REG	 US_TNPR; 	
+	AT91_REG	 US_TNCR; 	
+	AT91_REG	 US_PTCR; 	
+	AT91_REG	 US_PTSR; 	
+} AT91S_USART, *AT91PS_USART;
+#else
+#define US_CR           (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define US_MR           (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define US_IER          (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define US_IDR          (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define US_IMR          (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define US_CSR          (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define US_RHR          (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define US_THR          (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define US_BRGR         (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define US_RTOR         (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define US_TTGR         (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define US_FIDI         (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define US_NER          (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define US_IF           (AT91_CAST(AT91_REG *) 	0x0000004C) 
+
+#endif
+
+#define AT91C_US_STTBRK       (0x1 <<  9) 
+#define AT91C_US_STPBRK       (0x1 << 10) 
+#define AT91C_US_STTTO        (0x1 << 11) 
+#define AT91C_US_SENDA        (0x1 << 12) 
+#define AT91C_US_RSTIT        (0x1 << 13) 
+#define AT91C_US_RSTNACK      (0x1 << 14) 
+#define AT91C_US_RETTO        (0x1 << 15) 
+#define AT91C_US_DTREN        (0x1 << 16) 
+#define AT91C_US_DTRDIS       (0x1 << 17) 
+#define AT91C_US_RTSEN        (0x1 << 18) 
+#define AT91C_US_RTSDIS       (0x1 << 19) 
+
+#define AT91C_US_USMODE       (0xF <<  0) 
+#define 	AT91C_US_USMODE_NORMAL               (0x0) 
+#define 	AT91C_US_USMODE_RS485                (0x1) 
+#define 	AT91C_US_USMODE_HWHSH                (0x2) 
+#define 	AT91C_US_USMODE_MODEM                (0x3) 
+#define 	AT91C_US_USMODE_ISO7816_0            (0x4) 
+#define 	AT91C_US_USMODE_ISO7816_1            (0x6) 
+#define 	AT91C_US_USMODE_IRDA                 (0x8) 
+#define 	AT91C_US_USMODE_SWHSH                (0xC) 
+#define AT91C_US_CLKS         (0x3 <<  4) 
+#define 	AT91C_US_CLKS_CLOCK                (0x0 <<  4) 
+#define 	AT91C_US_CLKS_FDIV1                (0x1 <<  4) 
+#define 	AT91C_US_CLKS_SLOW                 (0x2 <<  4) 
+#define 	AT91C_US_CLKS_EXT                  (0x3 <<  4) 
+#define AT91C_US_CHRL         (0x3 <<  6) 
+#define 	AT91C_US_CHRL_5_BITS               (0x0 <<  6) 
+#define 	AT91C_US_CHRL_6_BITS               (0x1 <<  6) 
+#define 	AT91C_US_CHRL_7_BITS               (0x2 <<  6) 
+#define 	AT91C_US_CHRL_8_BITS               (0x3 <<  6) 
+#define AT91C_US_SYNC         (0x1 <<  8) 
+#define AT91C_US_NBSTOP       (0x3 << 12) 
+#define 	AT91C_US_NBSTOP_1_BIT                (0x0 << 12) 
+#define 	AT91C_US_NBSTOP_15_BIT               (0x1 << 12) 
+#define 	AT91C_US_NBSTOP_2_BIT                (0x2 << 12) 
+#define AT91C_US_MSBF         (0x1 << 16) 
+#define AT91C_US_MODE9        (0x1 << 17) 
+#define AT91C_US_CKLO         (0x1 << 18) 
+#define AT91C_US_OVER         (0x1 << 19) 
+#define AT91C_US_INACK        (0x1 << 20) 
+#define AT91C_US_DSNACK       (0x1 << 21) 
+#define AT91C_US_MAX_ITER     (0x1 << 24) 
+#define AT91C_US_FILTER       (0x1 << 28) 
+
+#define AT91C_US_RXBRK        (0x1 <<  2) 
+#define AT91C_US_TIMEOUT      (0x1 <<  8) 
+#define AT91C_US_ITERATION    (0x1 << 10) 
+#define AT91C_US_NACK         (0x1 << 13) 
+#define AT91C_US_RIIC         (0x1 << 16) 
+#define AT91C_US_DSRIC        (0x1 << 17) 
+#define AT91C_US_DCDIC        (0x1 << 18) 
+#define AT91C_US_CTSIC        (0x1 << 19) 
+
+#define AT91C_US_RI           (0x1 << 20) 
+#define AT91C_US_DSR          (0x1 << 21) 
+#define AT91C_US_DCD          (0x1 << 22) 
+#define AT91C_US_CTS          (0x1 << 23) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SSC {
+	AT91_REG	 SSC_CR; 	
+	AT91_REG	 SSC_CMR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 SSC_RCMR; 	
+	AT91_REG	 SSC_RFMR; 	
+	AT91_REG	 SSC_TCMR; 	
+	AT91_REG	 SSC_TFMR; 	
+	AT91_REG	 SSC_RHR; 	
+	AT91_REG	 SSC_THR; 	
+	AT91_REG	 Reserved1[2]; 	
+	AT91_REG	 SSC_RSHR; 	
+	AT91_REG	 SSC_TSHR; 	
+	AT91_REG	 Reserved2[2]; 	
+	AT91_REG	 SSC_SR; 	
+	AT91_REG	 SSC_IER; 	
+	AT91_REG	 SSC_IDR; 	
+	AT91_REG	 SSC_IMR; 	
+	AT91_REG	 Reserved3[44]; 	
+	AT91_REG	 SSC_RPR; 	
+	AT91_REG	 SSC_RCR; 	
+	AT91_REG	 SSC_TPR; 	
+	AT91_REG	 SSC_TCR; 	
+	AT91_REG	 SSC_RNPR; 	
+	AT91_REG	 SSC_RNCR; 	
+	AT91_REG	 SSC_TNPR; 	
+	AT91_REG	 SSC_TNCR; 	
+	AT91_REG	 SSC_PTCR; 	
+	AT91_REG	 SSC_PTSR; 	
+} AT91S_SSC, *AT91PS_SSC;
+#else
+#define SSC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define SSC_CMR         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define SSC_RCMR        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define SSC_RFMR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define SSC_TCMR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define SSC_TFMR        (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define SSC_RHR         (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define SSC_THR         (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define SSC_RSHR        (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define SSC_TSHR        (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define SSC_SR          (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define SSC_IER         (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define SSC_IDR         (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define SSC_IMR         (AT91_CAST(AT91_REG *) 	0x0000004C) 
+
+#endif
+
+#define AT91C_SSC_RXEN        (0x1 <<  0) 
+#define AT91C_SSC_RXDIS       (0x1 <<  1) 
+#define AT91C_SSC_TXEN        (0x1 <<  8) 
+#define AT91C_SSC_TXDIS       (0x1 <<  9) 
+#define AT91C_SSC_SWRST       (0x1 << 15) 
+
+#define AT91C_SSC_CKS         (0x3 <<  0) 
+#define 	AT91C_SSC_CKS_DIV                  (0x0) 
+#define 	AT91C_SSC_CKS_TK                   (0x1) 
+#define 	AT91C_SSC_CKS_RK                   (0x2) 
+#define AT91C_SSC_CKO         (0x7 <<  2) 
+#define 	AT91C_SSC_CKO_NONE                 (0x0 <<  2) 
+#define 	AT91C_SSC_CKO_CONTINOUS            (0x1 <<  2) 
+#define 	AT91C_SSC_CKO_DATA_TX              (0x2 <<  2) 
+#define AT91C_SSC_CKI         (0x1 <<  5) 
+#define AT91C_SSC_CKG         (0x3 <<  6) 
+#define 	AT91C_SSC_CKG_NONE                 (0x0 <<  6) 
+#define 	AT91C_SSC_CKG_LOW                  (0x1 <<  6) 
+#define 	AT91C_SSC_CKG_HIGH                 (0x2 <<  6) 
+#define AT91C_SSC_START       (0xF <<  8) 
+#define 	AT91C_SSC_START_CONTINOUS            (0x0 <<  8) 
+#define 	AT91C_SSC_START_TX                   (0x1 <<  8) 
+#define 	AT91C_SSC_START_LOW_RF               (0x2 <<  8) 
+#define 	AT91C_SSC_START_HIGH_RF              (0x3 <<  8) 
+#define 	AT91C_SSC_START_FALL_RF              (0x4 <<  8) 
+#define 	AT91C_SSC_START_RISE_RF              (0x5 <<  8) 
+#define 	AT91C_SSC_START_LEVEL_RF             (0x6 <<  8) 
+#define 	AT91C_SSC_START_EDGE_RF              (0x7 <<  8) 
+#define 	AT91C_SSC_START_0                    (0x8 <<  8) 
+#define AT91C_SSC_STOP        (0x1 << 12) 
+#define AT91C_SSC_STTDLY      (0xFF << 16) 
+#define AT91C_SSC_PERIOD      (0xFF << 24) 
+
+#define AT91C_SSC_DATLEN      (0x1F <<  0) 
+#define AT91C_SSC_LOOP        (0x1 <<  5) 
+#define AT91C_SSC_MSBF        (0x1 <<  7) 
+#define AT91C_SSC_DATNB       (0xF <<  8) 
+#define AT91C_SSC_FSLEN       (0xF << 16) 
+#define AT91C_SSC_FSOS        (0x7 << 20) 
+#define 	AT91C_SSC_FSOS_NONE                 (0x0 << 20) 
+#define 	AT91C_SSC_FSOS_NEGATIVE             (0x1 << 20) 
+#define 	AT91C_SSC_FSOS_POSITIVE             (0x2 << 20) 
+#define 	AT91C_SSC_FSOS_LOW                  (0x3 << 20) 
+#define 	AT91C_SSC_FSOS_HIGH                 (0x4 << 20) 
+#define 	AT91C_SSC_FSOS_TOGGLE               (0x5 << 20) 
+#define AT91C_SSC_FSEDGE      (0x1 << 24) 
+
+
+#define AT91C_SSC_DATDEF      (0x1 <<  5) 
+#define AT91C_SSC_FSDEN       (0x1 << 23) 
+
+#define AT91C_SSC_TXRDY       (0x1 <<  0) 
+#define AT91C_SSC_TXEMPTY     (0x1 <<  1) 
+#define AT91C_SSC_ENDTX       (0x1 <<  2) 
+#define AT91C_SSC_TXBUFE      (0x1 <<  3) 
+#define AT91C_SSC_RXRDY       (0x1 <<  4) 
+#define AT91C_SSC_OVRUN       (0x1 <<  5) 
+#define AT91C_SSC_ENDRX       (0x1 <<  6) 
+#define AT91C_SSC_RXBUFF      (0x1 <<  7) 
+#define AT91C_SSC_CP0         (0x1 <<  8) 
+#define AT91C_SSC_CP1         (0x1 <<  9) 
+#define AT91C_SSC_TXSYN       (0x1 << 10) 
+#define AT91C_SSC_RXSYN       (0x1 << 11) 
+#define AT91C_SSC_TXENA       (0x1 << 16) 
+#define AT91C_SSC_RXENA       (0x1 << 17) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_SPI {
+	AT91_REG	 SPI_CR; 	
+	AT91_REG	 SPI_MR; 	
+	AT91_REG	 SPI_RDR; 	
+	AT91_REG	 SPI_TDR; 	
+	AT91_REG	 SPI_SR; 	
+	AT91_REG	 SPI_IER; 	
+	AT91_REG	 SPI_IDR; 	
+	AT91_REG	 SPI_IMR; 	
+	AT91_REG	 Reserved0[4]; 	
+	AT91_REG	 SPI_CSR[4]; 	
+	AT91_REG	 Reserved1[48]; 	
+	AT91_REG	 SPI_RPR; 	
+	AT91_REG	 SPI_RCR; 	
+	AT91_REG	 SPI_TPR; 	
+	AT91_REG	 SPI_TCR; 	
+	AT91_REG	 SPI_RNPR; 	
+	AT91_REG	 SPI_RNCR; 	
+	AT91_REG	 SPI_TNPR; 	
+	AT91_REG	 SPI_TNCR; 	
+	AT91_REG	 SPI_PTCR; 	
+	AT91_REG	 SPI_PTSR; 	
+} AT91S_SPI, *AT91PS_SPI;
+#else
+#define SPI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define SPI_MR          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define SPI_RDR         (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define SPI_TDR         (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define SPI_SR          (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define SPI_IER         (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define SPI_IDR         (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define SPI_IMR         (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define SPI_CSR         (AT91_CAST(AT91_REG *) 	0x00000030) 
+
+#endif
+
+#define AT91C_SPI_SPIEN       (0x1 <<  0) 
+#define AT91C_SPI_SPIDIS      (0x1 <<  1) 
+#define AT91C_SPI_SWRST       (0x1 <<  7) 
+#define AT91C_SPI_LASTXFER    (0x1 << 24) 
+
+#define AT91C_SPI_MSTR        (0x1 <<  0) 
+#define AT91C_SPI_PS          (0x1 <<  1) 
+#define 	AT91C_SPI_PS_FIXED                (0x0 <<  1) 
+#define 	AT91C_SPI_PS_VARIABLE             (0x1 <<  1) 
+#define AT91C_SPI_PCSDEC      (0x1 <<  2) 
+#define AT91C_SPI_FDIV        (0x1 <<  3) 
+#define AT91C_SPI_MODFDIS     (0x1 <<  4) 
+#define AT91C_SPI_LLB         (0x1 <<  7) 
+#define AT91C_SPI_PCS         (0xF << 16) 
+#define AT91C_SPI_DLYBCS      (0xFF << 24) 
+
+#define AT91C_SPI_RD          (0xFFFF <<  0) 
+#define AT91C_SPI_RPCS        (0xF << 16) 
+
+#define AT91C_SPI_TD          (0xFFFF <<  0) 
+#define AT91C_SPI_TPCS        (0xF << 16) 
+
+#define AT91C_SPI_RDRF        (0x1 <<  0) 
+#define AT91C_SPI_TDRE        (0x1 <<  1) 
+#define AT91C_SPI_MODF        (0x1 <<  2) 
+#define AT91C_SPI_OVRES       (0x1 <<  3) 
+#define AT91C_SPI_ENDRX       (0x1 <<  4) 
+#define AT91C_SPI_ENDTX       (0x1 <<  5) 
+#define AT91C_SPI_RXBUFF      (0x1 <<  6) 
+#define AT91C_SPI_TXBUFE      (0x1 <<  7) 
+#define AT91C_SPI_NSSR        (0x1 <<  8) 
+#define AT91C_SPI_TXEMPTY     (0x1 <<  9) 
+#define AT91C_SPI_SPIENS      (0x1 << 16) 
+
+
+#define AT91C_SPI_CPOL        (0x1 <<  0) 
+#define AT91C_SPI_NCPHA       (0x1 <<  1) 
+#define AT91C_SPI_CSAAT       (0x1 <<  3) 
+#define AT91C_SPI_BITS        (0xF <<  4) 
+#define 	AT91C_SPI_BITS_8                    (0x0 <<  4) 
+#define 	AT91C_SPI_BITS_9                    (0x1 <<  4) 
+#define 	AT91C_SPI_BITS_10                   (0x2 <<  4) 
+#define 	AT91C_SPI_BITS_11                   (0x3 <<  4) 
+#define 	AT91C_SPI_BITS_12                   (0x4 <<  4) 
+#define 	AT91C_SPI_BITS_13                   (0x5 <<  4) 
+#define 	AT91C_SPI_BITS_14                   (0x6 <<  4) 
+#define 	AT91C_SPI_BITS_15                   (0x7 <<  4) 
+#define 	AT91C_SPI_BITS_16                   (0x8 <<  4) 
+#define AT91C_SPI_SCBR        (0xFF <<  8) 
+#define AT91C_SPI_DLYBS       (0xFF << 16) 
+#define AT91C_SPI_DLYBCT      (0xFF << 24) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_ADC {
+	AT91_REG	 ADC_CR; 	
+	AT91_REG	 ADC_MR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 ADC_CHER; 	
+	AT91_REG	 ADC_CHDR; 	
+	AT91_REG	 ADC_CHSR; 	
+	AT91_REG	 ADC_SR; 	
+	AT91_REG	 ADC_LCDR; 	
+	AT91_REG	 ADC_IER; 	
+	AT91_REG	 ADC_IDR; 	
+	AT91_REG	 ADC_IMR; 	
+	AT91_REG	 ADC_CDR0; 	
+	AT91_REG	 ADC_CDR1; 	
+	AT91_REG	 ADC_CDR2; 	
+	AT91_REG	 ADC_CDR3; 	
+	AT91_REG	 Reserved1[48]; 	
+	AT91_REG	 ADC_RPR; 	
+	AT91_REG	 ADC_RCR; 	
+	AT91_REG	 ADC_TPR; 	
+	AT91_REG	 ADC_TCR; 	
+	AT91_REG	 ADC_RNPR; 	
+	AT91_REG	 ADC_RNCR; 	
+	AT91_REG	 ADC_TNPR; 	
+	AT91_REG	 ADC_TNCR; 	
+	AT91_REG	 ADC_PTCR; 	
+	AT91_REG	 ADC_PTSR; 	
+} AT91S_ADC, *AT91PS_ADC;
+#else
+#define ADC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define ADC_MR          (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define ADC_CHER        (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define ADC_CHDR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define ADC_CHSR        (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define ADC_SR          (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define ADC_LCDR        (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define ADC_IER         (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define ADC_IDR         (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define ADC_IMR         (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define ADC_CDR0        (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define ADC_CDR1        (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define ADC_CDR2        (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define ADC_CDR3        (AT91_CAST(AT91_REG *) 	0x0000003C) 
+
+#endif
+
+#define AT91C_ADC_SWRST       (0x1 <<  0) 
+#define AT91C_ADC_START       (0x1 <<  1) 
+
+#define AT91C_ADC_TRGEN       (0x1 <<  0) 
+#define 	AT91C_ADC_TRGEN_DIS                  (0x0) 
+#define 	AT91C_ADC_TRGEN_EN                   (0x1) 
+#define AT91C_ADC_TRGSEL      (0x7 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA0                (0x0 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA1                (0x1 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA2                (0x2 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA3                (0x3 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA4                (0x4 <<  1) 
+#define 	AT91C_ADC_TRGSEL_TIOA5                (0x5 <<  1) 
+#define 	AT91C_ADC_TRGSEL_EXT                  (0x6 <<  1) 
+#define AT91C_ADC_LOWRES      (0x1 <<  4) 
+#define 	AT91C_ADC_LOWRES_10_BIT               (0x0 <<  4) 
+#define 	AT91C_ADC_LOWRES_8_BIT                (0x1 <<  4) 
+#define AT91C_ADC_SLEEP       (0x1 <<  5) 
+#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) 
+#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) 
+#define AT91C_ADC_PRESCAL     (0x3F <<  8) 
+#define AT91C_ADC_STARTUP     (0x1F << 16) 
+#define AT91C_ADC_SHTIM       (0xF << 24) 
+
+#define AT91C_ADC_CH0         (0x1 <<  0) 
+#define AT91C_ADC_CH1         (0x1 <<  1) 
+#define AT91C_ADC_CH2         (0x1 <<  2) 
+#define AT91C_ADC_CH3         (0x1 <<  3) 
+
+
+
+#define AT91C_ADC_EOC0        (0x1 <<  0) 
+#define AT91C_ADC_EOC1        (0x1 <<  1) 
+#define AT91C_ADC_EOC2        (0x1 <<  2) 
+#define AT91C_ADC_EOC3        (0x1 <<  3) 
+#define AT91C_ADC_OVRE0       (0x1 <<  8) 
+#define AT91C_ADC_OVRE1       (0x1 <<  9) 
+#define AT91C_ADC_OVRE2       (0x1 << 10) 
+#define AT91C_ADC_OVRE3       (0x1 << 11) 
+#define AT91C_ADC_DRDY        (0x1 << 16) 
+#define AT91C_ADC_GOVRE       (0x1 << 17) 
+#define AT91C_ADC_ENDRX       (0x1 << 18) 
+#define AT91C_ADC_RXBUFF      (0x1 << 19) 
+
+#define AT91C_ADC_LDATA       (0x3FF <<  0) 
+
+#define AT91C_ADC_DATA        (0x3FF <<  0) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_EMAC {
+	AT91_REG	 EMAC_NCR; 	
+	AT91_REG	 EMAC_NCFGR; 	
+	AT91_REG	 EMAC_NSR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 EMAC_TSR; 	
+	AT91_REG	 EMAC_RBQP; 	
+	AT91_REG	 EMAC_TBQP; 	
+	AT91_REG	 EMAC_RSR; 	
+	AT91_REG	 EMAC_ISR; 	
+	AT91_REG	 EMAC_IER; 	
+	AT91_REG	 EMAC_IDR; 	
+	AT91_REG	 EMAC_IMR; 	
+	AT91_REG	 EMAC_MAN; 	
+	AT91_REG	 EMAC_PTR; 	
+	AT91_REG	 EMAC_PFR; 	
+	AT91_REG	 EMAC_FTO; 	
+	AT91_REG	 EMAC_SCF; 	
+	AT91_REG	 EMAC_MCF; 	
+	AT91_REG	 EMAC_FRO; 	
+	AT91_REG	 EMAC_FCSE; 	
+	AT91_REG	 EMAC_ALE; 	
+	AT91_REG	 EMAC_DTF; 	
+	AT91_REG	 EMAC_LCOL; 	
+	AT91_REG	 EMAC_ECOL; 	
+	AT91_REG	 EMAC_TUND; 	
+	AT91_REG	 EMAC_CSE; 	
+	AT91_REG	 EMAC_RRE; 	
+	AT91_REG	 EMAC_ROV; 	
+	AT91_REG	 EMAC_RSE; 	
+	AT91_REG	 EMAC_ELE; 	
+	AT91_REG	 EMAC_RJA; 	
+	AT91_REG	 EMAC_USF; 	
+	AT91_REG	 EMAC_STE; 	
+	AT91_REG	 EMAC_RLE; 	
+	AT91_REG	 EMAC_TPF; 	
+	AT91_REG	 EMAC_HRB; 	
+	AT91_REG	 EMAC_HRT; 	
+	AT91_REG	 EMAC_SA1L; 	
+	AT91_REG	 EMAC_SA1H; 	
+	AT91_REG	 EMAC_SA2L; 	
+	AT91_REG	 EMAC_SA2H; 	
+	AT91_REG	 EMAC_SA3L; 	
+	AT91_REG	 EMAC_SA3H; 	
+	AT91_REG	 EMAC_SA4L; 	
+	AT91_REG	 EMAC_SA4H; 	
+	AT91_REG	 EMAC_TID; 	
+	AT91_REG	 EMAC_TPQ; 	
+	AT91_REG	 EMAC_USRIO; 	
+	AT91_REG	 EMAC_WOL; 	
+	AT91_REG	 Reserved1[13]; 	
+	AT91_REG	 EMAC_REV; 	
+} AT91S_EMAC, *AT91PS_EMAC;
+#else
+#define EMAC_NCR        (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define EMAC_NCFGR      (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define EMAC_NSR        (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define EMAC_TSR        (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define EMAC_RBQP       (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define EMAC_TBQP       (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define EMAC_RSR        (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define EMAC_ISR        (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define EMAC_IER        (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define EMAC_IDR        (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define EMAC_IMR        (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define EMAC_MAN        (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define EMAC_PTR        (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define EMAC_PFR        (AT91_CAST(AT91_REG *) 	0x0000003C) 
+#define EMAC_FTO        (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define EMAC_SCF        (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define EMAC_MCF        (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define EMAC_FRO        (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define EMAC_FCSE       (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define EMAC_ALE        (AT91_CAST(AT91_REG *) 	0x00000054) 
+#define EMAC_DTF        (AT91_CAST(AT91_REG *) 	0x00000058) 
+#define EMAC_LCOL       (AT91_CAST(AT91_REG *) 	0x0000005C) 
+#define EMAC_ECOL       (AT91_CAST(AT91_REG *) 	0x00000060) 
+#define EMAC_TUND       (AT91_CAST(AT91_REG *) 	0x00000064) 
+#define EMAC_CSE        (AT91_CAST(AT91_REG *) 	0x00000068) 
+#define EMAC_RRE        (AT91_CAST(AT91_REG *) 	0x0000006C) 
+#define EMAC_ROV        (AT91_CAST(AT91_REG *) 	0x00000070) 
+#define EMAC_RSE        (AT91_CAST(AT91_REG *) 	0x00000074) 
+#define EMAC_ELE        (AT91_CAST(AT91_REG *) 	0x00000078) 
+#define EMAC_RJA        (AT91_CAST(AT91_REG *) 	0x0000007C) 
+#define EMAC_USF        (AT91_CAST(AT91_REG *) 	0x00000080) 
+#define EMAC_STE        (AT91_CAST(AT91_REG *) 	0x00000084) 
+#define EMAC_RLE        (AT91_CAST(AT91_REG *) 	0x00000088) 
+#define EMAC_TPF        (AT91_CAST(AT91_REG *) 	0x0000008C) 
+#define EMAC_HRB        (AT91_CAST(AT91_REG *) 	0x00000090) 
+#define EMAC_HRT        (AT91_CAST(AT91_REG *) 	0x00000094) 
+#define EMAC_SA1L       (AT91_CAST(AT91_REG *) 	0x00000098) 
+#define EMAC_SA1H       (AT91_CAST(AT91_REG *) 	0x0000009C) 
+#define EMAC_SA2L       (AT91_CAST(AT91_REG *) 	0x000000A0) 
+#define EMAC_SA2H       (AT91_CAST(AT91_REG *) 	0x000000A4) 
+#define EMAC_SA3L       (AT91_CAST(AT91_REG *) 	0x000000A8) 
+#define EMAC_SA3H       (AT91_CAST(AT91_REG *) 	0x000000AC) 
+#define EMAC_SA4L       (AT91_CAST(AT91_REG *) 	0x000000B0) 
+#define EMAC_SA4H       (AT91_CAST(AT91_REG *) 	0x000000B4) 
+#define EMAC_TID        (AT91_CAST(AT91_REG *) 	0x000000B8) 
+#define EMAC_TPQ        (AT91_CAST(AT91_REG *) 	0x000000BC) 
+#define EMAC_USRIO      (AT91_CAST(AT91_REG *) 	0x000000C0) 
+#define EMAC_WOL        (AT91_CAST(AT91_REG *) 	0x000000C4) 
+#define EMAC_REV        (AT91_CAST(AT91_REG *) 	0x000000FC) 
+
+#endif
+
+#define AT91C_EMAC_LB         (0x1 <<  0) 
+#define AT91C_EMAC_LLB        (0x1 <<  1) 
+#define AT91C_EMAC_RE         (0x1 <<  2) 
+#define AT91C_EMAC_TE         (0x1 <<  3) 
+#define AT91C_EMAC_MPE        (0x1 <<  4) 
+#define AT91C_EMAC_CLRSTAT    (0x1 <<  5) 
+#define AT91C_EMAC_INCSTAT    (0x1 <<  6) 
+#define AT91C_EMAC_WESTAT     (0x1 <<  7) 
+#define AT91C_EMAC_BP         (0x1 <<  8) 
+#define AT91C_EMAC_TSTART     (0x1 <<  9) 
+#define AT91C_EMAC_THALT      (0x1 << 10) 
+#define AT91C_EMAC_TPFR       (0x1 << 11) 
+#define AT91C_EMAC_TZQ        (0x1 << 12) 
+
+#define AT91C_EMAC_SPD        (0x1 <<  0) 
+#define AT91C_EMAC_FD         (0x1 <<  1) 
+#define AT91C_EMAC_JFRAME     (0x1 <<  3) 
+#define AT91C_EMAC_CAF        (0x1 <<  4) 
+#define AT91C_EMAC_NBC        (0x1 <<  5) 
+#define AT91C_EMAC_MTI        (0x1 <<  6) 
+#define AT91C_EMAC_UNI        (0x1 <<  7) 
+#define AT91C_EMAC_BIG        (0x1 <<  8) 
+#define AT91C_EMAC_EAE        (0x1 <<  9) 
+#define AT91C_EMAC_CLK        (0x3 << 10) 
+#define 	AT91C_EMAC_CLK_HCLK_8               (0x0 << 10) 
+#define 	AT91C_EMAC_CLK_HCLK_16              (0x1 << 10) 
+#define 	AT91C_EMAC_CLK_HCLK_32              (0x2 << 10) 
+#define 	AT91C_EMAC_CLK_HCLK_64              (0x3 << 10) 
+#define AT91C_EMAC_RTY        (0x1 << 12) 
+#define AT91C_EMAC_PAE        (0x1 << 13) 
+#define AT91C_EMAC_RBOF       (0x3 << 14) 
+#define 	AT91C_EMAC_RBOF_OFFSET_0             (0x0 << 14) 
+#define 	AT91C_EMAC_RBOF_OFFSET_1             (0x1 << 14) 
+#define 	AT91C_EMAC_RBOF_OFFSET_2             (0x2 << 14) 
+#define 	AT91C_EMAC_RBOF_OFFSET_3             (0x3 << 14) 
+#define AT91C_EMAC_RLCE       (0x1 << 16) 
+#define AT91C_EMAC_DRFCS      (0x1 << 17) 
+#define AT91C_EMAC_EFRHD      (0x1 << 18) 
+#define AT91C_EMAC_IRXFCS     (0x1 << 19) 
+
+#define AT91C_EMAC_LINKR      (0x1 <<  0) 
+#define AT91C_EMAC_MDIO       (0x1 <<  1) 
+#define AT91C_EMAC_IDLE       (0x1 <<  2) 
+
+#define AT91C_EMAC_UBR        (0x1 <<  0) 
+#define AT91C_EMAC_COL        (0x1 <<  1) 
+#define AT91C_EMAC_RLES       (0x1 <<  2) 
+#define AT91C_EMAC_TGO        (0x1 <<  3) 
+#define AT91C_EMAC_BEX        (0x1 <<  4) 
+#define AT91C_EMAC_COMP       (0x1 <<  5) 
+#define AT91C_EMAC_UND        (0x1 <<  6) 
+
+#define AT91C_EMAC_BNA        (0x1 <<  0) 
+#define AT91C_EMAC_REC        (0x1 <<  1) 
+#define AT91C_EMAC_OVR        (0x1 <<  2) 
+
+#define AT91C_EMAC_MFD        (0x1 <<  0) 
+#define AT91C_EMAC_RCOMP      (0x1 <<  1) 
+#define AT91C_EMAC_RXUBR      (0x1 <<  2) 
+#define AT91C_EMAC_TXUBR      (0x1 <<  3) 
+#define AT91C_EMAC_TUNDR      (0x1 <<  4) 
+#define AT91C_EMAC_RLEX       (0x1 <<  5) 
+#define AT91C_EMAC_TXERR      (0x1 <<  6) 
+#define AT91C_EMAC_TCOMP      (0x1 <<  7) 
+#define AT91C_EMAC_LINK       (0x1 <<  9) 
+#define AT91C_EMAC_ROVR       (0x1 << 10) 
+#define AT91C_EMAC_HRESP      (0x1 << 11) 
+#define AT91C_EMAC_PFRE       (0x1 << 12) 
+#define AT91C_EMAC_PTZ        (0x1 << 13) 
+
+#define AT91C_EMAC_DATA       (0xFFFF <<  0) 
+#define AT91C_EMAC_CODE       (0x3 << 16) 
+#define AT91C_EMAC_REGA       (0x1F << 18) 
+#define AT91C_EMAC_PHYA       (0x1F << 23) 
+#define AT91C_EMAC_RW         (0x3 << 28) 
+#define AT91C_EMAC_SOF        (0x3 << 30) 
+
+#define AT91C_EMAC_RMII       (0x1 <<  0) 
+#define AT91C_EMAC_CLKEN      (0x1 <<  1) 
+
+#define AT91C_EMAC_IP         (0xFFFF <<  0) 
+#define AT91C_EMAC_MAG        (0x1 << 16) 
+#define AT91C_EMAC_ARP        (0x1 << 17) 
+#define AT91C_EMAC_SA1        (0x1 << 18) 
+
+#define AT91C_EMAC_REVREF     (0xFFFF <<  0) 
+#define AT91C_EMAC_PARTREF    (0xFFFF << 16) 
+
+
+
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_UDP {
+	AT91_REG	 UDP_NUM; 	
+	AT91_REG	 UDP_GLBSTATE; 	
+	AT91_REG	 UDP_FADDR; 	
+	AT91_REG	 Reserved0[1]; 	
+	AT91_REG	 UDP_IER; 	
+	AT91_REG	 UDP_IDR; 	
+	AT91_REG	 UDP_IMR; 	
+	AT91_REG	 UDP_ISR; 	
+	AT91_REG	 UDP_ICR; 	
+	AT91_REG	 Reserved1[1]; 	
+	AT91_REG	 UDP_RSTEP; 	
+	AT91_REG	 Reserved2[1]; 	
+	AT91_REG	 UDP_CSR[6]; 	
+	AT91_REG	 Reserved3[2]; 	
+	AT91_REG	 UDP_FDR[6]; 	
+	AT91_REG	 Reserved4[3]; 	
+	AT91_REG	 UDP_TXVC; 	
+} AT91S_UDP, *AT91PS_UDP;
+#else
+#define UDP_FRM_NUM     (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define UDP_GLBSTATE    (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define UDP_FADDR       (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define UDP_IER         (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define UDP_IDR         (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define UDP_IMR         (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define UDP_ISR         (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define UDP_ICR         (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define UDP_RSTEP       (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define UDP_CSR         (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define UDP_FDR         (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define UDP_TXVC        (AT91_CAST(AT91_REG *) 	0x00000074) 
+
+#endif
+
+#define AT91C_UDP_FRM_NUM     (0x7FF <<  0) 
+#define AT91C_UDP_FRM_ERR     (0x1 << 16) 
+#define AT91C_UDP_FRM_OK      (0x1 << 17) 
+
+#define AT91C_UDP_FADDEN      (0x1 <<  0) 
+#define AT91C_UDP_CONFG       (0x1 <<  1) 
+#define AT91C_UDP_ESR         (0x1 <<  2) 
+#define AT91C_UDP_RSMINPR     (0x1 <<  3) 
+#define AT91C_UDP_RMWUPE      (0x1 <<  4) 
+
+#define AT91C_UDP_FADD        (0xFF <<  0) 
+#define AT91C_UDP_FEN         (0x1 <<  8) 
+
+#define AT91C_UDP_EPINT0      (0x1 <<  0) 
+#define AT91C_UDP_EPINT1      (0x1 <<  1) 
+#define AT91C_UDP_EPINT2      (0x1 <<  2) 
+#define AT91C_UDP_EPINT3      (0x1 <<  3) 
+#define AT91C_UDP_EPINT4      (0x1 <<  4) 
+#define AT91C_UDP_EPINT5      (0x1 <<  5) 
+#define AT91C_UDP_RXSUSP      (0x1 <<  8) 
+#define AT91C_UDP_RXRSM       (0x1 <<  9) 
+#define AT91C_UDP_EXTRSM      (0x1 << 10) 
+#define AT91C_UDP_SOFINT      (0x1 << 11) 
+#define AT91C_UDP_WAKEUP      (0x1 << 13) 
+
+
+
+#define AT91C_UDP_ENDBUSRES   (0x1 << 12) 
+
+
+#define AT91C_UDP_EP0         (0x1 <<  0) 
+#define AT91C_UDP_EP1         (0x1 <<  1) 
+#define AT91C_UDP_EP2         (0x1 <<  2) 
+#define AT91C_UDP_EP3         (0x1 <<  3) 
+#define AT91C_UDP_EP4         (0x1 <<  4) 
+#define AT91C_UDP_EP5         (0x1 <<  5) 
+
+#define AT91C_UDP_TXCOMP      (0x1 <<  0) 
+#define AT91C_UDP_RX_DATA_BK0 (0x1 <<  1) 
+#define AT91C_UDP_RXSETUP     (0x1 <<  2) 
+#define AT91C_UDP_ISOERROR    (0x1 <<  3) 
+#define AT91C_UDP_STALLSENT   (0x1 <<  3) 
+#define AT91C_UDP_TXPKTRDY    (0x1 <<  4) 
+#define AT91C_UDP_FORCESTALL  (0x1 <<  5) 
+#define AT91C_UDP_RX_DATA_BK1 (0x1 <<  6) 
+#define AT91C_UDP_DIR         (0x1 <<  7) 
+#define AT91C_UDP_EPTYPE      (0x7 <<  8) 
+#define 	AT91C_UDP_EPTYPE_CTRL                 (0x0 <<  8) 
+#define 	AT91C_UDP_EPTYPE_ISO_OUT              (0x1 <<  8) 
+#define 	AT91C_UDP_EPTYPE_BULK_OUT             (0x2 <<  8) 
+#define 	AT91C_UDP_EPTYPE_INT_OUT              (0x3 <<  8) 
+#define 	AT91C_UDP_EPTYPE_ISO_IN               (0x5 <<  8) 
+#define 	AT91C_UDP_EPTYPE_BULK_IN              (0x6 <<  8) 
+#define 	AT91C_UDP_EPTYPE_INT_IN               (0x7 <<  8) 
+#define AT91C_UDP_DTGLE       (0x1 << 11) 
+#define AT91C_UDP_EPEDS       (0x1 << 15) 
+#define AT91C_UDP_RXBYTECNT   (0x7FF << 16) 
+
+#define AT91C_UDP_TXVDIS      (0x1 <<  8) 
+#define AT91C_UDP_PUON        (0x1 <<  9) 
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_UHP {
+	AT91_REG	 UHP_HcRevision; 	
+	AT91_REG	 UHP_HcControl; 	
+	AT91_REG	 UHP_HcCommandStatus; 	
+	AT91_REG	 UHP_HcInterruptStatus; 	
+	AT91_REG	 UHP_HcInterruptEnable; 	
+	AT91_REG	 UHP_HcInterruptDisable; 	
+	AT91_REG	 UHP_HcHCCA; 	
+	AT91_REG	 UHP_HcPeriodCurrentED; 	
+	AT91_REG	 UHP_HcControlHeadED; 	
+	AT91_REG	 UHP_HcControlCurrentED; 	
+	AT91_REG	 UHP_HcBulkHeadED; 	
+	AT91_REG	 UHP_HcBulkCurrentED; 	
+	AT91_REG	 UHP_HcBulkDoneHead; 	
+	AT91_REG	 UHP_HcFmInterval; 	
+	AT91_REG	 UHP_HcFmRemaining; 	
+	AT91_REG	 UHP_HcFmNumber; 	
+	AT91_REG	 UHP_HcPeriodicStart; 	
+	AT91_REG	 UHP_HcLSThreshold; 	
+	AT91_REG	 UHP_HcRhDescriptorA; 	
+	AT91_REG	 UHP_HcRhDescriptorB; 	
+	AT91_REG	 UHP_HcRhStatus; 	
+	AT91_REG	 UHP_HcRhPortStatus[2]; 	
+} AT91S_UHP, *AT91PS_UHP;
+#else
+#define HcRevision      (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define HcControl       (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define HcCommandStatus (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define HcInterruptStatus (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define HcInterruptEnable (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define HcInterruptDisable (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define HcHCCA          (AT91_CAST(AT91_REG *) 	0x00000018) 
+#define HcPeriodCurrentED (AT91_CAST(AT91_REG *) 	0x0000001C) 
+#define HcControlHeadED (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define HcControlCurrentED (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define HcBulkHeadED    (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define HcBulkCurrentED (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define HcBulkDoneHead  (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define HcFmInterval    (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define HcFmRemaining   (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define HcFmNumber      (AT91_CAST(AT91_REG *) 	0x0000003C) 
+#define HcPeriodicStart (AT91_CAST(AT91_REG *) 	0x00000040) 
+#define HcLSThreshold   (AT91_CAST(AT91_REG *) 	0x00000044) 
+#define HcRhDescriptorA (AT91_CAST(AT91_REG *) 	0x00000048) 
+#define HcRhDescriptorB (AT91_CAST(AT91_REG *) 	0x0000004C) 
+#define HcRhStatus      (AT91_CAST(AT91_REG *) 	0x00000050) 
+#define HcRhPortStatus  (AT91_CAST(AT91_REG *) 	0x00000054) 
+
+#endif
+
+#ifndef __ASSEMBLY__
+typedef struct _AT91S_ISI {
+	AT91_REG	 ISI_CR1; 	
+	AT91_REG	 ISI_CR2; 	
+	AT91_REG	 ISI_SR; 	
+	AT91_REG	 ISI_IER; 	
+	AT91_REG	 ISI_IDR; 	
+	AT91_REG	 ISI_IMR; 	
+	AT91_REG	 Reserved0[2]; 	
+	AT91_REG	 ISI_PSIZE; 	
+	AT91_REG	 ISI_PDECF; 	
+	AT91_REG	 ISI_PFBD; 	
+	AT91_REG	 ISI_CDBA; 	
+	AT91_REG	 ISI_Y2RSET0; 	
+	AT91_REG	 ISI_Y2RSET1; 	
+	AT91_REG	 ISI_R2YSET0; 	
+	AT91_REG	 ISI_R2YSET1; 	
+	AT91_REG	 ISI_R2YSET2; 	
+} AT91S_ISI, *AT91PS_ISI;
+#else
+#define ISI_CR1         (AT91_CAST(AT91_REG *) 	0x00000000) 
+#define ISI_CR2         (AT91_CAST(AT91_REG *) 	0x00000004) 
+#define ISI_SR          (AT91_CAST(AT91_REG *) 	0x00000008) 
+#define ISI_IER         (AT91_CAST(AT91_REG *) 	0x0000000C) 
+#define ISI_IDR         (AT91_CAST(AT91_REG *) 	0x00000010) 
+#define ISI_IMR         (AT91_CAST(AT91_REG *) 	0x00000014) 
+#define ISI_PSIZE       (AT91_CAST(AT91_REG *) 	0x00000020) 
+#define ISI_PDECF       (AT91_CAST(AT91_REG *) 	0x00000024) 
+#define ISI_PFBD        (AT91_CAST(AT91_REG *) 	0x00000028) 
+#define ISI_CDBA        (AT91_CAST(AT91_REG *) 	0x0000002C) 
+#define ISI_Y2RSET0     (AT91_CAST(AT91_REG *) 	0x00000030) 
+#define ISI_Y2RSET1     (AT91_CAST(AT91_REG *) 	0x00000034) 
+#define ISI_R2YSET0     (AT91_CAST(AT91_REG *) 	0x00000038) 
+#define ISI_R2YSET1     (AT91_CAST(AT91_REG *) 	0x0000003C) 
+#define ISI_R2YSET2     (AT91_CAST(AT91_REG *) 	0x00000040) 
+
+#endif
+
+#define AT91C_ISI_RST         (0x1 <<  0) 
+#define AT91C_ISI_DISABLE     (0x1 <<  1) 
+#define AT91C_ISI_HSYNC_POL   (0x1 <<  2) 
+#define AT91C_ISI_PIXCLK_POL  (0x1 <<  4) 
+#define AT91C_ISI_EMB_SYNC    (0x1 <<  6) 
+#define AT91C_ISI_CRC_SYNC    (0x1 <<  7) 
+#define AT91C_ISI_FULL        (0x1 << 12) 
+#define AT91C_ISI_THMASK      (0x3 << 13) 
+#define 	AT91C_ISI_THMASK_4_8_16_BURST         (0x0 << 13) 
+#define 	AT91C_ISI_THMASK_8_16_BURST           (0x1 << 13) 
+#define 	AT91C_ISI_THMASK_16_BURST             (0x2 << 13) 
+#define AT91C_ISI_CODEC_ON    (0x1 << 15) 
+#define AT91C_ISI_SLD         (0xFF << 16) 
+#define AT91C_ISI_SFD         (0xFF << 24) 
+
+#define AT91C_ISI_IM_VSIZE    (0x7FF <<  0) 
+#define AT91C_ISI_GS_MODE     (0x1 << 11) 
+#define AT91C_ISI_RGB_MODE    (0x3 << 12) 
+#define 	AT91C_ISI_RGB_MODE_RGB_888              (0x0 << 12) 
+#define 	AT91C_ISI_RGB_MODE_RGB_565              (0x1 << 12) 
+#define 	AT91C_ISI_RGB_MODE_RGB_555              (0x2 << 12) 
+#define AT91C_ISI_GRAYSCALE   (0x1 << 13) 
+#define AT91C_ISI_RGB_SWAP    (0x1 << 14) 
+#define AT91C_ISI_COL_SPACE   (0x1 << 15) 
+#define AT91C_ISI_IM_HSIZE    (0x7FF << 16) 
+#define 	AT91C_ISI_RGB_MODE_YCC_DEF              (0x0 << 28) 
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD1             (0x1 << 28) 
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD2             (0x2 << 28) 
+#define 	AT91C_ISI_RGB_MODE_YCC_MOD3             (0x3 << 28) 
+#define AT91C_ISI_RGB_CFG     (0x3 << 30) 
+#define 	AT91C_ISI_RGB_CFG_RGB_DEF              (0x0 << 30) 
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD1             (0x1 << 30) 
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD2             (0x2 << 30) 
+#define 	AT91C_ISI_RGB_CFG_RGB_MOD3             (0x3 << 30) 
+
+#define AT91C_ISI_SOF         (0x1 <<  0) 
+#define AT91C_ISI_DIS         (0x1 <<  1) 
+#define AT91C_ISI_SOFTRST     (0x1 <<  2) 
+#define AT91C_ISI_CRC_ERR     (0x1 <<  4) 
+#define AT91C_ISI_FO_C_OVF    (0x1 <<  5) 
+#define AT91C_ISI_FO_P_OVF    (0x1 <<  6) 
+#define AT91C_ISI_FO_P_EMP    (0x1 <<  7) 
+#define AT91C_ISI_FO_C_EMP    (0x1 <<  8) 
+#define AT91C_ISI_FR_OVR      (0x1 <<  9) 
+
+#define AT91C_ISI_PREV_VSIZE  (0x3FF <<  0) 
+#define AT91C_ISI_PREV_HSIZE  (0x3FF << 16) 
+
+#define AT91C_ISI_Y2R_C0      (0xFF <<  0) 
+#define AT91C_ISI_Y2R_C1      (0xFF <<  8) 
+#define AT91C_ISI_Y2R_C2      (0xFF << 16) 
+#define AT91C_ISI_Y2R_C3      (0xFF << 24) 
+
+#define AT91C_ISI_Y2R_C4      (0x1FF <<  0) 
+#define AT91C_ISI_Y2R_YOFF    (0xFF << 12) 
+#define AT91C_ISI_Y2R_CROFF   (0xFF << 13) 
+#define AT91C_ISI_Y2R_CBFF    (0xFF << 14) 
+
+#define AT91C_ISI_R2Y_C0      (0x7F <<  0) 
+#define AT91C_ISI_R2Y_C1      (0x7F <<  1) 
+#define AT91C_ISI_R2Y_C2      (0x7F <<  3) 
+#define AT91C_ISI_R2Y_ROFF    (0x1 <<  4) 
+
+#define AT91C_ISI_R2Y_C3      (0x7F <<  0) 
+#define AT91C_ISI_R2Y_C4      (0x7F <<  1) 
+#define AT91C_ISI_R2Y_C5      (0x7F <<  3) 
+#define AT91C_ISI_R2Y_GOFF    (0x1 <<  4) 
+
+#define AT91C_ISI_R2Y_C6      (0x7F <<  0) 
+#define AT91C_ISI_R2Y_C7      (0x7F <<  1) 
+#define AT91C_ISI_R2Y_C8      (0x7F <<  3) 
+#define AT91C_ISI_R2Y_BOFF    (0x1 <<  4) 
+
+
+
+
+
+#define AT91C_SYS_GPBR1 (AT91_CAST(AT91_REG *) 	0xFFFFFFFF) 
+#define AT91C_SYS_GPBR2 (AT91_CAST(AT91_REG *) 	0xFFFFFFFF) 
+#define AT91C_SYS_GPBR0 (AT91_CAST(AT91_REG *) 	0xFFFFFFFF) 
+#define AT91C_SYS_GPBR3 (AT91_CAST(AT91_REG *) 	0xFFFFFFFF) 
+
+#define AT91C_EBI_DUMMY (AT91_CAST(AT91_REG *) 	0xFFFFEA00) 
+
+#define AT91C_HECC_VR   (AT91_CAST(AT91_REG *) 	0xFFFFE8FC) 
+#define AT91C_HECC_NPR  (AT91_CAST(AT91_REG *) 	0xFFFFE810) 
+#define AT91C_HECC_SR   (AT91_CAST(AT91_REG *) 	0xFFFFE808) 
+#define AT91C_HECC_PR   (AT91_CAST(AT91_REG *) 	0xFFFFE80C) 
+#define AT91C_HECC_MR   (AT91_CAST(AT91_REG *) 	0xFFFFE804) 
+#define AT91C_HECC_CR   (AT91_CAST(AT91_REG *) 	0xFFFFE800) 
+
+#define AT91C_SDRAMC_MR (AT91_CAST(AT91_REG *) 	0xFFFFEA00) 
+#define AT91C_SDRAMC_IMR (AT91_CAST(AT91_REG *) 	0xFFFFEA1C) 
+#define AT91C_SDRAMC_LPR (AT91_CAST(AT91_REG *) 	0xFFFFEA10) 
+#define AT91C_SDRAMC_ISR (AT91_CAST(AT91_REG *) 	0xFFFFEA20) 
+#define AT91C_SDRAMC_IDR (AT91_CAST(AT91_REG *) 	0xFFFFEA18) 
+#define AT91C_SDRAMC_CR (AT91_CAST(AT91_REG *) 	0xFFFFEA08) 
+#define AT91C_SDRAMC_TR (AT91_CAST(AT91_REG *) 	0xFFFFEA04) 
+#define AT91C_SDRAMC_MDR (AT91_CAST(AT91_REG *) 	0xFFFFEA24) 
+#define AT91C_SDRAMC_HSR (AT91_CAST(AT91_REG *) 	0xFFFFEA0C) 
+#define AT91C_SDRAMC_IER (AT91_CAST(AT91_REG *) 	0xFFFFEA14) 
+
+#define AT91C_SMC_CTRL1 (AT91_CAST(AT91_REG *) 	0xFFFFEC1C) 
+#define AT91C_SMC_PULSE7 (AT91_CAST(AT91_REG *) 	0xFFFFEC74) 
+#define AT91C_SMC_PULSE6 (AT91_CAST(AT91_REG *) 	0xFFFFEC64) 
+#define AT91C_SMC_SETUP4 (AT91_CAST(AT91_REG *) 	0xFFFFEC40) 
+#define AT91C_SMC_PULSE3 (AT91_CAST(AT91_REG *) 	0xFFFFEC34) 
+#define AT91C_SMC_CYCLE5 (AT91_CAST(AT91_REG *) 	0xFFFFEC58) 
+#define AT91C_SMC_CYCLE2 (AT91_CAST(AT91_REG *) 	0xFFFFEC28) 
+#define AT91C_SMC_CTRL2 (AT91_CAST(AT91_REG *) 	0xFFFFEC2C) 
+#define AT91C_SMC_CTRL0 (AT91_CAST(AT91_REG *) 	0xFFFFEC0C) 
+#define AT91C_SMC_PULSE5 (AT91_CAST(AT91_REG *) 	0xFFFFEC54) 
+#define AT91C_SMC_PULSE1 (AT91_CAST(AT91_REG *) 	0xFFFFEC14) 
+#define AT91C_SMC_PULSE0 (AT91_CAST(AT91_REG *) 	0xFFFFEC04) 
+#define AT91C_SMC_CYCLE7 (AT91_CAST(AT91_REG *) 	0xFFFFEC78) 
+#define AT91C_SMC_CTRL4 (AT91_CAST(AT91_REG *) 	0xFFFFEC4C) 
+#define AT91C_SMC_CTRL3 (AT91_CAST(AT91_REG *) 	0xFFFFEC3C) 
+#define AT91C_SMC_SETUP7 (AT91_CAST(AT91_REG *) 	0xFFFFEC70) 
+#define AT91C_SMC_CTRL7 (AT91_CAST(AT91_REG *) 	0xFFFFEC7C) 
+#define AT91C_SMC_SETUP1 (AT91_CAST(AT91_REG *) 	0xFFFFEC10) 
+#define AT91C_SMC_CYCLE0 (AT91_CAST(AT91_REG *) 	0xFFFFEC08) 
+#define AT91C_SMC_CTRL5 (AT91_CAST(AT91_REG *) 	0xFFFFEC5C) 
+#define AT91C_SMC_CYCLE1 (AT91_CAST(AT91_REG *) 	0xFFFFEC18) 
+#define AT91C_SMC_CTRL6 (AT91_CAST(AT91_REG *) 	0xFFFFEC6C) 
+#define AT91C_SMC_SETUP0 (AT91_CAST(AT91_REG *) 	0xFFFFEC00) 
+#define AT91C_SMC_PULSE4 (AT91_CAST(AT91_REG *) 	0xFFFFEC44) 
+#define AT91C_SMC_SETUP5 (AT91_CAST(AT91_REG *) 	0xFFFFEC50) 
+#define AT91C_SMC_SETUP2 (AT91_CAST(AT91_REG *) 	0xFFFFEC20) 
+#define AT91C_SMC_CYCLE3 (AT91_CAST(AT91_REG *) 	0xFFFFEC38) 
+#define AT91C_SMC_CYCLE6 (AT91_CAST(AT91_REG *) 	0xFFFFEC68) 
+#define AT91C_SMC_SETUP6 (AT91_CAST(AT91_REG *) 	0xFFFFEC60) 
+#define AT91C_SMC_CYCLE4 (AT91_CAST(AT91_REG *) 	0xFFFFEC48) 
+#define AT91C_SMC_PULSE2 (AT91_CAST(AT91_REG *) 	0xFFFFEC24) 
+#define AT91C_SMC_SETUP3 (AT91_CAST(AT91_REG *) 	0xFFFFEC30) 
+
+#define AT91C_MATRIX_MCFG0 (AT91_CAST(AT91_REG *) 	0xFFFFEE00) 
+#define AT91C_MATRIX_MCFG7 (AT91_CAST(AT91_REG *) 	0xFFFFEE1C) 
+#define AT91C_MATRIX_SCFG1 (AT91_CAST(AT91_REG *) 	0xFFFFEE44) 
+#define AT91C_MATRIX_MCFG4 (AT91_CAST(AT91_REG *) 	0xFFFFEE10) 
+#define AT91C_MATRIX_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFEFFC) 
+#define AT91C_MATRIX_MCFG2 (AT91_CAST(AT91_REG *) 	0xFFFFEE08) 
+#define AT91C_MATRIX_PRBS0 (AT91_CAST(AT91_REG *) 	0xFFFFEE84) 
+#define AT91C_MATRIX_SCFG3 (AT91_CAST(AT91_REG *) 	0xFFFFEE4C) 
+#define AT91C_MATRIX_MCFG6 (AT91_CAST(AT91_REG *) 	0xFFFFEE18) 
+#define AT91C_MATRIX_EBI (AT91_CAST(AT91_REG *) 	0xFFFFEF1C) 
+#define AT91C_MATRIX_SCFG0 (AT91_CAST(AT91_REG *) 	0xFFFFEE40) 
+#define AT91C_MATRIX_PRAS0 (AT91_CAST(AT91_REG *) 	0xFFFFEE80) 
+#define AT91C_MATRIX_MCFG3 (AT91_CAST(AT91_REG *) 	0xFFFFEE0C) 
+#define AT91C_MATRIX_PRAS1 (AT91_CAST(AT91_REG *) 	0xFFFFEE88) 
+#define AT91C_MATRIX_PRAS2 (AT91_CAST(AT91_REG *) 	0xFFFFEE90) 
+#define AT91C_MATRIX_SCFG2 (AT91_CAST(AT91_REG *) 	0xFFFFEE48) 
+#define AT91C_MATRIX_MCFG5 (AT91_CAST(AT91_REG *) 	0xFFFFEE14) 
+#define AT91C_MATRIX_MCFG1 (AT91_CAST(AT91_REG *) 	0xFFFFEE04) 
+#define AT91C_MATRIX_MRCR (AT91_CAST(AT91_REG *) 	0xFFFFEF00) 
+#define AT91C_MATRIX_PRBS2 (AT91_CAST(AT91_REG *) 	0xFFFFEE94) 
+#define AT91C_MATRIX_SCFG4 (AT91_CAST(AT91_REG *) 	0xFFFFEE50) 
+#define AT91C_MATRIX_TEAKCFG (AT91_CAST(AT91_REG *) 	0xFFFFEF2C) 
+#define AT91C_MATRIX_PRBS1 (AT91_CAST(AT91_REG *) 	0xFFFFEE8C) 
+
+#define AT91C_CCFG_MATRIXVERSION (AT91_CAST(AT91_REG *) 	0xFFFFEFFC) 
+#define AT91C_CCFG_EBICSA (AT91_CAST(AT91_REG *) 	0xFFFFEF1C) 
+
+#define AT91C_DBGU_TCR  (AT91_CAST(AT91_REG *) 	0xFFFFF30C) 
+#define AT91C_DBGU_RNPR (AT91_CAST(AT91_REG *) 	0xFFFFF310) 
+#define AT91C_DBGU_TNPR (AT91_CAST(AT91_REG *) 	0xFFFFF318) 
+#define AT91C_DBGU_TPR  (AT91_CAST(AT91_REG *) 	0xFFFFF308) 
+#define AT91C_DBGU_RPR  (AT91_CAST(AT91_REG *) 	0xFFFFF300) 
+#define AT91C_DBGU_RCR  (AT91_CAST(AT91_REG *) 	0xFFFFF304) 
+#define AT91C_DBGU_RNCR (AT91_CAST(AT91_REG *) 	0xFFFFF314) 
+#define AT91C_DBGU_PTCR (AT91_CAST(AT91_REG *) 	0xFFFFF320) 
+#define AT91C_DBGU_PTSR (AT91_CAST(AT91_REG *) 	0xFFFFF324) 
+#define AT91C_DBGU_TNCR (AT91_CAST(AT91_REG *) 	0xFFFFF31C) 
+
+#define AT91C_DBGU_EXID (AT91_CAST(AT91_REG *) 	0xFFFFF244) 
+#define AT91C_DBGU_BRGR (AT91_CAST(AT91_REG *) 	0xFFFFF220) 
+#define AT91C_DBGU_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF20C) 
+#define AT91C_DBGU_CSR  (AT91_CAST(AT91_REG *) 	0xFFFFF214) 
+#define AT91C_DBGU_CIDR (AT91_CAST(AT91_REG *) 	0xFFFFF240) 
+#define AT91C_DBGU_MR   (AT91_CAST(AT91_REG *) 	0xFFFFF204) 
+#define AT91C_DBGU_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF210) 
+#define AT91C_DBGU_CR   (AT91_CAST(AT91_REG *) 	0xFFFFF200) 
+#define AT91C_DBGU_FNTR (AT91_CAST(AT91_REG *) 	0xFFFFF248) 
+#define AT91C_DBGU_THR  (AT91_CAST(AT91_REG *) 	0xFFFFF21C) 
+#define AT91C_DBGU_RHR  (AT91_CAST(AT91_REG *) 	0xFFFFF218) 
+#define AT91C_DBGU_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF208) 
+
+#define AT91C_AIC_IVR   (AT91_CAST(AT91_REG *) 	0xFFFFF100) 
+#define AT91C_AIC_SMR   (AT91_CAST(AT91_REG *) 	0xFFFFF000) 
+#define AT91C_AIC_FVR   (AT91_CAST(AT91_REG *) 	0xFFFFF104) 
+#define AT91C_AIC_DCR   (AT91_CAST(AT91_REG *) 	0xFFFFF138) 
+#define AT91C_AIC_EOICR (AT91_CAST(AT91_REG *) 	0xFFFFF130) 
+#define AT91C_AIC_SVR   (AT91_CAST(AT91_REG *) 	0xFFFFF080) 
+#define AT91C_AIC_FFSR  (AT91_CAST(AT91_REG *) 	0xFFFFF148) 
+#define AT91C_AIC_ICCR  (AT91_CAST(AT91_REG *) 	0xFFFFF128) 
+#define AT91C_AIC_ISR   (AT91_CAST(AT91_REG *) 	0xFFFFF108) 
+#define AT91C_AIC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFFF110) 
+#define AT91C_AIC_IPR   (AT91_CAST(AT91_REG *) 	0xFFFFF10C) 
+#define AT91C_AIC_FFER  (AT91_CAST(AT91_REG *) 	0xFFFFF140) 
+#define AT91C_AIC_IECR  (AT91_CAST(AT91_REG *) 	0xFFFFF120) 
+#define AT91C_AIC_ISCR  (AT91_CAST(AT91_REG *) 	0xFFFFF12C) 
+#define AT91C_AIC_FFDR  (AT91_CAST(AT91_REG *) 	0xFFFFF144) 
+#define AT91C_AIC_CISR  (AT91_CAST(AT91_REG *) 	0xFFFFF114) 
+#define AT91C_AIC_IDCR  (AT91_CAST(AT91_REG *) 	0xFFFFF124) 
+#define AT91C_AIC_SPU   (AT91_CAST(AT91_REG *) 	0xFFFFF134) 
+
+#define AT91C_PIOA_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF414) 
+#define AT91C_PIOA_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF430) 
+#define AT91C_PIOA_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF44C) 
+#define AT91C_PIOA_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF478) 
+#define AT91C_PIOA_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF440) 
+#define AT91C_PIOA_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF460) 
+#define AT91C_PIOA_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF448) 
+#define AT91C_PIOA_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF400) 
+#define AT91C_PIOA_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF424) 
+#define AT91C_PIOA_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF4A4) 
+#define AT91C_PIOA_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF458) 
+#define AT91C_PIOA_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF444) 
+#define AT91C_PIOA_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF438) 
+#define AT91C_PIOA_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF468) 
+#define AT91C_PIOA_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF4A8) 
+#define AT91C_PIOA_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF474) 
+#define AT91C_PIOA_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF4A0) 
+#define AT91C_PIOA_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF420) 
+#define AT91C_PIOA_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF43C) 
+#define AT91C_PIOA_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF464) 
+#define AT91C_PIOA_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF418) 
+#define AT91C_PIOA_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF470) 
+#define AT91C_PIOA_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF454) 
+#define AT91C_PIOA_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF434) 
+#define AT91C_PIOA_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF450) 
+#define AT91C_PIOA_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF404) 
+#define AT91C_PIOA_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF428) 
+#define AT91C_PIOA_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF410) 
+#define AT91C_PIOA_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF408) 
+
+#define AT91C_PIOB_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF6A4) 
+#define AT91C_PIOB_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF650) 
+#define AT91C_PIOB_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF668) 
+#define AT91C_PIOB_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF648) 
+#define AT91C_PIOB_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF670) 
+#define AT91C_PIOB_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF660) 
+#define AT91C_PIOB_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF608) 
+#define AT91C_PIOB_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF640) 
+#define AT91C_PIOB_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF634) 
+#define AT91C_PIOB_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF6A0) 
+#define AT91C_PIOB_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF678) 
+#define AT91C_PIOB_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF624) 
+#define AT91C_PIOB_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF63C) 
+#define AT91C_PIOB_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF644) 
+#define AT91C_PIOB_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF6A8) 
+#define AT91C_PIOB_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF604) 
+#define AT91C_PIOB_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF614) 
+#define AT91C_PIOB_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF628) 
+#define AT91C_PIOB_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF664) 
+#define AT91C_PIOB_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF630) 
+#define AT91C_PIOB_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF64C) 
+#define AT91C_PIOB_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF638) 
+#define AT91C_PIOB_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF618) 
+#define AT91C_PIOB_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF658) 
+#define AT91C_PIOB_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF620) 
+#define AT91C_PIOB_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF674) 
+#define AT91C_PIOB_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF654) 
+#define AT91C_PIOB_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF610) 
+#define AT91C_PIOB_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF600) 
+
+#define AT91C_PIOC_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF8A4) 
+#define AT91C_PIOC_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF830) 
+#define AT91C_PIOC_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF864) 
+#define AT91C_PIOC_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF834) 
+#define AT91C_PIOC_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF808) 
+#define AT91C_PIOC_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF804) 
+#define AT91C_PIOC_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF814) 
+#define AT91C_PIOC_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF868) 
+#define AT91C_PIOC_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF878) 
+#define AT91C_PIOC_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF828) 
+#define AT91C_PIOC_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF810) 
+#define AT91C_PIOC_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF848) 
+#define AT91C_PIOC_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF870) 
+#define AT91C_PIOC_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF854) 
+#define AT91C_PIOC_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF8A8) 
+#define AT91C_PIOC_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF800) 
+#define AT91C_PIOC_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF844) 
+#define AT91C_PIOC_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF850) 
+#define AT91C_PIOC_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF83C) 
+#define AT91C_PIOC_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF858) 
+#define AT91C_PIOC_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF8A0) 
+#define AT91C_PIOC_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF874) 
+#define AT91C_PIOC_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF860) 
+#define AT91C_PIOC_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF824) 
+#define AT91C_PIOC_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF840) 
+#define AT91C_PIOC_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF818) 
+#define AT91C_PIOC_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF838) 
+#define AT91C_PIOC_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF84C) 
+#define AT91C_PIOC_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF820) 
+
+#define AT91C_CKGR_MOR  (AT91_CAST(AT91_REG *) 	0xFFFFFC20) 
+#define AT91C_CKGR_PLLBR (AT91_CAST(AT91_REG *) 	0xFFFFFC2C) 
+#define AT91C_CKGR_MCFR (AT91_CAST(AT91_REG *) 	0xFFFFFC24) 
+#define AT91C_CKGR_PLLAR (AT91_CAST(AT91_REG *) 	0xFFFFFC28) 
+
+#define AT91C_PMC_PCER  (AT91_CAST(AT91_REG *) 	0xFFFFFC10) 
+#define AT91C_PMC_PCKR  (AT91_CAST(AT91_REG *) 	0xFFFFFC40) 
+#define AT91C_PMC_MCKR  (AT91_CAST(AT91_REG *) 	0xFFFFFC30) 
+#define AT91C_PMC_PLLAR (AT91_CAST(AT91_REG *) 	0xFFFFFC28) 
+#define AT91C_PMC_PCDR  (AT91_CAST(AT91_REG *) 	0xFFFFFC14) 
+#define AT91C_PMC_SCSR  (AT91_CAST(AT91_REG *) 	0xFFFFFC08) 
+#define AT91C_PMC_MCFR  (AT91_CAST(AT91_REG *) 	0xFFFFFC24) 
+#define AT91C_PMC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFFFC6C) 
+#define AT91C_PMC_IER   (AT91_CAST(AT91_REG *) 	0xFFFFFC60) 
+#define AT91C_PMC_MOR   (AT91_CAST(AT91_REG *) 	0xFFFFFC20) 
+#define AT91C_PMC_IDR   (AT91_CAST(AT91_REG *) 	0xFFFFFC64) 
+#define AT91C_PMC_PLLBR (AT91_CAST(AT91_REG *) 	0xFFFFFC2C) 
+#define AT91C_PMC_SCDR  (AT91_CAST(AT91_REG *) 	0xFFFFFC04) 
+#define AT91C_PMC_PCSR  (AT91_CAST(AT91_REG *) 	0xFFFFFC18) 
+#define AT91C_PMC_SCER  (AT91_CAST(AT91_REG *) 	0xFFFFFC00) 
+#define AT91C_PMC_SR    (AT91_CAST(AT91_REG *) 	0xFFFFFC68) 
+
+#define AT91C_RSTC_RCR  (AT91_CAST(AT91_REG *) 	0xFFFFFD00) 
+#define AT91C_RSTC_RMR  (AT91_CAST(AT91_REG *) 	0xFFFFFD08) 
+#define AT91C_RSTC_RSR  (AT91_CAST(AT91_REG *) 	0xFFFFFD04) 
+
+#define AT91C_SHDWC_SHSR (AT91_CAST(AT91_REG *) 	0xFFFFFD18) 
+#define AT91C_SHDWC_SHMR (AT91_CAST(AT91_REG *) 	0xFFFFFD14) 
+#define AT91C_SHDWC_SHCR (AT91_CAST(AT91_REG *) 	0xFFFFFD10) 
+
+#define AT91C_RTTC_RTSR (AT91_CAST(AT91_REG *) 	0xFFFFFD2C) 
+#define AT91C_RTTC_RTMR (AT91_CAST(AT91_REG *) 	0xFFFFFD20) 
+#define AT91C_RTTC_RTVR (AT91_CAST(AT91_REG *) 	0xFFFFFD28) 
+#define AT91C_RTTC_RTAR (AT91_CAST(AT91_REG *) 	0xFFFFFD24) 
+
+#define AT91C_PITC_PIVR (AT91_CAST(AT91_REG *) 	0xFFFFFD38) 
+#define AT91C_PITC_PISR (AT91_CAST(AT91_REG *) 	0xFFFFFD34) 
+#define AT91C_PITC_PIIR (AT91_CAST(AT91_REG *) 	0xFFFFFD3C) 
+#define AT91C_PITC_PIMR (AT91_CAST(AT91_REG *) 	0xFFFFFD30) 
+
+#define AT91C_WDTC_WDCR (AT91_CAST(AT91_REG *) 	0xFFFFFD40) 
+#define AT91C_WDTC_WDSR (AT91_CAST(AT91_REG *) 	0xFFFFFD48) 
+#define AT91C_WDTC_WDMR (AT91_CAST(AT91_REG *) 	0xFFFFFD44) 
+
+#define AT91C_TC0_SR    (AT91_CAST(AT91_REG *) 	0xFFFA0020) 
+#define AT91C_TC0_RC    (AT91_CAST(AT91_REG *) 	0xFFFA001C) 
+#define AT91C_TC0_RB    (AT91_CAST(AT91_REG *) 	0xFFFA0018) 
+#define AT91C_TC0_CCR   (AT91_CAST(AT91_REG *) 	0xFFFA0000) 
+#define AT91C_TC0_CMR   (AT91_CAST(AT91_REG *) 	0xFFFA0004) 
+#define AT91C_TC0_IER   (AT91_CAST(AT91_REG *) 	0xFFFA0024) 
+#define AT91C_TC0_RA    (AT91_CAST(AT91_REG *) 	0xFFFA0014) 
+#define AT91C_TC0_IDR   (AT91_CAST(AT91_REG *) 	0xFFFA0028) 
+#define AT91C_TC0_CV    (AT91_CAST(AT91_REG *) 	0xFFFA0010) 
+#define AT91C_TC0_IMR   (AT91_CAST(AT91_REG *) 	0xFFFA002C) 
+
+#define AT91C_TC1_RB    (AT91_CAST(AT91_REG *) 	0xFFFA0058) 
+#define AT91C_TC1_CCR   (AT91_CAST(AT91_REG *) 	0xFFFA0040) 
+#define AT91C_TC1_IER   (AT91_CAST(AT91_REG *) 	0xFFFA0064) 
+#define AT91C_TC1_IDR   (AT91_CAST(AT91_REG *) 	0xFFFA0068) 
+#define AT91C_TC1_SR    (AT91_CAST(AT91_REG *) 	0xFFFA0060) 
+#define AT91C_TC1_CMR   (AT91_CAST(AT91_REG *) 	0xFFFA0044) 
+#define AT91C_TC1_RA    (AT91_CAST(AT91_REG *) 	0xFFFA0054) 
+#define AT91C_TC1_RC    (AT91_CAST(AT91_REG *) 	0xFFFA005C) 
+#define AT91C_TC1_IMR   (AT91_CAST(AT91_REG *) 	0xFFFA006C) 
+#define AT91C_TC1_CV    (AT91_CAST(AT91_REG *) 	0xFFFA0050) 
+
+#define AT91C_TC2_CMR   (AT91_CAST(AT91_REG *) 	0xFFFA0084) 
+#define AT91C_TC2_CCR   (AT91_CAST(AT91_REG *) 	0xFFFA0080) 
+#define AT91C_TC2_CV    (AT91_CAST(AT91_REG *) 	0xFFFA0090) 
+#define AT91C_TC2_RA    (AT91_CAST(AT91_REG *) 	0xFFFA0094) 
+#define AT91C_TC2_RB    (AT91_CAST(AT91_REG *) 	0xFFFA0098) 
+#define AT91C_TC2_IDR   (AT91_CAST(AT91_REG *) 	0xFFFA00A8) 
+#define AT91C_TC2_IMR   (AT91_CAST(AT91_REG *) 	0xFFFA00AC) 
+#define AT91C_TC2_RC    (AT91_CAST(AT91_REG *) 	0xFFFA009C) 
+#define AT91C_TC2_IER   (AT91_CAST(AT91_REG *) 	0xFFFA00A4) 
+#define AT91C_TC2_SR    (AT91_CAST(AT91_REG *) 	0xFFFA00A0) 
+
+#define AT91C_TC3_IER   (AT91_CAST(AT91_REG *) 	0xFFFDC024) 
+#define AT91C_TC3_RB    (AT91_CAST(AT91_REG *) 	0xFFFDC018) 
+#define AT91C_TC3_CMR   (AT91_CAST(AT91_REG *) 	0xFFFDC004) 
+#define AT91C_TC3_RC    (AT91_CAST(AT91_REG *) 	0xFFFDC01C) 
+#define AT91C_TC3_CCR   (AT91_CAST(AT91_REG *) 	0xFFFDC000) 
+#define AT91C_TC3_SR    (AT91_CAST(AT91_REG *) 	0xFFFDC020) 
+#define AT91C_TC3_CV    (AT91_CAST(AT91_REG *) 	0xFFFDC010) 
+#define AT91C_TC3_RA    (AT91_CAST(AT91_REG *) 	0xFFFDC014) 
+#define AT91C_TC3_IDR   (AT91_CAST(AT91_REG *) 	0xFFFDC028) 
+#define AT91C_TC3_IMR   (AT91_CAST(AT91_REG *) 	0xFFFDC02C) 
+
+#define AT91C_TC4_CMR   (AT91_CAST(AT91_REG *) 	0xFFFDC044) 
+#define AT91C_TC4_RC    (AT91_CAST(AT91_REG *) 	0xFFFDC05C) 
+#define AT91C_TC4_SR    (AT91_CAST(AT91_REG *) 	0xFFFDC060) 
+#define AT91C_TC4_RB    (AT91_CAST(AT91_REG *) 	0xFFFDC058) 
+#define AT91C_TC4_IER   (AT91_CAST(AT91_REG *) 	0xFFFDC064) 
+#define AT91C_TC4_CV    (AT91_CAST(AT91_REG *) 	0xFFFDC050) 
+#define AT91C_TC4_RA    (AT91_CAST(AT91_REG *) 	0xFFFDC054) 
+#define AT91C_TC4_IDR   (AT91_CAST(AT91_REG *) 	0xFFFDC068) 
+#define AT91C_TC4_IMR   (AT91_CAST(AT91_REG *) 	0xFFFDC06C) 
+#define AT91C_TC4_CCR   (AT91_CAST(AT91_REG *) 	0xFFFDC040) 
+
+#define AT91C_TC5_RB    (AT91_CAST(AT91_REG *) 	0xFFFDC098) 
+#define AT91C_TC5_RA    (AT91_CAST(AT91_REG *) 	0xFFFDC094) 
+#define AT91C_TC5_CV    (AT91_CAST(AT91_REG *) 	0xFFFDC090) 
+#define AT91C_TC5_CCR   (AT91_CAST(AT91_REG *) 	0xFFFDC080) 
+#define AT91C_TC5_SR    (AT91_CAST(AT91_REG *) 	0xFFFDC0A0) 
+#define AT91C_TC5_IER   (AT91_CAST(AT91_REG *) 	0xFFFDC0A4) 
+#define AT91C_TC5_IDR   (AT91_CAST(AT91_REG *) 	0xFFFDC0A8) 
+#define AT91C_TC5_RC    (AT91_CAST(AT91_REG *) 	0xFFFDC09C) 
+#define AT91C_TC5_IMR   (AT91_CAST(AT91_REG *) 	0xFFFDC0AC) 
+#define AT91C_TC5_CMR   (AT91_CAST(AT91_REG *) 	0xFFFDC084) 
+
+#define AT91C_TCB0_BMR  (AT91_CAST(AT91_REG *) 	0xFFFA00C4) 
+#define AT91C_TCB0_BCR  (AT91_CAST(AT91_REG *) 	0xFFFA00C0) 
+
+#define AT91C_TCB1_BCR  (AT91_CAST(AT91_REG *) 	0xFFFDC0C0) 
+#define AT91C_TCB1_BMR  (AT91_CAST(AT91_REG *) 	0xFFFDC0C4) 
+
+#define AT91C_MCI_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFA8114) 
+#define AT91C_MCI_TCR   (AT91_CAST(AT91_REG *) 	0xFFFA810C) 
+#define AT91C_MCI_RCR   (AT91_CAST(AT91_REG *) 	0xFFFA8104) 
+#define AT91C_MCI_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFA8118) 
+#define AT91C_MCI_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFA8110) 
+#define AT91C_MCI_RPR   (AT91_CAST(AT91_REG *) 	0xFFFA8100) 
+#define AT91C_MCI_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFA811C) 
+#define AT91C_MCI_TPR   (AT91_CAST(AT91_REG *) 	0xFFFA8108) 
+#define AT91C_MCI_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFA8124) 
+#define AT91C_MCI_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFA8120) 
+
+#define AT91C_MCI_RDR   (AT91_CAST(AT91_REG *) 	0xFFFA8030) 
+#define AT91C_MCI_CMDR  (AT91_CAST(AT91_REG *) 	0xFFFA8014) 
+#define AT91C_MCI_VR    (AT91_CAST(AT91_REG *) 	0xFFFA80FC) 
+#define AT91C_MCI_IDR   (AT91_CAST(AT91_REG *) 	0xFFFA8048) 
+#define AT91C_MCI_DTOR  (AT91_CAST(AT91_REG *) 	0xFFFA8008) 
+#define AT91C_MCI_TDR   (AT91_CAST(AT91_REG *) 	0xFFFA8034) 
+#define AT91C_MCI_IER   (AT91_CAST(AT91_REG *) 	0xFFFA8044) 
+#define AT91C_MCI_BLKR  (AT91_CAST(AT91_REG *) 	0xFFFA8018) 
+#define AT91C_MCI_MR    (AT91_CAST(AT91_REG *) 	0xFFFA8004) 
+#define AT91C_MCI_IMR   (AT91_CAST(AT91_REG *) 	0xFFFA804C) 
+#define AT91C_MCI_CR    (AT91_CAST(AT91_REG *) 	0xFFFA8000) 
+#define AT91C_MCI_ARGR  (AT91_CAST(AT91_REG *) 	0xFFFA8010) 
+#define AT91C_MCI_SDCR  (AT91_CAST(AT91_REG *) 	0xFFFA800C) 
+#define AT91C_MCI_SR    (AT91_CAST(AT91_REG *) 	0xFFFA8040) 
+#define AT91C_MCI_RSPR  (AT91_CAST(AT91_REG *) 	0xFFFA8020) 
+
+#define AT91C_TWI_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFAC124) 
+#define AT91C_TWI_RPR   (AT91_CAST(AT91_REG *) 	0xFFFAC100) 
+#define AT91C_TWI_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFAC114) 
+#define AT91C_TWI_RCR   (AT91_CAST(AT91_REG *) 	0xFFFAC104) 
+#define AT91C_TWI_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFAC120) 
+#define AT91C_TWI_TPR   (AT91_CAST(AT91_REG *) 	0xFFFAC108) 
+#define AT91C_TWI_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFAC110) 
+#define AT91C_TWI_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFAC118) 
+#define AT91C_TWI_TCR   (AT91_CAST(AT91_REG *) 	0xFFFAC10C) 
+#define AT91C_TWI_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFAC11C) 
+
+#define AT91C_TWI_THR   (AT91_CAST(AT91_REG *) 	0xFFFAC034) 
+#define AT91C_TWI_IDR   (AT91_CAST(AT91_REG *) 	0xFFFAC028) 
+#define AT91C_TWI_SMR   (AT91_CAST(AT91_REG *) 	0xFFFAC008) 
+#define AT91C_TWI_CWGR  (AT91_CAST(AT91_REG *) 	0xFFFAC010) 
+#define AT91C_TWI_IADR  (AT91_CAST(AT91_REG *) 	0xFFFAC00C) 
+#define AT91C_TWI_RHR   (AT91_CAST(AT91_REG *) 	0xFFFAC030) 
+#define AT91C_TWI_IER   (AT91_CAST(AT91_REG *) 	0xFFFAC024) 
+#define AT91C_TWI_MMR   (AT91_CAST(AT91_REG *) 	0xFFFAC004) 
+#define AT91C_TWI_SR    (AT91_CAST(AT91_REG *) 	0xFFFAC020) 
+#define AT91C_TWI_IMR   (AT91_CAST(AT91_REG *) 	0xFFFAC02C) 
+#define AT91C_TWI_CR    (AT91_CAST(AT91_REG *) 	0xFFFAC000) 
+
+#define AT91C_US0_TCR   (AT91_CAST(AT91_REG *) 	0xFFFB010C) 
+#define AT91C_US0_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFB0120) 
+#define AT91C_US0_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFB0114) 
+#define AT91C_US0_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFB0124) 
+#define AT91C_US0_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFB011C) 
+#define AT91C_US0_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFB0110) 
+#define AT91C_US0_RCR   (AT91_CAST(AT91_REG *) 	0xFFFB0104) 
+#define AT91C_US0_TPR   (AT91_CAST(AT91_REG *) 	0xFFFB0108) 
+#define AT91C_US0_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFB0118) 
+#define AT91C_US0_RPR   (AT91_CAST(AT91_REG *) 	0xFFFB0100) 
+
+#define AT91C_US0_RHR   (AT91_CAST(AT91_REG *) 	0xFFFB0018) 
+#define AT91C_US0_NER   (AT91_CAST(AT91_REG *) 	0xFFFB0044) 
+#define AT91C_US0_IER   (AT91_CAST(AT91_REG *) 	0xFFFB0008) 
+#define AT91C_US0_CR    (AT91_CAST(AT91_REG *) 	0xFFFB0000) 
+#define AT91C_US0_THR   (AT91_CAST(AT91_REG *) 	0xFFFB001C) 
+#define AT91C_US0_CSR   (AT91_CAST(AT91_REG *) 	0xFFFB0014) 
+#define AT91C_US0_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFB0020) 
+#define AT91C_US0_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFB0024) 
+#define AT91C_US0_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFB0028) 
+#define AT91C_US0_IDR   (AT91_CAST(AT91_REG *) 	0xFFFB000C) 
+#define AT91C_US0_MR    (AT91_CAST(AT91_REG *) 	0xFFFB0004) 
+#define AT91C_US0_IF    (AT91_CAST(AT91_REG *) 	0xFFFB004C) 
+#define AT91C_US0_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFB0040) 
+#define AT91C_US0_IMR   (AT91_CAST(AT91_REG *) 	0xFFFB0010) 
+
+#define AT91C_US1_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFB4120) 
+#define AT91C_US1_RCR   (AT91_CAST(AT91_REG *) 	0xFFFB4104) 
+#define AT91C_US1_RPR   (AT91_CAST(AT91_REG *) 	0xFFFB4100) 
+#define AT91C_US1_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFB4124) 
+#define AT91C_US1_TPR   (AT91_CAST(AT91_REG *) 	0xFFFB4108) 
+#define AT91C_US1_TCR   (AT91_CAST(AT91_REG *) 	0xFFFB410C) 
+#define AT91C_US1_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFB4110) 
+#define AT91C_US1_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFB411C) 
+#define AT91C_US1_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFB4114) 
+#define AT91C_US1_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFB4118) 
+
+#define AT91C_US1_THR   (AT91_CAST(AT91_REG *) 	0xFFFB401C) 
+#define AT91C_US1_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFB4028) 
+#define AT91C_US1_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFB4020) 
+#define AT91C_US1_IDR   (AT91_CAST(AT91_REG *) 	0xFFFB400C) 
+#define AT91C_US1_MR    (AT91_CAST(AT91_REG *) 	0xFFFB4004) 
+#define AT91C_US1_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFB4024) 
+#define AT91C_US1_CR    (AT91_CAST(AT91_REG *) 	0xFFFB4000) 
+#define AT91C_US1_IMR   (AT91_CAST(AT91_REG *) 	0xFFFB4010) 
+#define AT91C_US1_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFB4040) 
+#define AT91C_US1_RHR   (AT91_CAST(AT91_REG *) 	0xFFFB4018) 
+#define AT91C_US1_IER   (AT91_CAST(AT91_REG *) 	0xFFFB4008) 
+#define AT91C_US1_CSR   (AT91_CAST(AT91_REG *) 	0xFFFB4014) 
+#define AT91C_US1_IF    (AT91_CAST(AT91_REG *) 	0xFFFB404C) 
+#define AT91C_US1_NER   (AT91_CAST(AT91_REG *) 	0xFFFB4044) 
+
+#define AT91C_US2_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFB811C) 
+#define AT91C_US2_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFB8114) 
+#define AT91C_US2_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFB8118) 
+#define AT91C_US2_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFB8120) 
+#define AT91C_US2_TCR   (AT91_CAST(AT91_REG *) 	0xFFFB810C) 
+#define AT91C_US2_RPR   (AT91_CAST(AT91_REG *) 	0xFFFB8100) 
+#define AT91C_US2_TPR   (AT91_CAST(AT91_REG *) 	0xFFFB8108) 
+#define AT91C_US2_RCR   (AT91_CAST(AT91_REG *) 	0xFFFB8104) 
+#define AT91C_US2_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFB8124) 
+#define AT91C_US2_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFB8110) 
+
+#define AT91C_US2_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFB8024) 
+#define AT91C_US2_CSR   (AT91_CAST(AT91_REG *) 	0xFFFB8014) 
+#define AT91C_US2_CR    (AT91_CAST(AT91_REG *) 	0xFFFB8000) 
+#define AT91C_US2_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFB8020) 
+#define AT91C_US2_NER   (AT91_CAST(AT91_REG *) 	0xFFFB8044) 
+#define AT91C_US2_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFB8040) 
+#define AT91C_US2_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFB8028) 
+#define AT91C_US2_RHR   (AT91_CAST(AT91_REG *) 	0xFFFB8018) 
+#define AT91C_US2_IDR   (AT91_CAST(AT91_REG *) 	0xFFFB800C) 
+#define AT91C_US2_THR   (AT91_CAST(AT91_REG *) 	0xFFFB801C) 
+#define AT91C_US2_MR    (AT91_CAST(AT91_REG *) 	0xFFFB8004) 
+#define AT91C_US2_IMR   (AT91_CAST(AT91_REG *) 	0xFFFB8010) 
+#define AT91C_US2_IF    (AT91_CAST(AT91_REG *) 	0xFFFB804C) 
+#define AT91C_US2_IER   (AT91_CAST(AT91_REG *) 	0xFFFB8008) 
+
+#define AT91C_US3_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFD0110) 
+#define AT91C_US3_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFD0114) 
+#define AT91C_US3_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFD0124) 
+#define AT91C_US3_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFD0120) 
+#define AT91C_US3_TCR   (AT91_CAST(AT91_REG *) 	0xFFFD010C) 
+#define AT91C_US3_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFD0118) 
+#define AT91C_US3_RCR   (AT91_CAST(AT91_REG *) 	0xFFFD0104) 
+#define AT91C_US3_TPR   (AT91_CAST(AT91_REG *) 	0xFFFD0108) 
+#define AT91C_US3_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFD011C) 
+#define AT91C_US3_RPR   (AT91_CAST(AT91_REG *) 	0xFFFD0100) 
+
+#define AT91C_US3_NER   (AT91_CAST(AT91_REG *) 	0xFFFD0044) 
+#define AT91C_US3_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFD0024) 
+#define AT91C_US3_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD000C) 
+#define AT91C_US3_MR    (AT91_CAST(AT91_REG *) 	0xFFFD0004) 
+#define AT91C_US3_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFD0040) 
+#define AT91C_US3_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFD0020) 
+#define AT91C_US3_THR   (AT91_CAST(AT91_REG *) 	0xFFFD001C) 
+#define AT91C_US3_CR    (AT91_CAST(AT91_REG *) 	0xFFFD0000) 
+#define AT91C_US3_IF    (AT91_CAST(AT91_REG *) 	0xFFFD004C) 
+#define AT91C_US3_IER   (AT91_CAST(AT91_REG *) 	0xFFFD0008) 
+#define AT91C_US3_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFD0028) 
+#define AT91C_US3_RHR   (AT91_CAST(AT91_REG *) 	0xFFFD0018) 
+#define AT91C_US3_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD0010) 
+#define AT91C_US3_CSR   (AT91_CAST(AT91_REG *) 	0xFFFD0014) 
+
+#define AT91C_US4_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFD411C) 
+#define AT91C_US4_RPR   (AT91_CAST(AT91_REG *) 	0xFFFD4100) 
+#define AT91C_US4_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFD4114) 
+#define AT91C_US4_TPR   (AT91_CAST(AT91_REG *) 	0xFFFD4108) 
+#define AT91C_US4_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFD4120) 
+#define AT91C_US4_TCR   (AT91_CAST(AT91_REG *) 	0xFFFD410C) 
+#define AT91C_US4_RCR   (AT91_CAST(AT91_REG *) 	0xFFFD4104) 
+#define AT91C_US4_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFD4110) 
+#define AT91C_US4_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFD4118) 
+#define AT91C_US4_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFD4124) 
+
+#define AT91C_US4_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFD4020) 
+#define AT91C_US4_THR   (AT91_CAST(AT91_REG *) 	0xFFFD401C) 
+#define AT91C_US4_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFD4024) 
+#define AT91C_US4_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD4010) 
+#define AT91C_US4_NER   (AT91_CAST(AT91_REG *) 	0xFFFD4044) 
+#define AT91C_US4_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFD4028) 
+#define AT91C_US4_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFD4040) 
+#define AT91C_US4_MR    (AT91_CAST(AT91_REG *) 	0xFFFD4004) 
+#define AT91C_US4_IER   (AT91_CAST(AT91_REG *) 	0xFFFD4008) 
+#define AT91C_US4_RHR   (AT91_CAST(AT91_REG *) 	0xFFFD4018) 
+#define AT91C_US4_CR    (AT91_CAST(AT91_REG *) 	0xFFFD4000) 
+#define AT91C_US4_IF    (AT91_CAST(AT91_REG *) 	0xFFFD404C) 
+#define AT91C_US4_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD400C) 
+#define AT91C_US4_CSR   (AT91_CAST(AT91_REG *) 	0xFFFD4014) 
+
+#define AT91C_US5_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFD8124) 
+#define AT91C_US5_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFD8120) 
+#define AT91C_US5_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFD8118) 
+#define AT91C_US5_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFD811C) 
+#define AT91C_US5_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFD8110) 
+#define AT91C_US5_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFD8114) 
+#define AT91C_US5_RPR   (AT91_CAST(AT91_REG *) 	0xFFFD8100) 
+#define AT91C_US5_TCR   (AT91_CAST(AT91_REG *) 	0xFFFD810C) 
+#define AT91C_US5_TPR   (AT91_CAST(AT91_REG *) 	0xFFFD8108) 
+#define AT91C_US5_RCR   (AT91_CAST(AT91_REG *) 	0xFFFD8104) 
+
+#define AT91C_US5_IF    (AT91_CAST(AT91_REG *) 	0xFFFD804C) 
+#define AT91C_US5_RTOR  (AT91_CAST(AT91_REG *) 	0xFFFD8024) 
+#define AT91C_US5_NER   (AT91_CAST(AT91_REG *) 	0xFFFD8044) 
+#define AT91C_US5_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD8010) 
+#define AT91C_US5_RHR   (AT91_CAST(AT91_REG *) 	0xFFFD8018) 
+#define AT91C_US5_CSR   (AT91_CAST(AT91_REG *) 	0xFFFD8014) 
+#define AT91C_US5_MR    (AT91_CAST(AT91_REG *) 	0xFFFD8004) 
+#define AT91C_US5_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD800C) 
+#define AT91C_US5_THR   (AT91_CAST(AT91_REG *) 	0xFFFD801C) 
+#define AT91C_US5_FIDI  (AT91_CAST(AT91_REG *) 	0xFFFD8040) 
+#define AT91C_US5_TTGR  (AT91_CAST(AT91_REG *) 	0xFFFD8028) 
+#define AT91C_US5_BRGR  (AT91_CAST(AT91_REG *) 	0xFFFD8020) 
+#define AT91C_US5_CR    (AT91_CAST(AT91_REG *) 	0xFFFD8000) 
+#define AT91C_US5_IER   (AT91_CAST(AT91_REG *) 	0xFFFD8008) 
+
+#define AT91C_SSC0_TNPR (AT91_CAST(AT91_REG *) 	0xFFFBC118) 
+#define AT91C_SSC0_TCR  (AT91_CAST(AT91_REG *) 	0xFFFBC10C) 
+#define AT91C_SSC0_RNCR (AT91_CAST(AT91_REG *) 	0xFFFBC114) 
+#define AT91C_SSC0_RPR  (AT91_CAST(AT91_REG *) 	0xFFFBC100) 
+#define AT91C_SSC0_TPR  (AT91_CAST(AT91_REG *) 	0xFFFBC108) 
+#define AT91C_SSC0_RCR  (AT91_CAST(AT91_REG *) 	0xFFFBC104) 
+#define AT91C_SSC0_RNPR (AT91_CAST(AT91_REG *) 	0xFFFBC110) 
+#define AT91C_SSC0_PTCR (AT91_CAST(AT91_REG *) 	0xFFFBC120) 
+#define AT91C_SSC0_TNCR (AT91_CAST(AT91_REG *) 	0xFFFBC11C) 
+#define AT91C_SSC0_PTSR (AT91_CAST(AT91_REG *) 	0xFFFBC124) 
+
+#define AT91C_SSC0_IMR  (AT91_CAST(AT91_REG *) 	0xFFFBC04C) 
+#define AT91C_SSC0_RFMR (AT91_CAST(AT91_REG *) 	0xFFFBC014) 
+#define AT91C_SSC0_CR   (AT91_CAST(AT91_REG *) 	0xFFFBC000) 
+#define AT91C_SSC0_TFMR (AT91_CAST(AT91_REG *) 	0xFFFBC01C) 
+#define AT91C_SSC0_CMR  (AT91_CAST(AT91_REG *) 	0xFFFBC004) 
+#define AT91C_SSC0_IER  (AT91_CAST(AT91_REG *) 	0xFFFBC044) 
+#define AT91C_SSC0_RHR  (AT91_CAST(AT91_REG *) 	0xFFFBC020) 
+#define AT91C_SSC0_RCMR (AT91_CAST(AT91_REG *) 	0xFFFBC010) 
+#define AT91C_SSC0_SR   (AT91_CAST(AT91_REG *) 	0xFFFBC040) 
+#define AT91C_SSC0_RSHR (AT91_CAST(AT91_REG *) 	0xFFFBC030) 
+#define AT91C_SSC0_THR  (AT91_CAST(AT91_REG *) 	0xFFFBC024) 
+#define AT91C_SSC0_TCMR (AT91_CAST(AT91_REG *) 	0xFFFBC018) 
+#define AT91C_SSC0_IDR  (AT91_CAST(AT91_REG *) 	0xFFFBC048) 
+#define AT91C_SSC0_TSHR (AT91_CAST(AT91_REG *) 	0xFFFBC034) 
+
+#define AT91C_SPI0_PTCR (AT91_CAST(AT91_REG *) 	0xFFFC8120) 
+#define AT91C_SPI0_TCR  (AT91_CAST(AT91_REG *) 	0xFFFC810C) 
+#define AT91C_SPI0_RPR  (AT91_CAST(AT91_REG *) 	0xFFFC8100) 
+#define AT91C_SPI0_TPR  (AT91_CAST(AT91_REG *) 	0xFFFC8108) 
+#define AT91C_SPI0_PTSR (AT91_CAST(AT91_REG *) 	0xFFFC8124) 
+#define AT91C_SPI0_RNCR (AT91_CAST(AT91_REG *) 	0xFFFC8114) 
+#define AT91C_SPI0_TNPR (AT91_CAST(AT91_REG *) 	0xFFFC8118) 
+#define AT91C_SPI0_RCR  (AT91_CAST(AT91_REG *) 	0xFFFC8104) 
+#define AT91C_SPI0_RNPR (AT91_CAST(AT91_REG *) 	0xFFFC8110) 
+#define AT91C_SPI0_TNCR (AT91_CAST(AT91_REG *) 	0xFFFC811C) 
+
+#define AT91C_SPI0_IDR  (AT91_CAST(AT91_REG *) 	0xFFFC8018) 
+#define AT91C_SPI0_TDR  (AT91_CAST(AT91_REG *) 	0xFFFC800C) 
+#define AT91C_SPI0_SR   (AT91_CAST(AT91_REG *) 	0xFFFC8010) 
+#define AT91C_SPI0_CR   (AT91_CAST(AT91_REG *) 	0xFFFC8000) 
+#define AT91C_SPI0_CSR  (AT91_CAST(AT91_REG *) 	0xFFFC8030) 
+#define AT91C_SPI0_RDR  (AT91_CAST(AT91_REG *) 	0xFFFC8008) 
+#define AT91C_SPI0_MR   (AT91_CAST(AT91_REG *) 	0xFFFC8004) 
+#define AT91C_SPI0_IER  (AT91_CAST(AT91_REG *) 	0xFFFC8014) 
+#define AT91C_SPI0_IMR  (AT91_CAST(AT91_REG *) 	0xFFFC801C) 
+
+#define AT91C_SPI1_PTCR (AT91_CAST(AT91_REG *) 	0xFFFCC120) 
+#define AT91C_SPI1_RNPR (AT91_CAST(AT91_REG *) 	0xFFFCC110) 
+#define AT91C_SPI1_RCR  (AT91_CAST(AT91_REG *) 	0xFFFCC104) 
+#define AT91C_SPI1_TPR  (AT91_CAST(AT91_REG *) 	0xFFFCC108) 
+#define AT91C_SPI1_PTSR (AT91_CAST(AT91_REG *) 	0xFFFCC124) 
+#define AT91C_SPI1_TNCR (AT91_CAST(AT91_REG *) 	0xFFFCC11C) 
+#define AT91C_SPI1_RPR  (AT91_CAST(AT91_REG *) 	0xFFFCC100) 
+#define AT91C_SPI1_TCR  (AT91_CAST(AT91_REG *) 	0xFFFCC10C) 
+#define AT91C_SPI1_RNCR (AT91_CAST(AT91_REG *) 	0xFFFCC114) 
+#define AT91C_SPI1_TNPR (AT91_CAST(AT91_REG *) 	0xFFFCC118) 
+
+#define AT91C_SPI1_IER  (AT91_CAST(AT91_REG *) 	0xFFFCC014) 
+#define AT91C_SPI1_RDR  (AT91_CAST(AT91_REG *) 	0xFFFCC008) 
+#define AT91C_SPI1_SR   (AT91_CAST(AT91_REG *) 	0xFFFCC010) 
+#define AT91C_SPI1_IMR  (AT91_CAST(AT91_REG *) 	0xFFFCC01C) 
+#define AT91C_SPI1_TDR  (AT91_CAST(AT91_REG *) 	0xFFFCC00C) 
+#define AT91C_SPI1_IDR  (AT91_CAST(AT91_REG *) 	0xFFFCC018) 
+#define AT91C_SPI1_CSR  (AT91_CAST(AT91_REG *) 	0xFFFCC030) 
+#define AT91C_SPI1_CR   (AT91_CAST(AT91_REG *) 	0xFFFCC000) 
+#define AT91C_SPI1_MR   (AT91_CAST(AT91_REG *) 	0xFFFCC004) 
+
+#define AT91C_ADC_PTCR  (AT91_CAST(AT91_REG *) 	0xFFFE0120) 
+#define AT91C_ADC_TPR   (AT91_CAST(AT91_REG *) 	0xFFFE0108) 
+#define AT91C_ADC_TCR   (AT91_CAST(AT91_REG *) 	0xFFFE010C) 
+#define AT91C_ADC_RCR   (AT91_CAST(AT91_REG *) 	0xFFFE0104) 
+#define AT91C_ADC_PTSR  (AT91_CAST(AT91_REG *) 	0xFFFE0124) 
+#define AT91C_ADC_RNPR  (AT91_CAST(AT91_REG *) 	0xFFFE0110) 
+#define AT91C_ADC_RPR   (AT91_CAST(AT91_REG *) 	0xFFFE0100) 
+#define AT91C_ADC_TNCR  (AT91_CAST(AT91_REG *) 	0xFFFE011C) 
+#define AT91C_ADC_RNCR  (AT91_CAST(AT91_REG *) 	0xFFFE0114) 
+#define AT91C_ADC_TNPR  (AT91_CAST(AT91_REG *) 	0xFFFE0118) 
+
+#define AT91C_ADC_CHDR  (AT91_CAST(AT91_REG *) 	0xFFFE0014) 
+#define AT91C_ADC_CDR3  (AT91_CAST(AT91_REG *) 	0xFFFE003C) 
+#define AT91C_ADC_CHER  (AT91_CAST(AT91_REG *) 	0xFFFE0010) 
+#define AT91C_ADC_CHSR  (AT91_CAST(AT91_REG *) 	0xFFFE0018) 
+#define AT91C_ADC_CR    (AT91_CAST(AT91_REG *) 	0xFFFE0000) 
+#define AT91C_ADC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFE002C) 
+#define AT91C_ADC_MR    (AT91_CAST(AT91_REG *) 	0xFFFE0004) 
+#define AT91C_ADC_CDR2  (AT91_CAST(AT91_REG *) 	0xFFFE0038) 
+#define AT91C_ADC_SR    (AT91_CAST(AT91_REG *) 	0xFFFE001C) 
+#define AT91C_ADC_LCDR  (AT91_CAST(AT91_REG *) 	0xFFFE0020) 
+#define AT91C_ADC_IER   (AT91_CAST(AT91_REG *) 	0xFFFE0024) 
+#define AT91C_ADC_CDR1  (AT91_CAST(AT91_REG *) 	0xFFFE0034) 
+#define AT91C_ADC_IDR   (AT91_CAST(AT91_REG *) 	0xFFFE0028) 
+#define AT91C_ADC_CDR0  (AT91_CAST(AT91_REG *) 	0xFFFE0030) 
+
+#define AT91C_EMACB_USRIO (AT91_CAST(AT91_REG *) 	0xFFFC40C0) 
+#define AT91C_EMACB_RSE (AT91_CAST(AT91_REG *) 	0xFFFC4074) 
+#define AT91C_EMACB_SCF (AT91_CAST(AT91_REG *) 	0xFFFC4044) 
+#define AT91C_EMACB_STE (AT91_CAST(AT91_REG *) 	0xFFFC4084) 
+#define AT91C_EMACB_SA1H (AT91_CAST(AT91_REG *) 	0xFFFC409C) 
+#define AT91C_EMACB_ROV (AT91_CAST(AT91_REG *) 	0xFFFC4070) 
+#define AT91C_EMACB_TBQP (AT91_CAST(AT91_REG *) 	0xFFFC401C) 
+#define AT91C_EMACB_IMR (AT91_CAST(AT91_REG *) 	0xFFFC4030) 
+#define AT91C_EMACB_IER (AT91_CAST(AT91_REG *) 	0xFFFC4028) 
+#define AT91C_EMACB_REV (AT91_CAST(AT91_REG *) 	0xFFFC40FC) 
+#define AT91C_EMACB_SA3L (AT91_CAST(AT91_REG *) 	0xFFFC40A8) 
+#define AT91C_EMACB_ELE (AT91_CAST(AT91_REG *) 	0xFFFC4078) 
+#define AT91C_EMACB_HRT (AT91_CAST(AT91_REG *) 	0xFFFC4094) 
+#define AT91C_EMACB_SA2L (AT91_CAST(AT91_REG *) 	0xFFFC40A0) 
+#define AT91C_EMACB_RRE (AT91_CAST(AT91_REG *) 	0xFFFC406C) 
+#define AT91C_EMACB_FRO (AT91_CAST(AT91_REG *) 	0xFFFC404C) 
+#define AT91C_EMACB_TPQ (AT91_CAST(AT91_REG *) 	0xFFFC40BC) 
+#define AT91C_EMACB_ISR (AT91_CAST(AT91_REG *) 	0xFFFC4024) 
+#define AT91C_EMACB_TSR (AT91_CAST(AT91_REG *) 	0xFFFC4014) 
+#define AT91C_EMACB_RLE (AT91_CAST(AT91_REG *) 	0xFFFC4088) 
+#define AT91C_EMACB_USF (AT91_CAST(AT91_REG *) 	0xFFFC4080) 
+#define AT91C_EMACB_WOL (AT91_CAST(AT91_REG *) 	0xFFFC40C4) 
+#define AT91C_EMACB_TPF (AT91_CAST(AT91_REG *) 	0xFFFC408C) 
+#define AT91C_EMACB_PTR (AT91_CAST(AT91_REG *) 	0xFFFC4038) 
+#define AT91C_EMACB_TUND (AT91_CAST(AT91_REG *) 	0xFFFC4064) 
+#define AT91C_EMACB_MAN (AT91_CAST(AT91_REG *) 	0xFFFC4034) 
+#define AT91C_EMACB_RJA (AT91_CAST(AT91_REG *) 	0xFFFC407C) 
+#define AT91C_EMACB_SA4L (AT91_CAST(AT91_REG *) 	0xFFFC40B0) 
+#define AT91C_EMACB_CSE (AT91_CAST(AT91_REG *) 	0xFFFC4068) 
+#define AT91C_EMACB_HRB (AT91_CAST(AT91_REG *) 	0xFFFC4090) 
+#define AT91C_EMACB_ALE (AT91_CAST(AT91_REG *) 	0xFFFC4054) 
+#define AT91C_EMACB_SA1L (AT91_CAST(AT91_REG *) 	0xFFFC4098) 
+#define AT91C_EMACB_NCR (AT91_CAST(AT91_REG *) 	0xFFFC4000) 
+#define AT91C_EMACB_FTO (AT91_CAST(AT91_REG *) 	0xFFFC4040) 
+#define AT91C_EMACB_ECOL (AT91_CAST(AT91_REG *) 	0xFFFC4060) 
+#define AT91C_EMACB_DTF (AT91_CAST(AT91_REG *) 	0xFFFC4058) 
+#define AT91C_EMACB_SA4H (AT91_CAST(AT91_REG *) 	0xFFFC40B4) 
+#define AT91C_EMACB_FCSE (AT91_CAST(AT91_REG *) 	0xFFFC4050) 
+#define AT91C_EMACB_TID (AT91_CAST(AT91_REG *) 	0xFFFC40B8) 
+#define AT91C_EMACB_PFR (AT91_CAST(AT91_REG *) 	0xFFFC403C) 
+#define AT91C_EMACB_IDR (AT91_CAST(AT91_REG *) 	0xFFFC402C) 
+#define AT91C_EMACB_SA3H (AT91_CAST(AT91_REG *) 	0xFFFC40AC) 
+#define AT91C_EMACB_NSR (AT91_CAST(AT91_REG *) 	0xFFFC4008) 
+#define AT91C_EMACB_MCF (AT91_CAST(AT91_REG *) 	0xFFFC4048) 
+#define AT91C_EMACB_RBQP (AT91_CAST(AT91_REG *) 	0xFFFC4018) 
+#define AT91C_EMACB_RSR (AT91_CAST(AT91_REG *) 	0xFFFC4020) 
+#define AT91C_EMACB_SA2H (AT91_CAST(AT91_REG *) 	0xFFFC40A4) 
+#define AT91C_EMACB_NCFGR (AT91_CAST(AT91_REG *) 	0xFFFC4004) 
+#define AT91C_EMACB_LCOL (AT91_CAST(AT91_REG *) 	0xFFFC405C) 
+
+#define AT91C_UDP_GLBSTATE (AT91_CAST(AT91_REG *) 	0xFFFA4004) 
+#define AT91C_UDP_FDR   (AT91_CAST(AT91_REG *) 	0xFFFA4050) 
+#define AT91C_UDP_RSTEP (AT91_CAST(AT91_REG *) 	0xFFFA4028) 
+#define AT91C_UDP_FADDR (AT91_CAST(AT91_REG *) 	0xFFFA4008) 
+#define AT91C_UDP_NUM   (AT91_CAST(AT91_REG *) 	0xFFFA4000) 
+#define AT91C_UDP_IDR   (AT91_CAST(AT91_REG *) 	0xFFFA4014) 
+#define AT91C_UDP_IMR   (AT91_CAST(AT91_REG *) 	0xFFFA4018) 
+#define AT91C_UDP_CSR   (AT91_CAST(AT91_REG *) 	0xFFFA4030) 
+#define AT91C_UDP_IER   (AT91_CAST(AT91_REG *) 	0xFFFA4010) 
+#define AT91C_UDP_ICR   (AT91_CAST(AT91_REG *) 	0xFFFA4020) 
+#define AT91C_UDP_TXVC  (AT91_CAST(AT91_REG *) 	0xFFFA4074) 
+#define AT91C_UDP_ISR   (AT91_CAST(AT91_REG *) 	0xFFFA401C) 
+
+#define AT91C_UHP_HcInterruptStatus (AT91_CAST(AT91_REG *) 	0x0050000C) 
+#define AT91C_UHP_HcCommandStatus (AT91_CAST(AT91_REG *) 	0x00500008) 
+#define AT91C_UHP_HcRhStatus (AT91_CAST(AT91_REG *) 	0x00500050) 
+#define AT91C_UHP_HcInterruptDisable (AT91_CAST(AT91_REG *) 	0x00500014) 
+#define AT91C_UHP_HcPeriodicStart (AT91_CAST(AT91_REG *) 	0x00500040) 
+#define AT91C_UHP_HcControlCurrentED (AT91_CAST(AT91_REG *) 	0x00500024) 
+#define AT91C_UHP_HcPeriodCurrentED (AT91_CAST(AT91_REG *) 	0x0050001C) 
+#define AT91C_UHP_HcBulkHeadED (AT91_CAST(AT91_REG *) 	0x00500028) 
+#define AT91C_UHP_HcRevision (AT91_CAST(AT91_REG *) 	0x00500000) 
+#define AT91C_UHP_HcBulkCurrentED (AT91_CAST(AT91_REG *) 	0x0050002C) 
+#define AT91C_UHP_HcRhDescriptorB (AT91_CAST(AT91_REG *) 	0x0050004C) 
+#define AT91C_UHP_HcControlHeadED (AT91_CAST(AT91_REG *) 	0x00500020) 
+#define AT91C_UHP_HcFmRemaining (AT91_CAST(AT91_REG *) 	0x00500038) 
+#define AT91C_UHP_HcHCCA (AT91_CAST(AT91_REG *) 	0x00500018) 
+#define AT91C_UHP_HcLSThreshold (AT91_CAST(AT91_REG *) 	0x00500044) 
+#define AT91C_UHP_HcRhPortStatus (AT91_CAST(AT91_REG *) 	0x00500054) 
+#define AT91C_UHP_HcInterruptEnable (AT91_CAST(AT91_REG *) 	0x00500010) 
+#define AT91C_UHP_HcFmNumber (AT91_CAST(AT91_REG *) 	0x0050003C) 
+#define AT91C_UHP_HcFmInterval (AT91_CAST(AT91_REG *) 	0x00500034) 
+#define AT91C_UHP_HcControl (AT91_CAST(AT91_REG *) 	0x00500004) 
+#define AT91C_UHP_HcBulkDoneHead (AT91_CAST(AT91_REG *) 	0x00500030) 
+#define AT91C_UHP_HcRhDescriptorA (AT91_CAST(AT91_REG *) 	0x00500048) 
+
+
+#define AT91C_HISI_PSIZE (AT91_CAST(AT91_REG *) 	0xFFFC0020) 
+#define AT91C_HISI_CR1  (AT91_CAST(AT91_REG *) 	0xFFFC0000) 
+#define AT91C_HISI_R2YSET1 (AT91_CAST(AT91_REG *) 	0xFFFC003C) 
+#define AT91C_HISI_CDBA (AT91_CAST(AT91_REG *) 	0xFFFC002C) 
+#define AT91C_HISI_IDR  (AT91_CAST(AT91_REG *) 	0xFFFC0010) 
+#define AT91C_HISI_R2YSET2 (AT91_CAST(AT91_REG *) 	0xFFFC0040) 
+#define AT91C_HISI_Y2RSET1 (AT91_CAST(AT91_REG *) 	0xFFFC0034) 
+#define AT91C_HISI_PFBD (AT91_CAST(AT91_REG *) 	0xFFFC0028) 
+#define AT91C_HISI_CR2  (AT91_CAST(AT91_REG *) 	0xFFFC0004) 
+#define AT91C_HISI_Y2RSET0 (AT91_CAST(AT91_REG *) 	0xFFFC0030) 
+#define AT91C_HISI_PDECF (AT91_CAST(AT91_REG *) 	0xFFFC0024) 
+#define AT91C_HISI_IMR  (AT91_CAST(AT91_REG *) 	0xFFFC0014) 
+#define AT91C_HISI_IER  (AT91_CAST(AT91_REG *) 	0xFFFC000C) 
+#define AT91C_HISI_R2YSET0 (AT91_CAST(AT91_REG *) 	0xFFFC0038) 
+#define AT91C_HISI_SR   (AT91_CAST(AT91_REG *) 	0xFFFC0008) 
+
+#define AT91C_PIO_PA0        (1 <<  0) 
+#define AT91C_PA0_SPI0_MISO (AT91C_PIO_PA0) 
+#define AT91C_PA0_MCDB0    (AT91C_PIO_PA0) 
+#define AT91C_PIO_PA1        (1 <<  1) 
+#define AT91C_PA1_SPI0_MOSI (AT91C_PIO_PA1) 
+#define AT91C_PA1_MCCDB    (AT91C_PIO_PA1) 
+#define AT91C_PIO_PA10       (1 << 10) 
+#define AT91C_PA10_MCI_DA2  (AT91C_PIO_PA10) 
+#define AT91C_PA10_ETX2_0   (AT91C_PIO_PA10) 
+#define AT91C_PIO_PA11       (1 << 11) 
+#define AT91C_PA11_MCI_DA3  (AT91C_PIO_PA11) 
+#define AT91C_PA11_ETX3_0   (AT91C_PIO_PA11) 
+#define AT91C_PIO_PA12       (1 << 12) 
+#define AT91C_PA12_ETX0     (AT91C_PIO_PA12) 
+#define AT91C_PIO_PA13       (1 << 13) 
+#define AT91C_PA13_ETX1     (AT91C_PIO_PA13) 
+#define AT91C_PIO_PA14       (1 << 14) 
+#define AT91C_PA14_ERX0     (AT91C_PIO_PA14) 
+#define AT91C_PIO_PA15       (1 << 15) 
+#define AT91C_PA15_ERX1     (AT91C_PIO_PA15) 
+#define AT91C_PIO_PA16       (1 << 16) 
+#define AT91C_PA16_ETXEN    (AT91C_PIO_PA16) 
+#define AT91C_PIO_PA17       (1 << 17) 
+#define AT91C_PA17_ERXDV    (AT91C_PIO_PA17) 
+#define AT91C_PIO_PA18       (1 << 18) 
+#define AT91C_PA18_ERXER    (AT91C_PIO_PA18) 
+#define AT91C_PIO_PA19       (1 << 19) 
+#define AT91C_PA19_ETXCK    (AT91C_PIO_PA19) 
+#define AT91C_PIO_PA2        (1 <<  2) 
+#define AT91C_PA2_SPI0_SPCK (AT91C_PIO_PA2) 
+#define AT91C_PIO_PA20       (1 << 20) 
+#define AT91C_PA20_EMDC     (AT91C_PIO_PA20) 
+#define AT91C_PIO_PA21       (1 << 21) 
+#define AT91C_PA21_EMDIO    (AT91C_PIO_PA21) 
+#define AT91C_PIO_PA22       (1 << 22) 
+#define AT91C_PA22_ADTRG    (AT91C_PIO_PA22) 
+#define AT91C_PA22_ETXER    (AT91C_PIO_PA22) 
+#define AT91C_PIO_PA23       (1 << 23) 
+#define AT91C_PA23_TWD      (AT91C_PIO_PA23) 
+#define AT91C_PA23_ETX2_1   (AT91C_PIO_PA23) 
+#define AT91C_PIO_PA24       (1 << 24) 
+#define AT91C_PA24_TWCK     (AT91C_PIO_PA24) 
+#define AT91C_PA24_ETX3_1   (AT91C_PIO_PA24) 
+#define AT91C_PIO_PA25       (1 << 25) 
+#define AT91C_PA25_TCLK0    (AT91C_PIO_PA25) 
+#define AT91C_PA25_ERX2     (AT91C_PIO_PA25) 
+#define AT91C_PIO_PA26       (1 << 26) 
+#define AT91C_PA26_TIOA0    (AT91C_PIO_PA26) 
+#define AT91C_PA26_ERX3     (AT91C_PIO_PA26) 
+#define AT91C_PIO_PA27       (1 << 27) 
+#define AT91C_PA27_TIOA1    (AT91C_PIO_PA27) 
+#define AT91C_PA27_ERXCK    (AT91C_PIO_PA27) 
+#define AT91C_PIO_PA28       (1 << 28) 
+#define AT91C_PA28_TIOA2    (AT91C_PIO_PA28) 
+#define AT91C_PA28_ECRS     (AT91C_PIO_PA28) 
+#define AT91C_PIO_PA29       (1 << 29) 
+#define AT91C_PA29_SCK1     (AT91C_PIO_PA29) 
+#define AT91C_PA29_ECOL     (AT91C_PIO_PA29) 
+#define AT91C_PIO_PA3        (1 <<  3) 
+#define AT91C_PA3_SPI0_NPCS0 (AT91C_PIO_PA3) 
+#define AT91C_PA3_MCDB3    (AT91C_PIO_PA3) 
+#define AT91C_PIO_PA30       (1 << 30) 
+#define AT91C_PA30_SCK2     (AT91C_PIO_PA30) 
+#define AT91C_PA30_RXD4     (AT91C_PIO_PA30) 
+#define AT91C_PIO_PA31       (1 << 31) 
+#define AT91C_PA31_SCK0     (AT91C_PIO_PA31) 
+#define AT91C_PA31_TXD4     (AT91C_PIO_PA31) 
+#define AT91C_PIO_PA4        (1 <<  4) 
+#define AT91C_PA4_RTS2     (AT91C_PIO_PA4) 
+#define AT91C_PA4_MCDB2    (AT91C_PIO_PA4) 
+#define AT91C_PIO_PA5        (1 <<  5) 
+#define AT91C_PA5_CTS2     (AT91C_PIO_PA5) 
+#define AT91C_PA5_MCDB1    (AT91C_PIO_PA5) 
+#define AT91C_PIO_PA6        (1 <<  6) 
+#define AT91C_PA6_MCDA0    (AT91C_PIO_PA6) 
+#define AT91C_PIO_PA7        (1 <<  7) 
+#define AT91C_PA7_MCCDA    (AT91C_PIO_PA7) 
+#define AT91C_PIO_PA8        (1 <<  8) 
+#define AT91C_PA8_MCCK     (AT91C_PIO_PA8) 
+#define AT91C_PIO_PA9        (1 <<  9) 
+#define AT91C_PA9_MCDA1    (AT91C_PIO_PA9) 
+#define AT91C_PIO_PB0        (1 <<  0) 
+#define AT91C_PB0_SPI1_MISO (AT91C_PIO_PB0) 
+#define AT91C_PB0_TIOA3    (AT91C_PIO_PB0) 
+#define AT91C_PIO_PB1        (1 <<  1) 
+#define AT91C_PB1_SPI1_MOSI (AT91C_PIO_PB1) 
+#define AT91C_PB1_TIOB3    (AT91C_PIO_PB1) 
+#define AT91C_PIO_PB10       (1 << 10) 
+#define AT91C_PB10_TXD3     (AT91C_PIO_PB10) 
+#define AT91C_PB10_ISI_D8   (AT91C_PIO_PB10) 
+#define AT91C_PIO_PB11       (1 << 11) 
+#define AT91C_PB11_RXD3     (AT91C_PIO_PB11) 
+#define AT91C_PB11_ISI_D9   (AT91C_PIO_PB11) 
+#define AT91C_PIO_PB12       (1 << 12) 
+#define AT91C_PB12_TXD5     (AT91C_PIO_PB12) 
+#define AT91C_PB12_ISI_D10  (AT91C_PIO_PB12) 
+#define AT91C_PIO_PB13       (1 << 13) 
+#define AT91C_PB13_RXD5     (AT91C_PIO_PB13) 
+#define AT91C_PB13_ISI_D11  (AT91C_PIO_PB13) 
+#define AT91C_PIO_PB14       (1 << 14) 
+#define AT91C_PB14_DRXD     (AT91C_PIO_PB14) 
+#define AT91C_PIO_PB15       (1 << 15) 
+#define AT91C_PB15_DTXD     (AT91C_PIO_PB15) 
+#define AT91C_PIO_PB16       (1 << 16) 
+#define AT91C_PB16_TK0      (AT91C_PIO_PB16) 
+#define AT91C_PB16_TCLK3    (AT91C_PIO_PB16) 
+#define AT91C_PIO_PB17       (1 << 17) 
+#define AT91C_PB17_TF0      (AT91C_PIO_PB17) 
+#define AT91C_PB17_TCLK4    (AT91C_PIO_PB17) 
+#define AT91C_PIO_PB18       (1 << 18) 
+#define AT91C_PB18_TD0      (AT91C_PIO_PB18) 
+#define AT91C_PB18_TIOB4    (AT91C_PIO_PB18) 
+#define AT91C_PIO_PB19       (1 << 19) 
+#define AT91C_PB19_RD0      (AT91C_PIO_PB19) 
+#define AT91C_PB19_TIOB5    (AT91C_PIO_PB19) 
+#define AT91C_PIO_PB2        (1 <<  2) 
+#define AT91C_PB2_SPI1_SPCK (AT91C_PIO_PB2) 
+#define AT91C_PB2_TIOA4    (AT91C_PIO_PB2) 
+#define AT91C_PIO_PB20       (1 << 20) 
+#define AT91C_PB20_RK0      (AT91C_PIO_PB20) 
+#define AT91C_PB20_ISI_D0   (AT91C_PIO_PB20) 
+#define AT91C_PIO_PB21       (1 << 21) 
+#define AT91C_PB21_RF0      (AT91C_PIO_PB21) 
+#define AT91C_PB21_ISI_D1   (AT91C_PIO_PB21) 
+#define AT91C_PIO_PB22       (1 << 22) 
+#define AT91C_PB22_DSR0     (AT91C_PIO_PB22) 
+#define AT91C_PB22_ISI_D2   (AT91C_PIO_PB22) 
+#define AT91C_PIO_PB23       (1 << 23) 
+#define AT91C_PB23_DCD0     (AT91C_PIO_PB23) 
+#define AT91C_PB23_ISI_D3   (AT91C_PIO_PB23) 
+#define AT91C_PIO_PB24       (1 << 24) 
+#define AT91C_PB24_DTR0     (AT91C_PIO_PB24) 
+#define AT91C_PB24_ISI_D4   (AT91C_PIO_PB24) 
+#define AT91C_PIO_PB25       (1 << 25) 
+#define AT91C_PB25_RI0      (AT91C_PIO_PB25) 
+#define AT91C_PB25_ISI_D5   (AT91C_PIO_PB25) 
+#define AT91C_PIO_PB26       (1 << 26) 
+#define AT91C_PB26_RTS0     (AT91C_PIO_PB26) 
+#define AT91C_PB26_ISI_D6   (AT91C_PIO_PB26) 
+#define AT91C_PIO_PB27       (1 << 27) 
+#define AT91C_PB27_CTS0     (AT91C_PIO_PB27) 
+#define AT91C_PB27_ISI_D7   (AT91C_PIO_PB27) 
+#define AT91C_PIO_PB28       (1 << 28) 
+#define AT91C_PB28_RTS1     (AT91C_PIO_PB28) 
+#define AT91C_PB28_ISI_PCK  (AT91C_PIO_PB28) 
+#define AT91C_PIO_PB29       (1 << 29) 
+#define AT91C_PB29_CTS1     (AT91C_PIO_PB29) 
+#define AT91C_PB29_ISI_VSYNC (AT91C_PIO_PB29) 
+#define AT91C_PIO_PB3        (1 <<  3) 
+#define AT91C_PB3_SPI1_NPCS0 (AT91C_PIO_PB3) 
+#define AT91C_PB3_TIOA5    (AT91C_PIO_PB3) 
+#define AT91C_PIO_PB30       (1 << 30) 
+#define AT91C_PB30_PCK0_0   (AT91C_PIO_PB30) 
+#define AT91C_PB30_ISI_HSYNC (AT91C_PIO_PB30) 
+#define AT91C_PIO_PB31       (1 << 31) 
+#define AT91C_PB31_PCK1_0   (AT91C_PIO_PB31) 
+#define AT91C_PB31_ISI_MCK  (AT91C_PIO_PB31) 
+#define AT91C_PIO_PB4        (1 <<  4) 
+#define AT91C_PB4_TXD0     (AT91C_PIO_PB4) 
+#define AT91C_PIO_PB5        (1 <<  5) 
+#define AT91C_PB5_RXD0     (AT91C_PIO_PB5) 
+#define AT91C_PIO_PB6        (1 <<  6) 
+#define AT91C_PB6_TXD1     (AT91C_PIO_PB6) 
+#define AT91C_PB6_TCLK1    (AT91C_PIO_PB6) 
+#define AT91C_PIO_PB7        (1 <<  7) 
+#define AT91C_PB7_RXD1     (AT91C_PIO_PB7) 
+#define AT91C_PB7_TCLK2    (AT91C_PIO_PB7) 
+#define AT91C_PIO_PB8        (1 <<  8) 
+#define AT91C_PB8_TXD2     (AT91C_PIO_PB8) 
+#define AT91C_PIO_PB9        (1 <<  9) 
+#define AT91C_PB9_RXD2     (AT91C_PIO_PB9) 
+#define AT91C_PIO_PC0        (1 <<  0) 
+#define AT91C_PC0_AD0      (AT91C_PIO_PC0) 
+#define AT91C_PC0_SCK3     (AT91C_PIO_PC0) 
+#define AT91C_PIO_PC1        (1 <<  1) 
+#define AT91C_PC1_AD1      (AT91C_PIO_PC1) 
+#define AT91C_PC1_PCK0_1   (AT91C_PIO_PC1) 
+#define AT91C_PIO_PC10       (1 << 10) 
+#define AT91C_PC10_A25_CFRNW (AT91C_PIO_PC10) 
+#define AT91C_PC10_CTS3     (AT91C_PIO_PC10) 
+#define AT91C_PIO_PC11       (1 << 11) 
+#define AT91C_PC11_NCS2     (AT91C_PIO_PC11) 
+#define AT91C_PC11_SPI0_NPCS1 (AT91C_PIO_PC11) 
+#define AT91C_PIO_PC12       (1 << 12) 
+#define AT91C_PC12_IRQ0     (AT91C_PIO_PC12) 
+#define AT91C_PC12_NCS7     (AT91C_PIO_PC12) 
+#define AT91C_PIO_PC13       (1 << 13) 
+#define AT91C_PC13_FIQ      (AT91C_PIO_PC13) 
+#define AT91C_PC13_NCS6     (AT91C_PIO_PC13) 
+#define AT91C_PIO_PC14       (1 << 14) 
+#define AT91C_PC14_NCS3_NANDCS (AT91C_PIO_PC14) 
+#define AT91C_PC14_IRQ2     (AT91C_PIO_PC14) 
+#define AT91C_PIO_PC15       (1 << 15) 
+#define AT91C_PC15_NWAIT    (AT91C_PIO_PC15) 
+#define AT91C_PC15_IRQ1     (AT91C_PIO_PC15) 
+#define AT91C_PIO_PC16       (1 << 16) 
+#define AT91C_PC16_D16      (AT91C_PIO_PC16) 
+#define AT91C_PC16_SPI0_NPCS2 (AT91C_PIO_PC16) 
+#define AT91C_PIO_PC17       (1 << 17) 
+#define AT91C_PC17_D17      (AT91C_PIO_PC17) 
+#define AT91C_PC17_SPI0_NPCS3 (AT91C_PIO_PC17) 
+#define AT91C_PIO_PC18       (1 << 18) 
+#define AT91C_PC18_D18      (AT91C_PIO_PC18) 
+#define AT91C_PC18_SPI1_NPCS1_1 (AT91C_PIO_PC18) 
+#define AT91C_PIO_PC19       (1 << 19) 
+#define AT91C_PC19_D19      (AT91C_PIO_PC19) 
+#define AT91C_PC19_SPI1_NPCS2_1 (AT91C_PIO_PC19) 
+#define AT91C_PIO_PC2        (1 <<  2) 
+#define AT91C_PC2_AD2      (AT91C_PIO_PC2) 
+#define AT91C_PC2_PCK1_1   (AT91C_PIO_PC2) 
+#define AT91C_PIO_PC20       (1 << 20) 
+#define AT91C_PC20_D20      (AT91C_PIO_PC20) 
+#define AT91C_PC20_SPI1_NPCS3_1 (AT91C_PIO_PC20) 
+#define AT91C_PIO_PC21       (1 << 21) 
+#define AT91C_PC21_D21      (AT91C_PIO_PC21) 
+#define AT91C_PC21_EF100    (AT91C_PIO_PC21) 
+#define AT91C_PIO_PC22       (1 << 22) 
+#define AT91C_PC22_D22      (AT91C_PIO_PC22) 
+#define AT91C_PC22_TCLK5    (AT91C_PIO_PC22) 
+#define AT91C_PIO_PC23       (1 << 23) 
+#define AT91C_PC23_D23      (AT91C_PIO_PC23) 
+#define AT91C_PIO_PC24       (1 << 24) 
+#define AT91C_PC24_D24      (AT91C_PIO_PC24) 
+#define AT91C_PIO_PC25       (1 << 25) 
+#define AT91C_PC25_D25      (AT91C_PIO_PC25) 
+#define AT91C_PIO_PC26       (1 << 26) 
+#define AT91C_PC26_D26      (AT91C_PIO_PC26) 
+#define AT91C_PIO_PC27       (1 << 27) 
+#define AT91C_PC27_D27      (AT91C_PIO_PC27) 
+#define AT91C_PIO_PC28       (1 << 28) 
+#define AT91C_PC28_D28      (AT91C_PIO_PC28) 
+#define AT91C_PIO_PC29       (1 << 29) 
+#define AT91C_PC29_D29      (AT91C_PIO_PC29) 
+#define AT91C_PIO_PC3        (1 <<  3) 
+#define AT91C_PC3_AD3      (AT91C_PIO_PC3) 
+#define AT91C_PC3_SPI1_NPCS3_0 (AT91C_PIO_PC3) 
+#define AT91C_PIO_PC30       (1 << 30) 
+#define AT91C_PC30_D30      (AT91C_PIO_PC30) 
+#define AT91C_PIO_PC31       (1 << 31) 
+#define AT91C_PC31_D31      (AT91C_PIO_PC31) 
+#define AT91C_PIO_PC4        (1 <<  4) 
+#define AT91C_PC4_A23      (AT91C_PIO_PC4) 
+#define AT91C_PC4_SPI1_NPCS2_0 (AT91C_PIO_PC4) 
+#define AT91C_PIO_PC5        (1 <<  5) 
+#define AT91C_PC5_A24      (AT91C_PIO_PC5) 
+#define AT91C_PC5_SPI1_NPCS1_0 (AT91C_PIO_PC5) 
+#define AT91C_PIO_PC6        (1 <<  6) 
+#define AT91C_PC6_TIOB2    (AT91C_PIO_PC6) 
+#define AT91C_PC6_CFCE1    (AT91C_PIO_PC6) 
+#define AT91C_PIO_PC7        (1 <<  7) 
+#define AT91C_PC7_TIOB1    (AT91C_PIO_PC7) 
+#define AT91C_PC7_CFCE2    (AT91C_PIO_PC7) 
+#define AT91C_PIO_PC8        (1 <<  8) 
+#define AT91C_PC8_NCS4_CFCS0 (AT91C_PIO_PC8) 
+#define AT91C_PC8_RTS3     (AT91C_PIO_PC8) 
+#define AT91C_PIO_PC9        (1 <<  9) 
+#define AT91C_PC9_NCS5_CFCS1 (AT91C_PIO_PC9) 
+#define AT91C_PC9_TIOB0    (AT91C_PIO_PC9) 
+
+#define AT91C_ID_FIQ    ( 0) 
+#define AT91C_ID_SYS    ( 1) 
+#define AT91C_ID_PIOA   ( 2) 
+#define AT91C_ID_PIOB   ( 3) 
+#define AT91C_ID_PIOC   ( 4) 
+#define AT91C_ID_ADC    ( 5) 
+#define AT91C_ID_US0    ( 6) 
+#define AT91C_ID_US1    ( 7) 
+#define AT91C_ID_US2    ( 8) 
+#define AT91C_ID_MCI    ( 9) 
+#define AT91C_ID_UDP    (10) 
+#define AT91C_ID_TWI    (11) 
+#define AT91C_ID_SPI0   (12) 
+#define AT91C_ID_SPI1   (13) 
+#define AT91C_ID_SSC0   (14) 
+#define AT91C_ID_TC0    (17) 
+#define AT91C_ID_TC1    (18) 
+#define AT91C_ID_TC2    (19) 
+#define AT91C_ID_UHP    (20) 
+#define AT91C_ID_EMAC   (21) 
+#define AT91C_ID_HISI   (22) 
+#define AT91C_ID_US3    (23) 
+#define AT91C_ID_US4    (24) 
+#define AT91C_ID_US5    (25) 
+#define AT91C_ID_TC3    (26) 
+#define AT91C_ID_TC4    (27) 
+#define AT91C_ID_TC5    (28) 
+#define AT91C_ID_IRQ0   (29) 
+#define AT91C_ID_IRQ1   (30) 
+#define AT91C_ID_IRQ2   (31) 
+#define AT91C_ALL_INT   (0xFFFE7FFF) 
+
+#define AT91C_BASE_SYS       (AT91_CAST(AT91PS_SYS) 	0xFFFFFD00) 
+#define AT91C_BASE_EBI       (AT91_CAST(AT91PS_EBI) 	0xFFFFEA00) 
+#define AT91C_BASE_HECC      (AT91_CAST(AT91PS_ECC) 	0xFFFFE800) 
+#define AT91C_BASE_SDRAMC    (AT91_CAST(AT91PS_SDRAMC) 	0xFFFFEA00) 
+#define AT91C_BASE_SMC       (AT91_CAST(AT91PS_SMC) 	0xFFFFEC00) 
+#define AT91C_BASE_MATRIX    (AT91_CAST(AT91PS_MATRIX) 	0xFFFFEE00) 
+#define AT91C_BASE_CCFG      (AT91_CAST(AT91PS_CCFG) 	0xFFFFEF10) 
+#define AT91C_BASE_PDC_DBGU  (AT91_CAST(AT91PS_PDC) 	0xFFFFF300) 
+#define AT91C_BASE_DBGU      (AT91_CAST(AT91PS_DBGU) 	0xFFFFF200) 
+#define AT91C_BASE_AIC       (AT91_CAST(AT91PS_AIC) 	0xFFFFF000) 
+#define AT91C_BASE_PIOA      (AT91_CAST(AT91PS_PIO) 	0xFFFFF400) 
+#define AT91C_BASE_PIOB      (AT91_CAST(AT91PS_PIO) 	0xFFFFF600) 
+#define AT91C_BASE_PIOC      (AT91_CAST(AT91PS_PIO) 	0xFFFFF800) 
+#define AT91C_BASE_CKGR      (AT91_CAST(AT91PS_CKGR) 	0xFFFFFC20) 
+#define AT91C_BASE_PMC       (AT91_CAST(AT91PS_PMC) 	0xFFFFFC00) 
+#define AT91C_BASE_RSTC      (AT91_CAST(AT91PS_RSTC) 	0xFFFFFD00) 
+#define AT91C_BASE_SHDWC     (AT91_CAST(AT91PS_SHDWC) 	0xFFFFFD10) 
+#define AT91C_BASE_RTTC      (AT91_CAST(AT91PS_RTTC) 	0xFFFFFD20) 
+#define AT91C_BASE_PITC      (AT91_CAST(AT91PS_PITC) 	0xFFFFFD30) 
+#define AT91C_BASE_WDTC      (AT91_CAST(AT91PS_WDTC) 	0xFFFFFD40) 
+#define AT91C_BASE_TC0       (AT91_CAST(AT91PS_TC) 	0xFFFA0000) 
+#define AT91C_BASE_TC1       (AT91_CAST(AT91PS_TC) 	0xFFFA0040) 
+#define AT91C_BASE_TC2       (AT91_CAST(AT91PS_TC) 	0xFFFA0080) 
+#define AT91C_BASE_TC3       (AT91_CAST(AT91PS_TC) 	0xFFFDC000) 
+#define AT91C_BASE_TC4       (AT91_CAST(AT91PS_TC) 	0xFFFDC040) 
+#define AT91C_BASE_TC5       (AT91_CAST(AT91PS_TC) 	0xFFFDC080) 
+#define AT91C_BASE_TCB0      (AT91_CAST(AT91PS_TCB) 	0xFFFA0000) 
+#define AT91C_BASE_TCB1      (AT91_CAST(AT91PS_TCB) 	0xFFFDC000) 
+#define AT91C_BASE_PDC_MCI   (AT91_CAST(AT91PS_PDC) 	0xFFFA8100) 
+#define AT91C_BASE_MCI       (AT91_CAST(AT91PS_MCI) 	0xFFFA8000) 
+#define AT91C_BASE_PDC_TWI   (AT91_CAST(AT91PS_PDC) 	0xFFFAC100) 
+#define AT91C_BASE_TWI       (AT91_CAST(AT91PS_TWI) 	0xFFFAC000) 
+#define AT91C_BASE_PDC_US0   (AT91_CAST(AT91PS_PDC) 	0xFFFB0100) 
+#define AT91C_BASE_US0       (AT91_CAST(AT91PS_USART) 	0xFFFB0000) 
+#define AT91C_BASE_PDC_US1   (AT91_CAST(AT91PS_PDC) 	0xFFFB4100) 
+#define AT91C_BASE_US1       (AT91_CAST(AT91PS_USART) 	0xFFFB4000) 
+#define AT91C_BASE_PDC_US2   (AT91_CAST(AT91PS_PDC) 	0xFFFB8100) 
+#define AT91C_BASE_US2       (AT91_CAST(AT91PS_USART) 	0xFFFB8000) 
+#define AT91C_BASE_PDC_US3   (AT91_CAST(AT91PS_PDC) 	0xFFFD0100) 
+#define AT91C_BASE_US3       (AT91_CAST(AT91PS_USART) 	0xFFFD0000) 
+#define AT91C_BASE_PDC_US4   (AT91_CAST(AT91PS_PDC) 	0xFFFD4100) 
+#define AT91C_BASE_US4       (AT91_CAST(AT91PS_USART) 	0xFFFD4000) 
+#define AT91C_BASE_PDC_US5   (AT91_CAST(AT91PS_PDC) 	0xFFFD8100) 
+#define AT91C_BASE_US5       (AT91_CAST(AT91PS_USART) 	0xFFFD8000) 
+#define AT91C_BASE_PDC_SSC0  (AT91_CAST(AT91PS_PDC) 	0xFFFBC100) 
+#define AT91C_BASE_SSC0      (AT91_CAST(AT91PS_SSC) 	0xFFFBC000) 
+#define AT91C_BASE_PDC_SPI0  (AT91_CAST(AT91PS_PDC) 	0xFFFC8100) 
+#define AT91C_BASE_SPI0      (AT91_CAST(AT91PS_SPI) 	0xFFFC8000) 
+#define AT91C_BASE_PDC_SPI1  (AT91_CAST(AT91PS_PDC) 	0xFFFCC100) 
+#define AT91C_BASE_SPI1      (AT91_CAST(AT91PS_SPI) 	0xFFFCC000) 
+#define AT91C_BASE_PDC_ADC   (AT91_CAST(AT91PS_PDC) 	0xFFFE0100) 
+#define AT91C_BASE_ADC       (AT91_CAST(AT91PS_ADC) 	0xFFFE0000) 
+#define AT91C_BASE_EMACB     (AT91_CAST(AT91PS_EMAC) 	0xFFFC4000) 
+#define AT91C_BASE_UDP       (AT91_CAST(AT91PS_UDP) 	0xFFFA4000) 
+#define AT91C_BASE_UHP       (AT91_CAST(AT91PS_UHP) 	0x00500000) 
+#define AT91C_BASE_HISI      (AT91_CAST(AT91PS_ISI) 	0xFFFC0000) 
+
+
+
+
+
+#define AT91C_IROM 	 (0x00100000) 
+#define AT91C_IROM_SIZE	 (0x00008000) 
+
+#define AT91C_IRAM_1	 (0x00200000) 
+#define AT91C_IRAM_1_SIZE	 (0x00001000) 
+
+#define AT91C_IRAM_2	 (0x00300000) 
+#define AT91C_IRAM_2_SIZE	 (0x00001000) 
+
+#define AT91C_IRAM_MIN	 (0x00300000) 
+#define AT91C_IRAM_MIN_SIZE	 (0x00001000) 
+
+#define AT91C_EBI_CS0	 (0x10000000) 
+#define AT91C_EBI_CS0_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS1	 (0x20000000) 
+#define AT91C_EBI_CS1_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_SDRAM	 (0x20000000) 
+#define AT91C_EBI_SDRAM_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_SDRAM_16BIT	 (0x20000000) 
+#define AT91C_EBI_SDRAM_16BIT_SIZE	 (0x02000000) 
+
+#define AT91C_EBI_SDRAM_32BIT	 (0x20000000) 
+#define AT91C_EBI_SDRAM_32BIT_SIZE	 (0x04000000) 
+
+#define AT91C_EBI_CS2	 (0x30000000) 
+#define AT91C_EBI_CS2_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS3	 (0x40000000) 
+#define AT91C_EBI_CS3_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_SM	 (0x40000000) 
+#define AT91C_EBI_SM_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS4	 (0x50000000) 
+#define AT91C_EBI_CS4_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CF0	 (0x50000000) 
+#define AT91C_EBI_CF0_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS5	 (0x60000000) 
+#define AT91C_EBI_CS5_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CF1	 (0x60000000) 
+#define AT91C_EBI_CF1_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS6	 (0x70000000) 
+#define AT91C_EBI_CS6_SIZE	 (0x10000000) 
+
+#define AT91C_EBI_CS7	 (0x80000000) 
+#define AT91C_EBI_CS7_SIZE	 (0x10000000) 
+
+#endif
+
+
 /*
  * Peripheral identifiers/interrupts.
  */
@@ -115,6 +3861,3 @@
 
 #define AT91SAM9XE_FLASH_BASE	0x00200000	/* Internal FLASH base address */
 #define AT91SAM9XE_SRAM_BASE	0x00300000	/* Internal SRAM base address */
-
-
-#endif
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/board.h linux-2.6.22_9260/include/asm-arm/arch-at91/board.h
--- linux-2.6.22/include/asm-arm/arch-at91/board.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/board.h	2014-08-26 16:23:12.701379873 +0800
@@ -118,15 +118,34 @@
 struct atmel_lcdfb_info;
 extern void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data);
 
+ /* SSC + AT73C213 */
+struct atmel_at73c213_data {
+	struct clk *at73_mck; 	// MCK AT73C213 clock   
+	unsigned int ssc_div;   // ssc divisor
+};
+extern void __init at91_add_device_ssc_at71c213(void);
+
  /* AC97 */
 struct atmel_ac97_data {
 	u8		reset_pin;	/* reset */
 };
 extern void __init at91_add_device_ac97(struct atmel_ac97_data *data);
 
+ /* ISI */
+extern void __init at91_add_device_isi(void);
+
  /* LEDs */
 extern u8 at91_leds_cpu;
 extern u8 at91_leds_timer;
 extern void __init at91_init_leds(u8 cpu_led, u8 timer_led);
 
+struct at91_gpio_led {
+	u8		index;		/* index of LED */
+	char*		name;		/* name of LED */
+	u8		gpio;		/* AT91_PIN_xx */
+	u8		flags;		/* 1=active-high */
+	char*		trigger;	/* default trigger */
+};
+extern void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr);
+
 #endif
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/ics1523.h linux-2.6.22_9260/include/asm-arm/arch-at91/ics1523.h
--- linux-2.6.22/include/asm-arm/arch-at91/ics1523.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/ics1523.h	2014-08-26 16:22:54.379396866 +0800
@@ -0,0 +1,154 @@
+//*----------------------------------------------------------------------------
+//*         ATMEL Microcontroller Software Support  -  ROUSSET  -
+//*----------------------------------------------------------------------------
+//* The software is delivered "AS IS" without warranty or condition of any
+//* kind, either express, implied or statutory. This includes without
+//* limitation any warranty or condition with respect to merchantability or
+//* fitness for any particular purpose, or against the infringements of
+//* intellectual property rights of others.
+//*----------------------------------------------------------------------------
+//* File Name           : ics1523.h
+//* Object              : Clock Generator Prototyping File.
+//*
+//* 1.0 08/28/02 ED     : Creation
+//* 1.2 13/01/03 FB		: Update on lib V3
+//*----------------------------------------------------------------------------
+
+#ifndef ics1523_h
+#define ics1523_h
+
+/*-------------------------------------------*/
+/* ICS1523 TWI Serial Clock Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_MIN_CLOCK		100		/* Min Frequency Access Clock KHz */
+#define		ICS_MAX_CLOCK		400		/* Max Frequency Access Clock KHz */
+#define		ICS_TRANSFER_RATE	ICS_MAX_CLOCK	/* Transfer speed to apply */
+
+#define		ICS_WRITE_CLK_PNB	30		/* TWCK Clock Periods required to write */
+#define		ICS_READ_CLK_PNB	40		/* TWCK Clock Periods required to read */
+
+/*-------------------------------------------*/
+/* ICS1523 Write Operation Definition        */
+/*-------------------------------------------*/
+
+#define		ICS1523_ACCESS_OK	0		/* OK */
+#define		ICS1523_ACCESS_ERROR	-1		/* NOK */
+
+/*-------------------------------------------*/
+/* ICS1523 Device Addresses Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_ADDR		0x26		/* Device Address */
+
+/*--------------------------------------------------*/
+/* ICS1523 Registers Internal Addresses Definition  */
+/*--------------------------------------------------*/
+
+#define		ICS_ICR			0x0		/* Input Control Register */
+#define		ICS_LCR			0x1		/* Loop Control Register */
+#define		ICS_FD0			0x2		/* PLL FeedBack Divider LSBs */
+#define		ICS_FD1			0x3		/* PLL FeedBack Divider MSBs */
+#define		ICS_DPAO		0x4		/* Dynamic Phase Aligner Offset */
+#define		ICS_DPAC		0x5		/* Dynamic Phase Aligner Resolution */
+#define		ICS_OE			0x6		/* Output Enables Register */
+#define		ICS_OD			0x7		/* Osc Divider Register */
+#define		ICS_SWRST		0x8		/* DPA & PLL Reset Register */
+#define		ICS_VID			0x10		/* Chip Version Register */
+#define		ICS_RID			0x11		/* Chip Revision Register */
+#define		ICS_SR			0x12		/* Status Register */
+
+/*------------------------------------------------------*/
+/* ICS1523 Input Control Register Bits Definition       */
+/*------------------------------------------------------*/
+
+#define		ICS_PDEN		0x1		/* Phase Detector Enable */
+#define		ICS_PDPOL		0x2		/* Phase Detector Enable Polarity */
+#define		ICS_REFPOL		0x4		/* External Reference Polarity */
+#define		ICS_FBKPOL		0x8		/* External Feedback Polarity */
+#define		ICS_FBKSEL		0x10		/* External Feedback Select */
+#define		ICS_FUNCSEL		0x20		/* Function Out Select */
+#define		ICS_ENPLS		0x40		/* Enable PLL Lock/Ref Status Output */
+#define		ICS_ENDLS		0x80		/* Enable DPA Lock/Ref Status Output */
+
+/*-----------------------------------------------------*/
+/* ICS1523 Loop Control Register Bits Definition       */
+/*-----------------------------------------------------*/
+
+#define		ICS_PFD			0x7		/* Phase Detector Gain */
+#define		ICS_PSD			0x30		/* Post-Scaler Divider */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider LSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDL		0xFF		/* PLL FeedBack Divider LSBs */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider MSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDM		0xF		/* PLL FeedBack Divider MSBs */
+
+/*------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Offset Bits Definition       */
+/*------------------------------------------------------------*/
+
+#define		ICS_DPAOS		0x2F		/* Dynamic Phase Aligner Offset */
+#define		ICS_FILSEL		0x80		/* Loop Filter Select */
+
+/*----------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Resolution Bits Definition       */
+/*----------------------------------------------------------------*/
+
+#define		ICS_DPARES		0x3		/* Dynamic Phase Aligner Resolution */
+#define		ICS_MMREV		0xFC		/* Metal Mask Revision Number */
+
+/*-------------------------------------------------------*/
+/* ICS1523 Output Enables Register Bits Definition       */
+/*-------------------------------------------------------*/
+
+#define		ICS_OEPCK		0x1		/* Output Enable for PECL PCLK Outputs */
+#define		ICS_OETCK		0x2		/* Output Enable for STTL CLK Output */
+#define		ICS_OEP2		0x4		/* Output Enable for PECL CLK/2 Outputs */
+#define		ICS_OET2		0x8		/* Output Enable for STTL CLK/2 Output */
+#define		ICS_OEF			0x10		/* Output Enable for STTL FUNC Output */
+#define		ICS_CLK2INV		0x20		/* CLK/2 Invert */
+#define		ICS_OSCL		0xC0		/* SSTL Clock Scaler */
+
+/*----------------------------------------------------*/
+/* ICS1523 Osc Divider Register Bits Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_OSCDIV		0x7F		/* Oscillator Divider Modulus */
+#define		ICS_INSEL		0x80		/* Input Select */
+
+/*---------------------------------------------------*/
+/* ICS1523 DPA & PLL Reset Register Definition       */
+/*---------------------------------------------------*/
+
+#define		ICS_DPAR		0x0A		/* DPA Reset Command */
+#define		ICS_PLLR		0x50		/* PLL Reset Command */
+
+/*------------------------------------------------*/
+/* ICS1523 Chip Version Register Definition       */
+/*------------------------------------------------*/
+
+#define		ICS_CHIPV		0xFF		/* Chip Version */
+
+/*-------------------------------------------------*/
+/* ICS1523 Chip Revision Register Definition       */
+/*-------------------------------------------------*/
+
+#define		ICS_CHIPR		0xFF		/* Chip Revision */
+
+/*------------------------------------------*/
+/* ICS1523 Status Register Definition       */
+/*------------------------------------------*/
+
+#define		ICS_DPALOCK		0x1		/* DPA Lock Status */
+#define		ICS_PLLLOCK		0x2		/* PLL Lock Status */
+
+int at91_ics1523_init(void);
+
+#endif /* ics1523_h */
diff -uNrbBw linux-2.6.22/include/asm-arm/arch-at91/spi.h linux-2.6.22_9260/include/asm-arm/arch-at91/spi.h
--- linux-2.6.22/include/asm-arm/arch-at91/spi.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/include/asm-arm/arch-at91/spi.h	2014-08-26 16:22:54.384529704 +0800
@@ -0,0 +1,54 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef AT91_LEGACY_SPI_H
+#define AT91_LEGACY_SPI_H
+
+#define SPI_MAJOR		153	/* registered device number */
+
+#define DEFAULT_SPI_CLK		6000000
+
+
+/* Maximum number of buffers in a single SPI transfer.
+ *  DataFlash uses maximum of 2
+ *  spidev interface supports up to 8.
+ */
+#define MAX_SPI_TRANSFERS	8
+#define NR_SPI_DEVICES		4	/* number of devices on SPI bus */
+
+/*
+ * Describes the buffers for a SPI transfer.
+ * A transmit & receive buffer must be specified for each transfer
+ */
+struct spi_transfer_list {
+	void* tx[MAX_SPI_TRANSFERS];	/* transmit */
+	int txlen[MAX_SPI_TRANSFERS];
+	void* rx[MAX_SPI_TRANSFERS];	/* receive */
+	int rxlen[MAX_SPI_TRANSFERS];
+	int nr_transfers;		/* number of transfers */
+	int curr;			/* current transfer */
+};
+
+struct spi_local {
+	unsigned int pcs;		/* Peripheral Chip Select value */
+
+	struct spi_transfer_list *xfers;	/* current transfer list */
+	dma_addr_t tx, rx;		/* DMA address for current transfer */
+	dma_addr_t txnext, rxnext;	/* DMA address for next transfer */
+};
+
+
+/* Exported functions */
+extern void spi_access_bus(short device);
+extern void spi_release_bus(short device);
+extern int spi_transfer(struct spi_transfer_list* list);
+
+#endif
diff -uNrbBw linux-2.6.22/include/linux/clk.h linux-2.6.22_9260/include/linux/clk.h
--- linux-2.6.22/include/linux/clk.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/linux/clk.h	2014-08-26 16:22:54.391398699 +0800
@@ -121,4 +121,24 @@
  */
 struct clk *clk_get_parent(struct clk *clk);
 
+/**
+ * clk_must_disable - report whether a clock's users must disable it
+ * @clk: one node in the clock tree
+ *
+ * This routine returns true only if the upcoming system state requires
+ * disabling the specified clock.
+ *
+ * It's common for platform power states to constrain certain clocks (and
+ * their descendants) to be unavailable, while other states allow that
+ * clock to be active.  A platform's power states often include an "all on"
+ * mode; system wide sleep states like "standby" or "suspend-to-RAM"; and
+ * operating states which sacrifice functionality for lower power usage.
+ *
+ * The constraint value is commonly tested in device driver suspend(), to
+ * leave clocks active if they are needed for features like wakeup events.
+ * On platforms that support reduced functionality operating states, the
+ * constraint may also need to be tested during resume() and probe() calls.
+ */
+int clk_must_disable(struct clk *clk);
+
 #endif
diff -uNrbBw linux-2.6.22/include/linux/i2c-id.h linux-2.6.22_9260/include/linux/i2c-id.h
--- linux-2.6.22/include/linux/i2c-id.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/linux/i2c-id.h	2014-08-26 16:22:54.395451764 +0800
@@ -203,6 +203,7 @@
 
 /* --- PCA 9564 based algorithms */
 #define I2C_HW_A_ISA		0x1a0000 /* generic ISA Bus interface card */
+#define I2C_HW_A_PLAT		0x1a0001 /* generic platform_bus interface */
 
 /* --- ACPI Embedded controller algorithms                              */
 #define I2C_HW_ACPI_EC          0x1f0000
diff -uNrbBw linux-2.6.22/include/linux/usb/serial.h linux-2.6.22_9260/include/linux/usb/serial.h
--- linux-2.6.22/include/linux/usb/serial.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/linux/usb/serial.h	2014-08-26 16:23:29.830381649 +0800
@@ -141,7 +141,7 @@
 };
 #define to_usb_serial(d) container_of(d, struct usb_serial, kref)
 
-#define NUM_DONT_CARE	(-1)
+#define NUM_DONT_CARE	99
 
 /* get and set the serial private data pointer helper functions */
 static inline void *usb_get_serial_data (struct usb_serial *serial)
@@ -160,12 +160,18 @@
  *	in the syslog messages when a device is inserted or removed.
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
- * @num_interrupt_in: the number of interrupt in endpoints this device will
- *	have.
- * @num_interrupt_out: the number of interrupt out endpoints this device will
- *	have.
- * @num_bulk_in: the number of bulk in endpoints this device will have.
- * @num_bulk_out: the number of bulk out endpoints this device will have.
+ * @num_interrupt_in: If a device doesn't have this many interrupt-in
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_interrupt_out: If a device doesn't have this many interrupt-out
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_bulk_in: If a device doesn't have this many bulk-in
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
+ * @num_bulk_out: If a device doesn't have this many bulk-out
+ *	endpoints, it won't be sent to the driver's attach() method.
+ *	(But it might still be sent to the probe() method.)
  * @num_ports: the number of different ports this device will have.
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()
@@ -221,6 +227,9 @@
 	int (*port_probe) (struct usb_serial_port *port);
 	int (*port_remove) (struct usb_serial_port *port);
 
+	int (*suspend) (struct usb_serial *serial, pm_message_t message);
+	int (*resume) (struct usb_serial *serial);
+
 	/* serial function calls */
 	int  (*open)		(struct usb_serial_port *port, struct file * filp);
 	void (*close)		(struct usb_serial_port *port, struct file * filp);
@@ -249,6 +258,9 @@
 extern int usb_serial_probe(struct usb_interface *iface, const struct usb_device_id *id);
 extern void usb_serial_disconnect(struct usb_interface *iface);
 
+extern int usb_serial_suspend(struct usb_interface *intf, pm_message_t message);
+extern int usb_serial_resume(struct usb_interface *intf);
+
 extern int ezusb_writememory (struct usb_serial *serial, int address, unsigned char *data, int length, __u8 bRequest);
 extern int ezusb_set_reset (struct usb_serial *serial, unsigned char reset_bit);
 
@@ -269,6 +281,7 @@
 extern int usb_serial_generic_open (struct usb_serial_port *port, struct file *filp);
 extern int usb_serial_generic_write (struct usb_serial_port *port, const unsigned char *buf, int count);
 extern void usb_serial_generic_close (struct usb_serial_port *port, struct file *filp);
+extern int usb_serial_generic_resume (struct usb_serial *serial);
 extern int usb_serial_generic_write_room (struct usb_serial_port *port);
 extern int usb_serial_generic_chars_in_buffer (struct usb_serial_port *port);
 extern void usb_serial_generic_read_bulk_callback (struct urb *urb);
diff -uNrbBw linux-2.6.22/include/linux/vt.h linux-2.6.22_9260/include/linux/vt.h
--- linux-2.6.22/include/linux/vt.h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/include/linux/vt.h	2014-08-26 16:23:29.831380980 +0800
@@ -6,8 +6,8 @@
  * resizing).
  */
 #define MIN_NR_CONSOLES 1       /* must be at least 1 */
-#define MAX_NR_CONSOLES	63	/* serial lines start at 64 */
-#define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */
+#define MAX_NR_CONSOLES	8	/* serial lines start at 64 */
+#define MAX_NR_USER_CONSOLES 8	/* must be root to allocate above this */
 		/* Note: the ioctl VT_GETSTATE does not work for
 		   consoles 16 and higher (since it returns a short) */
 
diff -uNrbBw linux-2.6.22/init/initramfs.c linux-2.6.22_9260/init/initramfs.c
--- linux-2.6.22/init/initramfs.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/init/initramfs.c	2014-08-26 16:23:29.834462996 +0800
@@ -551,7 +551,7 @@
 	if (initrd_start) {
 #ifdef CONFIG_BLK_DEV_RAM
 		int fd;
-		printk(KERN_INFO "checking if image is initramfs...");
+/*		printk(KERN_INFO "checking if image is initramfs...");
 		err = unpack_to_rootfs((char *)initrd_start,
 			initrd_end - initrd_start, 1);
 		if (!err) {
@@ -562,7 +562,7 @@
 			return 0;
 		}
 		printk("it isn't (%s); looks like an initrd\n", err);
-		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
+*/		fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
 			sys_write(fd, (char *)initrd_start,
 					initrd_end - initrd_start);
diff -uNrbBw linux-2.6.22/Makefile linux-2.6.22_9260/Makefile
--- linux-2.6.22/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/Makefile	2014-08-26 16:34:01.107397430 +0800
@@ -182,8 +182,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH ?= arm
+CROSS_COMPILE ?= arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
Binary files linux-2.6.22/patch/2.6.22-at91-exp.patch.gz and linux-2.6.22_9260/patch/2.6.22-at91-exp.patch.gz differ
Binary files linux-2.6.22/patch/2.6.22-at91.patch.gz and linux-2.6.22_9260/patch/2.6.22-at91.patch.gz differ
diff -uNrbBw linux-2.6.22/patch/2.6.22-netaccess_defconfig linux-2.6.22_9260/patch/2.6.22-netaccess_defconfig
--- linux-2.6.22/patch/2.6.22-netaccess_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/patch/2.6.22-netaccess_defconfig	2011-08-30 15:35:48.000000000 +0800
@@ -0,0 +1,1352 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22.1
+# Wed May 18 15:21:01 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+CONFIG_LBD=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+CONFIG_LSF=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_AT91=y
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Atmel AT91 System-on-Chip
+#
+# CONFIG_ARCH_AT91RM9200 is not set
+CONFIG_ARCH_AT91SAM9260=y
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+# CONFIG_ARCH_AT91SAM9RL is not set
+
+#
+# AT91SAM9260 Variants
+#
+# CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+
+#
+# AT91SAM9260 / AT91SAM9XE Board Type
+#
+CONFIG_MACH_AT91SAM9260EK=y
+# CONFIG_MACH_CAM60 is not set
+
+#
+# AT91 Board Options
+#
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+# CONFIG_MTD_NAND_AT91_BUSWIDTH_16 is not set
+
+#
+# AT91 Feature Selections
+#
+# CONFIG_AT91_PROGRAMMABLE_CLOCKS is not set
+# CONFIG_ATMEL_TCLIB is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="initrd=0x21100040,5242880 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IP_VS=y
+CONFIG_IP_VS_DEBUG=y
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=y
+CONFIG_IP_VS_WRR=y
+CONFIG_IP_VS_LC=y
+CONFIG_IP_VS_WLC=y
+CONFIG_IP_VS_LBLC=y
+CONFIG_IP_VS_LBLCR=y
+CONFIG_IP_VS_DH=y
+CONFIG_IP_VS_SH=y
+CONFIG_IP_VS_SED=y
+CONFIG_IP_VS_NQ=y
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK_ENABLED=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE_EBT_T_FILTER=y
+CONFIG_BRIDGE_EBT_T_NAT=y
+CONFIG_BRIDGE_EBT_802_3=y
+CONFIG_BRIDGE_EBT_AMONG=y
+CONFIG_BRIDGE_EBT_ARP=y
+CONFIG_BRIDGE_EBT_IP=y
+CONFIG_BRIDGE_EBT_LIMIT=y
+CONFIG_BRIDGE_EBT_MARK=y
+CONFIG_BRIDGE_EBT_PKTTYPE=y
+CONFIG_BRIDGE_EBT_STP=y
+CONFIG_BRIDGE_EBT_VLAN=y
+CONFIG_BRIDGE_EBT_ARPREPLY=y
+CONFIG_BRIDGE_EBT_DNAT=y
+CONFIG_BRIDGE_EBT_MARK_T=y
+CONFIG_BRIDGE_EBT_REDIRECT=y
+CONFIG_BRIDGE_EBT_SNAT=y
+CONFIG_BRIDGE_EBT_LOG=y
+CONFIG_BRIDGE_EBT_ULOG=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+
+#
+# Wireless
+#
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+CONFIG_IEEE80211_CRYPT_TKIP=y
+# CONFIG_IEEE80211_SOFTMAC is not set
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_AT91=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_UB=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=y
+CONFIG_SCSI_SAS_ATTRS=y
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+CONFIG_MACB_TX_SRAM=y
+CONFIG_SMC91X=y
+CONFIG_DM9000=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+CONFIG_WLAN_PRE80211=y
+# CONFIG_STRIP is not set
+CONFIG_WLAN_80211=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET_MII is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=8
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+# CONFIG_HWMON is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# HID Devices
+#
+# CONFIG_HID is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_AT91=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
Binary files linux-2.6.22/patch/2.6.22-netaccess.patch.gz and linux-2.6.22_9260/patch/2.6.22-netaccess.patch.gz differ
Binary files linux-2.6.22/patch/2.6.33-at91.patch.gz and linux-2.6.22_9260/patch/2.6.33-at91.patch.gz differ
diff -uNrbBw linux-2.6.22/patch/2.6.33-netaccess_defconfig linux-2.6.22_9260/patch/2.6.33-netaccess_defconfig
--- linux-2.6.22/patch/2.6.33-netaccess_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/patch/2.6.33-netaccess_defconfig	2011-08-30 15:35:48.000000000 +0800
@@ -0,0 +1,1719 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.33.7
+# Wed May 18 17:44:41 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_KALLSYMS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+# CONFIG_BUG is not set
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+CONFIG_ARCH_AT91=y
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_U8500 is not set
+CONFIG_HAVE_AT91_DATAFLASH_CARD=y
+CONFIG_HAVE_NAND_ATMEL_BUSWIDTH_16=y
+CONFIG_HAVE_AT91_USART3=y
+CONFIG_HAVE_AT91_USART4=y
+CONFIG_HAVE_AT91_USART5=y
+
+#
+# Atmel AT91 System-on-Chip
+#
+# CONFIG_ARCH_AT91RM9200 is not set
+CONFIG_ARCH_AT91SAM9260=y
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9G10 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+# CONFIG_ARCH_AT91SAM9RL is not set
+# CONFIG_ARCH_AT91SAM9G20 is not set
+# CONFIG_ARCH_AT91SAM9G45 is not set
+# CONFIG_ARCH_AT91CAP9 is not set
+# CONFIG_ARCH_AT572D940HF is not set
+# CONFIG_ARCH_AT91X40 is not set
+CONFIG_AT91_PMC_UNIT=y
+
+#
+# AT91SAM9260 Variants
+#
+# CONFIG_ARCH_AT91SAM9260_SAM9XE is not set
+
+#
+# AT91SAM9260 / AT91SAM9XE Board Type
+#
+CONFIG_MACH_AT91SAM9260EK=y
+# CONFIG_MACH_CAM60 is not set
+# CONFIG_MACH_SAM9_L9260 is not set
+# CONFIG_MACH_AFEB9260 is not set
+# CONFIG_MACH_USB_A9260 is not set
+# CONFIG_MACH_QIL_A9260 is not set
+# CONFIG_MACH_SBC35_A9260 is not set
+
+#
+# AT91 Board Options
+#
+# CONFIG_MTD_AT91_DATAFLASH_CARD is not set
+# CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16 is not set
+
+#
+# AT91 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+CONFIG_AT91_TIMER_HZ=100
+CONFIG_AT91_EARLY_DBGU=y
+# CONFIG_AT91_EARLY_USART0 is not set
+# CONFIG_AT91_EARLY_USART1 is not set
+# CONFIG_AT91_EARLY_USART2 is not set
+# CONFIG_AT91_EARLY_USART3 is not set
+# CONFIG_AT91_EARLY_USART4 is not set
+# CONFIG_AT91_EARLY_USART5 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="initrd=0x21100040,5242880 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_HL=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NETFILTER_XT_MATCH_OSF=y
+CONFIG_IP_VS=y
+CONFIG_IP_VS_DEBUG=y
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=y
+CONFIG_IP_VS_WRR=y
+CONFIG_IP_VS_LC=y
+CONFIG_IP_VS_WLC=y
+CONFIG_IP_VS_LBLC=y
+CONFIG_IP_VS_LBLCR=y
+CONFIG_IP_VS_DH=y
+CONFIG_IP_VS_SH=y
+CONFIG_IP_VS_SED=y
+CONFIG_IP_VS_NQ=y
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+# CONFIG_WEXT_SPY is not set
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_ATMEL=y
+CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+# CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+# CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_TCLIB is not set
+# CONFIG_ICS932S401 is not set
+CONFIG_ATMEL_SSC=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# The newer stack is recommended.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+CONFIG_SERIAL_ATMEL_PDC=y
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=8
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_AT91 is not set
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_ATMEL=y
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_88PM8607 is not set
+# CONFIG_AB4500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_AT91=y
+# CONFIG_MMC_ATMELMCI is not set
+CONFIG_MMC_SPI=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_AT91SAM9 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=936
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
Binary files linux-2.6.22/patch/2.6.33-netaccess.patch.gz and linux-2.6.22_9260/patch/2.6.33-netaccess.patch.gz differ
Binary files linux-2.6.22/patch/mkimage and linux-2.6.22_9260/patch/mkimage differ
Binary files linux-2.6.22/patch/mkimage_oldMagic and linux-2.6.22_9260/patch/mkimage_oldMagic differ
Binary files linux-2.6.22/patch/patch-2.6.33.7.gz and linux-2.6.22_9260/patch/patch-2.6.33.7.gz differ
diff -uNrbBw linux-2.6.22/scripts/checksyscalls.sh linux-2.6.22_9260/scripts/checksyscalls.sh
--- linux-2.6.22/scripts/checksyscalls.sh	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/scripts/checksyscalls.sh	2014-08-26 16:23:29.839395917 +0800
@@ -14,6 +14,13 @@
 #include <asm/types.h>
 #include <asm/unistd.h>
 
+//Add By WenJing 20090615
+#define __IGNORE_fadvise64
+#define __IGNORE_migrate_pages
+#define __IGNORE_pselect6
+#define __IGNORE_ppoll
+#define __IGNORE_epoll_pwait
+
 /* System calls for 32-bit kernels only */
 #if BITS_PER_LONG == 64
 #define __IGNORE_sendfile64
@@ -99,10 +106,13 @@
 #define __IGNORE_setfsuid32
 #define __IGNORE_setfsgid32
 
+// complie warnning
 /* sync_file_range had a stupid ABI. Allow sync_file_range2 instead */
+/*
 #ifdef __NR_sync_file_range2
 #define __IGNORE_sync_file_range
 #endif
+*/
 
 /* Unmerged syscalls for AFS, STREAMS, etc. */
 #define __IGNORE_afs_syscall
diff -uNrbBw linux-2.6.22/scripts/mkcompile_h linux-2.6.22_9260/scripts/mkcompile_h
--- linux-2.6.22/scripts/mkcompile_h	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/scripts/mkcompile_h	2014-08-26 16:23:29.841400067 +0800
@@ -23,7 +23,9 @@
 export LC_ALL
 
 if [ -z "$KBUILD_BUILD_VERSION" ]; then
-	if [ -r .version ]; then
+	if [ -r ../.svn/entries ]; then
+	        VERSION=`sed -n -e 11p ../.svn/entries`
+	elif [ -r .version ]; then
 		VERSION=`cat .version`
 	else
 		VERSION=0
diff -uNrbBw linux-2.6.22/sound/arm/at73c213.c linux-2.6.22_9260/sound/arm/at73c213.c
--- linux-2.6.22/sound/arm/at73c213.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/at73c213.c	2014-08-26 16:23:12.708392396 +0800
@@ -0,0 +1,671 @@
+/*
+ * Driver for the at73c213 16-bit stereo DAC on Atmel SSC
+ *
+ * Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#include <asm/io.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <linux/atmel_pdc.h>
+#include <asm/arch/board.h>
+
+#include "at73c213.h"
+
+/*-----------------------------------------------------------------------------
+ *  AT73C213 SPI
+ *-----------------------------------------------------------------------------*/
+static struct spi_device *at73c213_spi_device;
+static unsigned char at73c213_regs[0x11];
+static unsigned char at73c213_spi_wbuffer[2];
+static unsigned char at73c213_spi_rbuffer[2];
+
+/*-----------------------------------------------------------------------------
+ *  AT73C213 SPI write regs
+ *-----------------------------------------------------------------------------*/
+static int at73c213_write_reg(u8 reg, u8 val)
+{
+    struct spi_message msg;
+    struct spi_transfer msg_xfer =
+    {
+        .len        = 2,
+        .cs_change  = 0,
+    };
+
+    spi_message_init(&msg);
+
+    at73c213_spi_wbuffer[0] = reg;
+    at73c213_spi_wbuffer[1] = val;
+
+    msg_xfer.tx_buf = at73c213_spi_wbuffer;
+    msg_xfer.rx_buf = at73c213_spi_rbuffer;
+    spi_message_add_tail(&msg_xfer, &msg);
+
+    at73c213_regs[reg] = val;
+
+    return spi_sync(at73c213_spi_device, &msg);
+}
+
+/*-----------------------------------------------------------------------------
+ *  AT73C213 SPI read regs
+ *-----------------------------------------------------------------------------*/
+static unsigned char at73c213_read_reg(unsigned char reg)
+{
+    return at73c213_regs[reg];
+}
+
+/*-----------------------------------------------------------------------------
+ *  AT73C213 - Init
+ *-----------------------------------------------------------------------------*/
+static void at73c213_hw_init(void)
+{
+/*
+	From AT73C213 datasheet
+	Path DAC to headset output
+	1. Write @0x10 => 0x03 (deassert the reset)
+	2. Write @0x0C => 0xFF (precharge + master on)
+	3. Write @0x00 => 0x30 (ONLNOL and ONLONOR set to 1)
+	4. Delay 500 ms
+	5. Write @0x0C => 0x01 (precharge off + master on)
+	6. Delay 1ms
+	7. Write @0x00 => 0x3C (ONLNOL, ONLNOR, ONDACR and ONDACL set to 1)
+*/
+	/* Make sure everything is off */
+	at73c213_write_reg(DAC_CTRL, 0x00);
+
+	msleep(500);
+
+	/* de-reset the device */
+    	at73c213_write_reg(DAC_RST, 0x03);
+
+	/* Turn on precharge */
+	at73c213_write_reg(DAC_PRECH, 0xFF);
+	at73c213_write_reg(DAC_CTRL, 0x30);
+
+    	/* Wait 500 ms*/
+    	msleep(500);
+
+	at73c213_write_reg(DAC_PRECH, 0x01);
+
+	msleep(1);
+
+	at73c213_write_reg(DAC_CTRL, 0x3C);
+	at73c213_write_reg(DAC_LLOG, 0x1f);
+	at73c213_write_reg(DAC_RLOG, 0x1f);
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_probe
+ *----------------------------------------------------------------------------*/
+static int __devinit at73c213_probe(struct spi_device *spi)
+{
+	int retval = 0;
+
+	if(!spi)
+		return -ENXIO;
+
+	at73c213_spi_device = spi;
+
+	return retval;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_remove
+ *----------------------------------------------------------------------------*/
+static int __devexit at73c213_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*-----------------------------------------------------------------------------
+* snd_at73c213_suspend
+*----------------------------------------------------------------------------*/
+static int at73c213_suspend(struct spi_device *spi)
+{
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+* snd_at73c213_resume
+*----------------------------------------------------------------------------*/
+static int at73c213_resume(struct spi_device *spi)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+/*-----------------------------------------------------------------------------
+ * AT73C213 Driver
+ *----------------------------------------------------------------------------*/
+static struct spi_driver at73c213_driver =
+{
+	.driver =
+	{
+		.name       = "at73c213",
+		.bus        = &spi_bus_type,
+		.owner      = THIS_MODULE,
+	}
+	,
+		.probe      = at73c213_probe,
+		.remove     = __devexit_p(at73c213_remove),
+		/* TODO:  investigate suspend and resume... */
+	#ifdef CONFIG_PM
+		.resume     = at73c213_resume,
+		.suspend    = at73c213_suspend,
+	#endif
+};
+
+/********************************************************************************
+*   Mixer
+********************************************************************************/
+
+/*-----------------------------------------------------------------------------
+ *  Info functions
+ *----------------------------------------------------------------------------*/
+static int at73c213_info_pcm_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0x0;
+	uinfo->value.integer.max = 0x1f;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ *  Get functions
+ *----------------------------------------------------------------------------*/
+static int at73c213_get_pcm_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value * ucontrol)
+{
+	ucontrol->value.integer.value[0] = (0x1f - at73c213_read_reg(DAC_LLOG)); /*left */
+	ucontrol->value.integer.value[1] = (0x1f - at73c213_read_reg(DAC_RLOG)); /*right*/
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ *  Put functions
+ *----------------------------------------------------------------------------*/
+static int at73c213_put_pcm_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value * ucontrol)
+{
+	at73c213_write_reg(DAC_LLOG,(0x1f - ucontrol->value.integer.value[0]));
+	at73c213_write_reg(DAC_RLOG,(0x1f - ucontrol->value.integer.value[1]));
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ *  Controls
+ *----------------------------------------------------------------------------*/
+static struct snd_kcontrol_new snd_at73c213_controls[] =
+{
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name  = "PCM Playback Volume",
+		.info  = at73c213_info_pcm_volume,
+		.get   = at73c213_get_pcm_volume,
+		.put   = at73c213_put_pcm_volume
+	},
+};
+
+/*-----------------------------------------------------------------------------
+ *  Controls
+ *----------------------------------------------------------------------------*/
+static int __devinit snd_chip_at73c213_mixer_new(struct snd_card *card)
+{
+	int idx, err;
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	if(at73c213_spi_device == NULL) {
+		printk(KERN_WARNING "No at73c231_spi_device found\n");
+		return -EFAULT;
+	}
+
+	/*  Set Mixer IOCTL */
+	for (idx = 0; idx < ARRAY_SIZE(snd_at73c213_controls); idx++) {
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_at73c213_controls[idx], NULL))) < 0)
+			return err;
+	}
+
+	/* Init DAC Hardware */
+	at73c213_hw_init();
+
+	return 0;
+}
+
+/********************************************************************************
+*   DSP
+********************************************************************************/
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_playback_hw
+ *----------------------------------------------------------------------------*/
+static struct snd_pcm_hardware snd_at73c213_playback_hw =
+{
+	.info    = (	SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER  ),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+        .rates =  SNDRV_PCM_RATE_CONTINUOUS,
+        .rate_min =         48000,
+        .rate_max =         48000,
+    	.channels_min   = 2,
+    	.channels_max   = 2,
+    	.buffer_bytes_max = 64 * 1024 - 1,
+    	.period_bytes_min = 1024,
+    	.period_bytes_max = 64 * 1024 - 1,
+    	.periods_min    = 4,
+    	.periods_max    = 1024,
+};
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_open - open callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	runtime->hw = snd_at73c213_playback_hw;
+	chip->substream = substream;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_close - close callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	chip->substream = NULL;
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_hw_params - hw_params callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_hw_params(struct snd_pcm_substream *substream,
+                                      struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+                                    params_buffer_bytes(hw_params));
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_hw_free - hw_free callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+    return snd_pcm_lib_free_pages(substream);
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_prepare - prepare callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	struct platform_device *pdev = chip->pdev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int block_size;
+
+	block_size = frames_to_bytes(runtime, runtime->period_size);
+
+	chip->period = 0;
+
+	/* Make sure that our data are actually readable by the SSC */
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr,
+			block_size, DMA_TO_DEVICE);
+	dma_sync_single_for_device(&pdev->dev, runtime->dma_addr + block_size,
+			block_size, DMA_TO_DEVICE);
+
+	writel(runtime->dma_addr, chip->ssc_regs + PDC_TPR);
+	writel(runtime->period_size * 2, chip->ssc_regs + PDC_TCR);
+	writel(runtime->dma_addr + block_size, chip->ssc_regs + PDC_TNPR);
+	writel(runtime->period_size * 2, chip->ssc_regs + PDC_TNCR);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_trigger - trigger callback
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_pcm_trigger(struct snd_pcm_substream *substream,
+                                    int cmd)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	int retval = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	switch (cmd)
+	{
+		case SNDRV_PCM_TRIGGER_START:
+			writel(SSC_INT_ENDTX, chip->ssc_regs + SSC_IER);
+			writel(PDC_PTCR_TXTEN, chip->ssc_regs + PDC_PTCR);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			writel(PDC_PTCR_TXTDIS, chip->ssc_regs + PDC_PTCR);
+			writel(SSC_INT_ENDTX, chip->ssc_regs + SSC_IDR);
+			break;
+		default:
+			printk(KERN_WARNING "at73c213: spurious command %x\n", cmd);
+			retval = -EINVAL;
+			break;
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return retval;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_pcm_uframes_t - pointer callback
+ *----------------------------------------------------------------------------*/
+static snd_pcm_uframes_t snd_at73c213_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_at73c213 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+	bytes = readl(chip->ssc_regs + PDC_TPR) - runtime->dma_addr;
+
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+	return pos;
+}
+
+/*-----------------------------------------------------------------------------
+ * operators
+ *----------------------------------------------------------------------------*/
+static struct snd_pcm_ops at73c213_playback_ops =
+{
+	.open       = snd_at73c213_pcm_open,
+	.close      = snd_at73c213_pcm_close,
+	.ioctl      = snd_pcm_lib_ioctl,
+	.hw_params  = snd_at73c213_pcm_hw_params,
+	.hw_free    = snd_at73c213_pcm_hw_free,
+	.prepare    = snd_at73c213_pcm_prepare,
+	.trigger    = snd_at73c213_pcm_trigger,
+	.pointer    = snd_at73c213_pcm_pointer,
+};
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_pcm_free free a pcm device
+ *----------------------------------------------------------------------------*/
+static void snd_at73c213_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_at73c213 *chip = snd_pcm_chip(pcm);
+
+	if (chip->pcm != 0 )
+	{
+		snd_pcm_lib_preallocate_free_for_all(chip->pcm);
+		chip->pcm = NULL;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_new_pcm create a new pcm device
+ *----------------------------------------------------------------------------*/
+static int __devinit snd_at73c213_new_pcm(struct snd_card * card)
+{
+	struct snd_pcm *pcm;
+	struct snd_at73c213 * chip = card->private_data;
+	int err;
+
+	err = snd_pcm_new(chip->card, "AT73C213", 0, 1, 0, &pcm);
+	if (err)
+		return err;
+
+	pcm->private_data = chip;
+	pcm->private_free = snd_at73c213_pcm_free;
+	pcm->info_flags = SNDRV_PCM_INFO_BLOCK_TRANSFER;
+	pcm->private_data = chip;
+	strcpy( pcm->name, "AT73C213" );
+	chip->pcm = pcm;
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at73c213_playback_ops);
+
+	/* pre-allocation of buffers */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, NULL, 64 * 1024, 64 * 1024);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_interrupt
+ *---------------------------------------------------------------------------*/
+static irqreturn_t snd_at73c213_interrupt(int irq, void *dev_id)
+{
+	struct snd_at73c213 *chip = dev_id;
+	struct platform_device *pdev = chip->pdev;
+	struct snd_pcm_runtime *runtime = chip->substream->runtime;
+	u32 status;
+	int offset, next_period, block_size;
+
+	spin_lock(&chip->lock);
+
+	block_size = frames_to_bytes(runtime, runtime->period_size);
+
+	status = readl(chip->ssc_regs + SSC_IMR);
+
+	if (status & SSC_INT_ENDTX)
+	{
+		chip->period++;
+		if (chip->period == runtime->periods)
+			chip->period = 0;
+		next_period = chip->period + 1;
+		if (next_period == runtime->periods)
+			next_period = 0;
+
+		offset = block_size * next_period;
+
+		/* Make sure that our data are actually readable by the SSC */
+		dma_sync_single_for_device(&pdev->dev, runtime->dma_addr + offset,
+				block_size, DMA_TO_DEVICE);
+		writel(runtime->dma_addr + offset, chip->ssc_regs + PDC_TNPR);
+		writel(runtime->period_size * 2, chip->ssc_regs + PDC_TNCR);
+
+		if (next_period == 0)
+		{
+			(void)readl(chip->ssc_regs + PDC_TPR);
+			(void)readl(chip->ssc_regs + PDC_TCR);
+		}
+	}
+	else
+	{
+		printk(KERN_WARNING
+				"Spurious SSC interrupt, status = 0x%08lx\n",
+				(unsigned long)status);
+		writel(status, chip->ssc_regs + SSC_IDR);
+	}
+
+	(void)readl(chip->ssc_regs + SSC_IMR);
+	spin_unlock(&chip->lock);
+
+	if (status & SSC_INT_ENDTX)
+		snd_pcm_period_elapsed(chip->substream);
+
+	return IRQ_HANDLED;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_chip_init
+ *----------------------------------------------------------------------------*/
+static int snd_at73c213_chip_init(struct snd_at73c213 *chip)
+{
+	/* Reset the SSC */
+	writel(SSC_CR_SWRST, chip->ssc_regs + SSC_CR);
+
+	/* Enable SSC and setup for I2S */
+	writel(chip->ssc_div, chip->ssc_regs + SSC_CMR);
+
+	/* CKO, START, STTDLY, PERIOD */
+	writel((1<<2)|(4<<8)|(1<<16)|(15<<24), chip->ssc_regs + SSC_TCMR);
+
+	/* DATLEN, MSBF, DATNB, FSLEN, FSOS */
+	writel((15<<0)|(1<<7)|(1<<8)|(15<<16)|(1<<20), chip->ssc_regs + SSC_TFMR);
+
+	/* Enable SSC RX */
+	writel(SSC_CR_TXEN, chip->ssc_regs + SSC_CR);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_probe
+ *----------------------------------------------------------------------------*/
+static int __devinit snd_at73c213_probe(struct platform_device *pdev)
+{
+	struct atmel_at73c213_data *pdata = pdev->dev.platform_data;
+	struct snd_at73c213 *chip;
+	struct snd_card *card;
+	int irq, ret;
+	struct resource *res;
+
+	/* register the soundcard */
+	card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, THIS_MODULE, sizeof(struct snd_at73c213));
+	if (card == NULL){
+		return -ENOMEM;
+	}
+
+	chip = card->private_data;
+	chip->ssc_div = pdata->ssc_div;
+	chip->at73_mck = pdata->at73_mck;
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	strcpy( card->driver, "AT73C213" );
+	strcpy( card->shortname, "AT73C213" );
+	strcpy( card->longname, "AT73C213" );
+
+	if (!pdev)
+		return -ENXIO;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+	chip->irq = irq;
+
+	/* Request mem region */
+	if (!request_mem_region(res->start, res->end - res->start + 1, pdev->name))
+		return -EBUSY;
+
+	/* Remap SSC register */
+	chip->ssc_regs = ioremap(res->start, res->end - res->start + 1);
+	if (!chip->ssc_regs)
+		return -ENOMEM;
+
+	snd_chip_at73c213_mixer_new(card);
+
+	snd_at73c213_new_pcm(card);
+
+	ret = request_irq(chip->irq, snd_at73c213_interrupt, 0, "AT73C213", chip);
+	if (ret)
+		return ret;
+	snd_at73c213_chip_init(chip);
+
+	ret = snd_card_register(card);
+	if(ret)
+		return ret;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_remove
+ *----------------------------------------------------------------------------*/
+static int __devexit snd_at73c213_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * snd_at73c213_driver
+ *----------------------------------------------------------------------------*/
+static struct platform_driver snd_at73c213_driver =
+{
+	.probe      = snd_at73c213_probe,
+	.remove     = __devexit_p(snd_at73c213_remove),
+	.driver     =
+	{
+		.name       = "atmel_ssc_at73c213",
+	}
+	,
+};
+
+static int __init snd_at73c213_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&at73c213_driver);
+	if(ret)
+		return ret;
+
+	ret = platform_driver_register(&snd_at73c213_driver);
+	if(ret)
+	{
+		spi_unregister_driver(&at73c213_driver);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit snd_at73c213_exit(void)
+{
+	platform_driver_unregister(&snd_at73c213_driver);
+	spi_unregister_driver(&at73c213_driver);
+}
+
+/********************************************************************************
+*   Module
+********************************************************************************/
+MODULE_AUTHOR("Atmel");
+MODULE_DESCRIPTION("at73c213 snd driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_at73c213_init);
+module_exit(snd_at73c213_exit);
diff -uNrbBw linux-2.6.22/sound/arm/at73c213.h linux-2.6.22_9260/sound/arm/at73c213.h
--- linux-2.6.22/sound/arm/at73c213.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/at73c213.h	2014-08-26 16:23:12.711402115 +0800
@@ -0,0 +1,182 @@
+/*
+ * Driver for the AT73C213 16-bit stereo DAC
+ *
+ * Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this
+ * distribution in the file called COPYING.
+ */
+
+#ifndef SND_AT73C213_MIXER_H_
+#define SND_AT73C213_MIXER_H_
+
+/* DAC control register */
+#define DAC_CTRL		0x00
+#define DAC_CTRL_ONPADRV	7
+#define DAC_CTRL_ONAUXIN	6
+#define DAC_CTRL_ONDACR		5
+#define DAC_CTRL_ONDACL		4
+#define DAC_CTRL_ONLNOR		3
+#define DAC_CTRL_ONLNOL		2
+#define DAC_CTRL_ONLNIR		1
+#define DAC_CTRL_ONLNIL		0
+
+/* DAC left line in gain register */
+#define DAC_LLIG		0x01
+#define DAC_LLIG_LLIG		0
+
+/* DAC right line in gain register */
+#define DAC_RLIG		0x02
+#define DAC_RLIG_RLIG		0
+
+/* DAC Left Master Playback Gain Register */
+#define DAC_LMPG		0x03
+#define DAC_LMPG_LMPG		0
+
+/* DAC Right Master Playback Gain Register */
+#define DAC_RMPG		0x04
+#define DAC_RMPG_RMPG		0
+
+/* DAC Left Line Out Gain Register */
+#define DAC_LLOG		0x05
+#define DAC_LLOG_LLOG		0
+
+/* DAC Right Line Out Gain Register */
+#define DAC_RLOG		0x06
+#define DAC_RLOG_RLOG		0
+
+/* DAC Output Level Control Register */
+#define DAC_OLC			0x07
+#define DAC_OLC_RSHORT		7
+#define DAC_OLC_ROLC		4
+#define DAC_OLC_LSHORT		3
+#define DAC_OLC_LOLC		0
+
+/* DAC Mixer Control Register */
+#define DAC_MC			0x08
+#define DAC_MC_INVR		5
+#define DAC_MC_INVL		4
+#define DAC_MC_RMSMIN2		3
+#define DAC_MC_RMSMIN1		2
+#define DAC_MC_LMSMIN2		1
+#define DAC_MC_LMSMIN1		0
+
+/* DAC Clock and Sampling Frequency Control Register */
+#define DAC_CSFC		0x09
+#define DAC_CSFC_OVRSEL		4
+
+/* DAC Miscellaneous Register */
+#define DAC_MISC		0x0A
+#define DAC_MISC_VCMCAPSEL	7
+#define DAC_MISC_DINTSEL	4
+#define DAC_MISC_DITHEN		3
+#define DAC_MISC_DEEMPEN	2
+#define DAC_MISC_NBITS		0
+
+/* DAC Precharge Control Register */
+#define DAC_PRECH		0x0C
+#define DAC_PRECH_PRCHGPDRV	7
+#define DAC_PRECH_PRCHGAUX1	6
+#define DAC_PRECH_PRCHGLNOR	5
+#define DAC_PRECH_PRCHGLNOL	4
+#define DAC_PRECH_PRCHGLNIR	3
+#define DAC_PRECH_PRCHGLNIL	2
+#define DAC_PRECH_PRCHG		1
+#define DAC_PRECH_ONMSTR	0
+
+/* DAC Auxiliary Input Gain Control Register */
+#define DAC_AUXG		0x0D
+#define DAC_AUXG_AUXG		0
+
+/* DAC Reset Register */
+#define DAC_RST			0x10
+#define DAC_RST_RESMASK		2
+#define DAC_RST_RESFILZ		1
+#define DAC_RST_RSTZ		0
+
+/* Power Amplifier Control Register */
+#define PA_CTRL			0x11
+#define PA_CTRL_APAON		6
+#define PA_CTRL_APAPRECH	5
+#define PA_CTRL_APALP		4
+#define PA_CTRL_APAGAIN		0
+
+/* PDC */
+#define PDC_RPR		0x100	/* Receive Pointer Register */
+#define PDC_RCR		0x104	/* Receive Counter Register */
+#define PDC_TPR		0x108	/* Transmit Pointer Register */
+#define PDC_TCR		0x10c	/* Transmit Counter Register */
+#define PDC_RNPR		0x110	/* Receive Next Pointer Register */
+#define PDC_RNCR		0x114	/* Receive Next Counter Register */
+#define PDC_TNPR		0x118	/* Transmit Next Pointer Register */
+#define PDC_TNCR		0x11c	/* Transmit Next Counter Register */
+
+#define PDC_PTCR		0x120	/* Transfer Control Register */
+#define		PDC_PTCR_RXTEN		(1 << 0)	/* Receiver Transfer Enable */
+#define		PDC_PTCR_RXTDIS		(1 << 1)	/* Receiver Transfer Disable */
+#define		PDC_PTCR_TXTEN		(1 << 8)	/* Transmitter Transfer Enable */
+#define		PDC_PTCR_TXTDIS		(1 << 9)	/* Transmitter Transfer Disable */
+
+#define PDC_PTSR		0x124	/* Transfer Status Register */
+#define SSC_CMR		0x04
+#define SSC_CR		0x00
+#define SSC_TCMR	0x18
+#define SSC_TFMR	0x1C
+
+/* SSC register definitions */
+#define SSC_CR		0x00
+#define SSC_CMR		0x04
+#define SSC_TCMR	0x18
+#define SSC_TFMR	0x1C
+#define SSC_THR		0x24
+#define SSC_SR		0x40
+#define SSC_IER		0x44
+#define SSC_IDR		0x48
+#define SSC_IMR		0x4C
+
+/* SSC fields definitions */
+#define SSC_CR_TXEN	0x00000100
+#define SSC_CR_TXDIS	0x00000200
+#define SSC_CR_SWRST	0x00008000
+
+/* SSC interrupt definitions */
+#define SSC0_IRQ	10
+#define SSC_INT_ENDTX	0x00000004
+#define SSC_INT_TXBUFE	0x00000008
+
+
+/* chip-specific data */
+struct snd_at73c213 {
+	struct snd_card			*card;
+	struct snd_pcm			*pcm;
+	struct snd_pcm_substream	*substream;
+	struct spi_device		*spi;
+	struct clk			*ssc_clk;
+	struct clk			*at73_mck;
+	spinlock_t			lock;
+	struct platform_device		*pdev;
+	void __iomem			*ssc_regs;
+	int				ext_clk_rate;
+	int 				ssc_div;
+	int					irq;
+	int					period;
+	u8					spi_wbuffer[2];
+	u8					spi_rbuffer[2];
+};
+#endif
+
diff -uNrbBw linux-2.6.22/sound/arm/at91-ac97.c linux-2.6.22_9260/sound/arm/at91-ac97.c
--- linux-2.6.22/sound/arm/at91-ac97.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/at91-ac97.c	2014-08-26 16:23:12.703386746 +0800
@@ -0,0 +1,654 @@
+/*
+ * 
+ * Driver for the Atmel AC97 Controller
+ *
+ * Copyright (C) 2005 Atmel 
+*/
+
+
+#undef DEBUG
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/atmel_pdc.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/cacheflush.h>
+
+#include <asm/arch/gpio.h>
+#include "at91-ac97.h"
+#include <asm/arch/board.h>
+
+#define platform_num_resources(dev)     ((dev)->num_resources)
+#define platform_resource_start(dev, i) ((dev)->resource[(i)].start)
+#define platform_resource_end(dev, i)   ((dev)->resource[(i)].end)
+#define platform_resource_flags(dev, i) ((dev)->resource[(i)].flags)
+#define platform_resource_len(dev, i)                   \
+        (platform_resource_end((dev), (i)) -            \
+         platform_resource_start((dev), (i)) + 1)
+
+
+/* module parameters */
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for AC97 controller");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for AC97 controller");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable AC97 controller");
+
+
+
+typedef struct at91_ac97 {
+	spinlock_t lock;
+	void *regs;
+	int period;
+	struct clk *ac97_clk;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_ac97 *ac97;
+	struct snd_ac97_bus *ac97_bus;
+	int irq;
+	struct platform_device *pdev;
+	u8 reset_pin;
+} at91_ac97_t;
+
+
+
+
+#define get_chip(card) ((at91_ac97_t *)(card)->private_data)
+
+
+
+#define ac97c_writel(chip, reg, val)			\
+	writel((val), (chip)->regs + AC97C_##reg)
+
+#define ac97c_readl(chip, reg)				\
+	readl((chip)->regs + AC97C_##reg)
+
+// PIO management functions
+void at91_ac97c_drive_reset(at91_ac97_t *chip, unsigned int value)
+{
+	at91_set_gpio_value(chip->reset_pin, value);
+}
+
+
+static const char driver_name[] = "at91-ac97";
+
+/* PCM part */
+static struct snd_pcm_hardware snd_at91_ac97_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED
+				   | SNDRV_PCM_INFO_MMAP
+				   | SNDRV_PCM_INFO_MMAP_VALID
+                                   | SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_CONTINUOUS,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 256*1024,
+	.period_bytes_min	= 1024,
+	.period_bytes_max	= 4*1024,
+	.periods_min		= 1,
+	.periods_max		= 64,
+};
+
+static int snd_at91_ac97_playback_open(struct snd_pcm_substream *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	runtime->hw = snd_at91_ac97_hw;
+	chip->playback_substream = substream;
+	chip->period = 0;
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_open\n\r", driver_name);
+
+	return 0;
+}
+
+static int snd_at91_ac97_playback_close(struct snd_pcm_substream *substream)
+{
+        at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+
+        chip->playback_substream = NULL;
+	return 0;
+}
+
+static int snd_at91_ac97_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
+{
+	int err;
+
+	err = snd_pcm_lib_malloc_pages(substream,
+				       params_buffer_bytes(hw_params));
+	return err;
+}
+
+static int snd_at91_ac97_hw_free(struct snd_pcm_substream *substream)
+{
+
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_at91_ac97_playback_prepare(struct snd_pcm_substream *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int block_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned long word = 0;
+
+	//clean_dcache_region(runtime->dma_area, block_size * 2);
+	snd_printd(KERN_DEBUG "%s : block_size = %d\n\r", driver_name, block_size);
+
+	/* Assign slots to channels */
+	switch (substream->runtime->channels) {
+          /* TODO: Support more than two channels */
+        case 1:
+          word |= AT91C_AC97C_CHID3_CA;
+          break;
+	case 2:
+        default:
+          /* Assign Left and Right slots (3,4) to Channel A */
+          word |= AT91C_AC97C_CHID3_CA | AT91C_AC97C_CHID4_CA;
+          break;
+	}
+
+	ac97c_writel(chip, OCA, word);
+
+	/*
+	 * Configure sample format and size.
+	 * FIXME: Avoid conflicts with capture channel.
+	 */
+        word = AT91C_AC97C_PDCEN | AT91C_AC97C_SIZE_16_BITS;
+
+        switch (runtime->format){
+        case SNDRV_PCM_FORMAT_S16_BE:
+          word |= AT91C_AC97C_CEM;
+          break;
+        case SNDRV_PCM_FORMAT_S16_LE:
+        default:
+          break;
+        }
+
+	ac97c_writel(chip, CAMR, word);
+
+        /* Set variable rate if needed */
+        if ( runtime->rate != 48000 ){
+          word = ac97c_readl(chip, MR);
+          word |= AT91C_AC97C_VRA;
+          ac97c_writel(chip, MR, word);
+        } else {
+          /* Clear Variable Rate Bit */
+          word = ac97c_readl(chip, MR);
+          word &= ~AT91C_AC97C_VRA;
+          ac97c_writel(chip, MR, word);
+        }
+
+        /* Set rate */
+        snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
+
+	snd_printd(KERN_DEBUG "%s : dma_addr = %x\n\r : dma_area = %x\n\r : dma_bytes = %d\n\r",
+		   driver_name, runtime->dma_addr, runtime->dma_area, runtime->dma_bytes);
+
+	/* Initialize and start the PDC */
+	writel(runtime->dma_addr, chip->regs + ATMEL_PDC_TPR);
+	writel(block_size / 2, chip->regs + ATMEL_PDC_TCR);
+	writel(runtime->dma_addr + block_size, chip->regs + ATMEL_PDC_TNPR);
+	writel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);
+
+	/* Enable Channel A interrupts */
+	ac97c_writel(chip, IER, AT91C_AC97C_CAEVT);
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_playback_prepare\n\r", driver_name);
+
+	return 0;
+}
+
+static int at91_ac97_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	unsigned long camr, ptcr = 0, flags;
+	int err = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	camr = ac97c_readl(chip, CAMR);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+          camr |= (AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
+	  ptcr = ATMEL_PDC_TXTEN;
+	  break;
+	case SNDRV_PCM_TRIGGER_STOP:
+          camr &= ~(AT91C_AC97C_CEN | AT91C_AC97C_ENDTX);
+	  ptcr = ATMEL_PDC_TXTDIS;
+          break;
+	default:
+          err = -EINVAL;
+          break;
+	}
+
+	ac97c_writel(chip, CAMR, camr);
+	writel(ptcr, chip->regs + ATMEL_PDC_PTCR);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_trigger\n\r", driver_name);
+
+	return err;
+}
+
+static  snd_pcm_uframes_t snd_at91_ac97_pointer(struct snd_pcm_substream *substream)
+{
+	at91_ac97_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	unsigned long bytes;
+
+	bytes = readl(chip->regs + ATMEL_PDC_TPR) - runtime->dma_addr;
+
+	pos = bytes_to_frames(runtime, bytes);
+	if (pos >= runtime->buffer_size)
+		pos -= runtime->buffer_size;
+
+	snd_printd(KERN_DEBUG "%s : snd_at91_ac97_pointer\n\r", driver_name);
+
+	return pos;
+}
+
+static struct snd_pcm_ops at91_ac97_playback_ops = {
+	.open		= snd_at91_ac97_playback_open,
+	.close		= snd_at91_ac97_playback_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= snd_at91_ac97_hw_params,
+	.hw_free	= snd_at91_ac97_hw_free,
+	.prepare	= snd_at91_ac97_playback_prepare,
+	.trigger	= at91_ac97_trigger,
+	.pointer	= snd_at91_ac97_pointer,
+};
+
+
+static struct ac97_pcm at91_ac97_pcm_defs[] __devinitdata = {
+	/* Playback */
+	{
+		.exclusive = 1,
+		.r = { {
+			.slots = ((1 << AC97_SLOT_PCM_LEFT)
+				  | (1 << AC97_SLOT_PCM_RIGHT)),
+		} },
+	},
+};
+
+static int __devinit snd_at91_ac97_pcm_new(at91_ac97_t *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_ac97_pcm_assign(chip->ac97_bus, 1, at91_ac97_pcm_defs);
+	if (err)
+		return err;
+
+	err = snd_pcm_new(chip->card, "Atmel AC97", 0, 1, 0, &pcm);
+	if (err)
+		return err;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      &chip->pdev->dev,
+					      128 * 1024, 256 * 1024);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at91_ac97_playback_ops);
+
+	pcm->private_data = chip;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "Atmel AC97");
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+/* Mixer part */
+static int snd_at91_ac97_mixer_new(at91_ac97_t *chip)
+{
+	int err;
+	struct snd_ac97_template template;
+
+	memset(&template, 0, sizeof(template));
+	template.private_data = chip;
+	template.num = 0;
+	template.addr = 0;
+	err = snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);
+
+	return err;
+}
+
+
+static irqreturn_t snd_at91_ac97_interrupt(int irq, void *dev_id)
+{
+	at91_ac97_t *chip = dev_id;
+	unsigned long status;
+	unsigned long dummy;
+
+	status = ac97c_readl(chip, SR);
+
+	if (status & AT91C_AC97C_CAEVT) {
+		struct snd_pcm_runtime *runtime;
+		int offset, next_period, block_size;
+		unsigned long casr;
+
+		runtime = chip->playback_substream->runtime;
+		block_size = frames_to_bytes(runtime, runtime->period_size);
+
+		casr = ac97c_readl(chip, CASR);
+
+		if (casr & AT91C_AC97C_ENDTX) {
+			chip->period++;
+			if (chip->period == runtime->periods)
+				chip->period = 0;
+			next_period = chip->period + 1;
+			if (next_period == runtime->periods)
+				next_period = 0;
+
+			offset = block_size * next_period;
+
+			writel(runtime->dma_addr + offset, chip->regs + ATMEL_PDC_TNPR);
+			writel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);
+
+			snd_pcm_period_elapsed(chip->playback_substream);
+		} else {
+                  printk(KERN_WARNING
+                         "Spurious AC97A interrupt, status = 0x%08lx\n",
+                         (unsigned long)casr);
+		}
+	} else {
+		printk(KERN_WARNING
+		       "Spurious AC97 interrupt, status = 0x%08lx\n",
+		       status);
+	}
+
+	dummy = ac97c_readl(chip, SR);
+
+	return IRQ_HANDLED;
+}
+
+
+/* CODEC part */
+
+static void snd_at91_ac97_hard_reset(at91_ac97_t *chip)
+{
+       // Enable AC97 Controller.
+       // Perform a cold (hard) reset of the AC97 codec.
+       ac97c_writel(chip, MR, 0);
+       ac97c_writel(chip, MR, AT91C_AC97C_ENA);
+
+       at91_ac97c_drive_reset(chip, 0);
+       udelay(1);
+       at91_ac97c_drive_reset(chip, 1);
+       udelay(1);
+}
+
+
+static void snd_at91_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+				 unsigned short val)
+{
+	at91_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 0x100;
+
+	snd_printd(KERN_DEBUG "%s : Writing codec register 0x%x = 0x%x\n\r", driver_name, reg, val);
+
+	word = (reg & 0x7f) << 16 | val;
+
+	do {
+		if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY) {
+			ac97c_writel(chip, COTHR, word);
+			return;
+		}
+		udelay(1);
+	} while (--timeout);
+
+	snd_printk(KERN_WARNING "at91-ac97: codec write timeout\n\r");
+}
+
+static unsigned short snd_at91_ac97_read(struct snd_ac97 *ac97,
+					  unsigned short reg)
+{
+	at91_ac97_t *chip = ac97->private_data;
+	unsigned long word;
+	int timeout = 0x100;
+
+
+	word = (0x80 | (reg & 0x7f)) << 16;
+
+	do {
+                if (ac97c_readl(chip, COSR) & AT91C_AC97C_TXRDY){
+                     ac97c_writel(chip, COTHR, word);
+                     break;
+                }
+		udelay(1);
+	} while (--timeout);
+
+	if (!timeout)
+		goto timed_out;
+
+	timeout = 0x100;
+
+	do {
+                if (ac97c_readl(chip, COSR) & AT91C_AC97C_RXRDY){
+                     unsigned short val = (unsigned short) ac97c_readl(chip, CORHR);
+		     return val;
+		}
+		udelay(1);
+	} while (--timeout);
+
+	if (!timeout)
+		goto timed_out;
+
+timed_out:
+	snd_printk(KERN_WARNING "at91-ac97: codec read timeout\n\r");
+	return 0xffff;
+}
+
+static void snd_at91_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+        at91_ac97_t *chip = ac97->private_data;
+	volatile unsigned int mr = ac97c_readl(chip, MR);
+
+	mr |= AT91C_AC97C_WRST;
+
+	ac97c_writel(chip, MR, mr);
+	udelay(1);
+
+	mr &= ~AT91C_AC97C_WRST;
+	ac97c_writel(chip, MR, mr);
+}
+
+static void snd_at91_ac97_destroy(struct snd_card *card)
+{
+	at91_ac97_t *chip = get_chip(card);
+
+	if (chip->irq != -1)
+		free_irq(chip->irq, chip);
+
+	if (chip->regs)
+		iounmap(chip->regs);
+}
+
+static int __devinit snd_at91_ac97_create(struct snd_card *card,
+					   struct platform_device *pdev)
+{
+	static struct snd_ac97_bus_ops ops = {
+		.write	= snd_at91_ac97_write,
+		.read	= snd_at91_ac97_read,
+		.reset  = snd_at91_ac97_warm_reset,
+	};
+
+	at91_ac97_t *chip = get_chip(card);
+	int irq, err = 0;
+
+
+
+	card->private_free = snd_at91_ac97_destroy;
+
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	chip->pdev = pdev;
+	chip->irq = -1;
+
+	if (!(platform_resource_flags(pdev, 0) & IORESOURCE_MEM)
+	    || !(platform_resource_flags(pdev, 1) & IORESOURCE_IRQ))
+		return -ENODEV;
+
+	irq = platform_resource_start(pdev, 1);
+
+	err = request_irq(irq, snd_at91_ac97_interrupt, 0, "ac97", chip);
+	if (err) {
+		snd_printk(KERN_WARNING "unable to request IRQ%d\n", irq);
+		return err;
+	}
+
+	chip->irq = irq;
+    	snd_printk(KERN_INFO "AC97C regs = %08X \n", platform_resource_start(pdev, 0));
+    	snd_printk(KERN_INFO "AC97C irq  = %d \n",irq);
+
+	chip->regs = ioremap(platform_resource_start(pdev, 0),
+			     platform_resource_len(pdev, 0));
+	if (!chip->regs) {
+	        snd_printk(KERN_WARNING "unable to remap AC97C io memory\n");
+		return -ENOMEM;
+	}
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);
+
+	return err;
+}
+
+static int __devinit snd_at91_ac97_probe(struct platform_device *pdev)
+{
+	static int dev;
+	struct atmel_ac97_data *pdata = pdev->dev.platform_data;
+	struct snd_card *card;
+	at91_ac97_t *chip;
+	int err;
+
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(at91_ac97_t));
+	if (!card)
+		return -ENOMEM;
+	chip = get_chip(card);
+
+	err = snd_at91_ac97_create(card, pdev);
+	if (err)
+		goto out_free_card;
+
+	// Enable AC97 Controller clock
+	chip->reset_pin = pdata->reset_pin;
+	chip->ac97_clk = clk_get(NULL, "ac97_clk");
+	if(!chip->ac97_clk)
+		goto out_free_card;
+
+	clk_enable(chip->ac97_clk);
+
+	// Perform a codec hard reset.
+	// This also enables the AC97 Controller.
+	snd_at91_ac97_hard_reset(chip);
+
+	err = snd_at91_ac97_mixer_new(chip);
+	if (err)
+		goto out_free_card;
+
+	err = snd_at91_ac97_pcm_new(chip);
+	if (err)
+		goto out_free_card;
+
+	strcpy(card->driver, "ac97c");
+	strcpy(card->shortname, "Atmel AC97");
+	sprintf(card->longname, "Atmel AC97 Controller at %#lx, irq %i",
+		(unsigned long) platform_resource_start(pdev, 0), (int) chip->irq);
+
+	err = snd_card_register(card);
+	if (err)
+		goto out_free_card;
+
+	dev_set_drvdata(&pdev->dev, card);
+	dev++;
+	return 0;
+
+out_free_card:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_at91_ac97_remove(struct  platform_device *pdev)
+{
+        struct snd_card *card = dev_get_drvdata(&pdev->dev);
+	at91_ac97_t *chip = get_chip(card);
+
+
+	snd_card_free(card);
+
+	// Disable AC97 Controller
+	ac97c_writel(chip, MR, 0);
+
+	// Disable AC97 Controller clock
+	clk_disable(chip->ac97_clk);
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver at91_ac97_driver =
+{
+	.probe      = snd_at91_ac97_probe,
+	.remove     = __devexit_p(snd_at91_ac97_remove),
+	.driver     =
+	{
+		.name       = "ac97c",
+	}
+	,
+};
+
+static int __init at91_ac97_init(void)
+{
+	return platform_driver_register(&at91_ac97_driver);
+}
+
+static void __exit at91_ac97_exit(void)
+{
+	platform_driver_unregister(&at91_ac97_driver);
+}
+
+module_init(at91_ac97_init);
+module_exit(at91_ac97_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for Atmel AC97 Controller");
+MODULE_AUTHOR("Atmel");
+
diff -uNrbBw linux-2.6.22/sound/arm/at91-ac97.h linux-2.6.22_9260/sound/arm/at91-ac97.h
--- linux-2.6.22/sound/arm/at91-ac97.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/at91-ac97.h	2014-08-26 16:23:12.707385283 +0800
@@ -0,0 +1,281 @@
+/* linux/include/asm-arm/arch-at91rm9200/ac97c.h
+ *
+ * Hardware definition for the ac97c peripheral in the ATMEL at91sam926x processor
+ *
+ * Generated  12/09/2005 (11:54:20) AT91 SW Application Group from AC97C_XXXX V1.3
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef __AC97C_H
+#define __AC97C_H
+
+/* -------------------------------------------------------- */
+/* AC97C ID definitions for  AT91SAM926x           */
+/* -------------------------------------------------------- */
+#ifndef AT91C_ID_AC97C
+#define AT91C_ID_AC97C 	18 /**< AC97 Controller id */
+#endif /* AT91C_ID_AC97C */
+
+/* -------------------------------------------------------- */
+/* AC97C Base Address definitions for  AT91SAM926x   */
+/* -------------------------------------------------------- */
+#define AT91C_BASE_AC97C     	0xFFFA0000 /**< AC97C base address */
+
+/* -------------------------------------------------------- */
+/* PIO definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AT91C_PB1_AC97CK   	(1 << 1) /**<  */
+#define AT91C_PB0_AC97FS   	(1 << 0) /**<  */
+#define AT91C_PB3_AC97RX   	(1 << 3) /**<  */
+#define AT91C_PB2_AC97TX   	(1 << 2) /**<  */
+
+/* -------------------------------------------------------- */
+/* Register offset definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+#define AC97C_MR 	(0x0008) 	/**< Mode Register */
+#define AC97C_ICA 	(0x0010) 	/**< Input Channel AssignementRegister */
+#define AC97C_OCA 	(0x0014) 	/**< Output Channel Assignement Register */
+#define AC97C_CARHR 	(0x0020) 	/**< Channel A Receive Holding Register */
+#define AC97C_CATHR 	(0x0024) 	/**< Channel A Transmit Holding Register */
+#define AC97C_CASR 	(0x0028) 	/**< Channel A Status Register */
+#define AC97C_CAMR 	(0x002C) 	/**< Channel A Mode Register */
+#define AC97C_CBRHR 	(0x0030) 	/**< Channel B Receive Holding Register (optional) */
+#define AC97C_CBTHR 	(0x0034) 	/**< Channel B Transmit Holding Register (optional) */
+#define AC97C_CBSR 	(0x0038) 	/**< Channel B Status Register */
+#define AC97C_CBMR 	(0x003C) 	/**< Channel B Mode Register */
+#define AC97C_CORHR 	(0x0040) 	/**< COdec Transmit Holding Register */
+#define AC97C_COTHR 	(0x0044) 	/**< COdec Transmit Holding Register */
+#define AC97C_COSR 	(0x0048) 	/**< CODEC Status Register */
+#define AC97C_COMR 	(0x004C) 	/**< CODEC Mask Status Register */
+#define AC97C_SR 	(0x0050) 	/**< Status Register */
+#define AC97C_IER 	(0x0054) 	/**< Interrupt Enable Register */
+#define AC97C_IDR 	(0x0058) 	/**< Interrupt Disable Register */
+#define AC97C_IMR 	(0x005C) 	/**< Interrupt Mask Register */
+#define AC97C_VERSION 	(0x00FC) 	/**< Version Register */
+
+/* -------------------------------------------------------- */
+/* Bitfields definition for AC97C hardware peripheral */
+/* -------------------------------------------------------- */
+/* --- Register AC97C_MR */
+#define AT91C_AC97C_ENA       (0x1 << 0 ) /**< (AC97C) AC97 Controller Global Enable */
+#define AT91C_AC97C_WRST      (0x1 << 1 ) /**< (AC97C) Warm Reset */
+#define AT91C_AC97C_VRA       (0x1 << 2 ) /**< (AC97C) Variable RAte (for Data Slots) */
+/* --- Register AC97C_ICA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_OCA */
+#define AT91C_AC97C_CHID3     (0x7 << 0 ) /**< (AC97C) Channel Id for the input slot 3 */
+#define 	AT91C_AC97C_CHID3_NONE                 0x0 /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CA                   0x1 /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CB                   0x2 /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID3_CC                   0x3 /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID4     (0x7 << 3 ) /**< (AC97C) Channel Id for the input slot 4 */
+#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID5     (0x7 << 6 ) /**< (AC97C) Channel Id for the input slot 5 */
+#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID6     (0x7 << 9 ) /**< (AC97C) Channel Id for the input slot 6 */
+#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID7     (0x7 << 12) /**< (AC97C) Channel Id for the input slot 7 */
+#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID8     (0x7 << 15) /**< (AC97C) Channel Id for the input slot 8 */
+#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID9     (0x7 << 18) /**< (AC97C) Channel Id for the input slot 9 */
+#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID10    (0x7 << 21) /**< (AC97C) Channel Id for the input slot 10 */
+#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID11    (0x7 << 24) /**< (AC97C) Channel Id for the input slot 11 */
+#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) /**< (AC97C) Channel C data will be transmitted during this slot */
+#define AT91C_AC97C_CHID12    (0x7 << 27) /**< (AC97C) Channel Id for the input slot 12 */
+#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) /**< (AC97C) No data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) /**< (AC97C) Channel A data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) /**< (AC97C) Channel B data will be transmitted during this slot */
+#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) /**< (AC97C) Channel C data will be transmitted during this slot */
+/* --- Register AC97C_CARHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CATHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CASR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+/* --- Register AC97C_CAMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_ENDTX     (0x1 << 10) /**< (AC97C)  */
+#define AT91C_AC97C_TXBUFE    (0x1 << 11) /**< (AC97C)  */
+#define AT91C_AC97C_ENDRX     (0x1 << 14) /**< (AC97C)  */
+#define AT91C_AC97C_RXBUFF    (0x1 << 15) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+#define AT91C_AC97C_PDCEN     (0x1 << 22) /**< (AC97C)  */
+/* --- Register AC97C_CBRHR */
+#define AT91C_AC97C_RDATA     (0xFFFFF << 0 ) /**< (AC97C) Receive data */
+/* --- Register AC97C_CBTHR */
+#define AT91C_AC97C_TDATA     (0xFFFFF << 0 ) /**< (AC97C) Transmit data */
+/* --- Register AC97C_CBSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+/* --- Register AC97C_CBMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+#define AT91C_AC97C_OVRUN     (0x1 << 5 ) /**< (AC97C)  */
+#define AT91C_AC97C_SIZE      (0x3 << 16) /**< (AC97C)  */
+#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) /**< (AC97C) Data size is 20 bits */
+#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) /**< (AC97C) Data size is 18 bits */
+#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) /**< (AC97C) Data size is 16 bits */
+#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) /**< (AC97C) Data size is 10 bits */
+#define AT91C_AC97C_CEM       (0x1 << 18) /**< (AC97C)  */
+#define AT91C_AC97C_CEN       (0x1 << 21) /**< (AC97C)  */
+/* --- Register AC97C_CORHR */
+#define AT91C_AC97C_SDATA     (0xFFFF << 0 ) /**< (AC97C) Status Data */
+/* --- Register AC97C_COTHR */
+#define AT91C_AC97C_CDATA     (0xFFFF << 0 ) /**< (AC97C) Command Data */
+#define AT91C_AC97C_CADDR     (0x7F << 16) /**< (AC97C) COdec control register index */
+#define AT91C_AC97C_READ      (0x1 << 23) /**< (AC97C) Read/Write command */
+/* --- Register AC97C_COSR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_COMR */
+#define AT91C_AC97C_TXRDY     (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_TXEMPTY   (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_UNRUN     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_RXRDY     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_SR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IER */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IDR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+/* --- Register AC97C_IMR */
+#define AT91C_AC97C_SOF       (0x1 << 0 ) /**< (AC97C)  */
+#define AT91C_AC97C_WKUP      (0x1 << 1 ) /**< (AC97C)  */
+#define AT91C_AC97C_COEVT     (0x1 << 2 ) /**< (AC97C)  */
+#define AT91C_AC97C_CAEVT     (0x1 << 3 ) /**< (AC97C)  */
+#define AT91C_AC97C_CBEVT     (0x1 << 4 ) /**< (AC97C)  */
+
+#endif /* __AC97C_H */
diff -uNrbBw linux-2.6.22/sound/arm/Kconfig linux-2.6.22_9260/sound/arm/Kconfig
--- linux-2.6.22/sound/arm/Kconfig	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/Kconfig	2014-08-26 16:23:12.701379873 +0800
@@ -33,4 +33,20 @@
 	  Say Y or M if you want to support any AC97 codec attached to
 	  the PXA2xx AC97 interface.
 
+config SND_AT73C213
+	tristate "Atmel AT73C213 DAC driver"
+	depends on SND && SPI_ATMEL && ARCH_AT91 && AT91_PROGRAMMABLE_CLOCKS
+	select SND_PCM
+	help
+	  Say Y here if you want to use the Atmel AT73C213 external DAC.
+
+config SND_AT91_AC97
+	tristate "AC97 Controller driver for SAM926X familly from ATMEL"
+	depends on SND && ARCH_AT91
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  Say Y or M if you want to support any AC97 codec attached to
+	  the SAM926X AC97 Controller.
+
 endmenu
diff -uNrbBw linux-2.6.22/sound/arm/Makefile linux-2.6.22_9260/sound/arm/Makefile
--- linux-2.6.22/sound/arm/Makefile	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/sound/arm/Makefile	2014-08-26 16:23:12.709401864 +0800
@@ -13,3 +13,9 @@
 
 obj-$(CONFIG_SND_PXA2XX_AC97)	+= snd-pxa2xx-ac97.o
 snd-pxa2xx-ac97-objs		:= pxa2xx-ac97.o
+
+obj-$(CONFIG_SND_AT73C213)	+= snd-at73c213.o
+snd-at73c213-objs		:= at73c213.o
+
+obj-$(CONFIG_SND_AT91_AC97)	+= snd-at91-ac97.o
+snd-at91-ac97-objs		:= at91-ac97.o
diff -uNrbBw linux-2.6.22/sound/soc/at91/eti_b1_wm8731.c linux-2.6.22_9260/sound/soc/at91/eti_b1_wm8731.c
--- linux-2.6.22/sound/soc/at91/eti_b1_wm8731.c	2007-07-09 07:32:17.000000000 +0800
+++ linux-2.6.22_9260/sound/soc/at91/eti_b1_wm8731.c	2014-08-26 16:22:54.397396219 +0800
@@ -34,8 +34,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 
-#include <asm/arch/hardware.h>
-#include <asm/arch/at91_pio.h>
+#include <asm/hardware.h>
 #include <asm/arch/gpio.h>
 
 #include "../codecs/wm8731.h"
@@ -48,13 +47,6 @@
 #define	DBG(x...)
 #endif
 
-#define AT91_PIO_TF1	(1 << (AT91_PIN_PB6 - PIN_BASE) % 32)
-#define AT91_PIO_TK1	(1 << (AT91_PIN_PB7 - PIN_BASE) % 32)
-#define AT91_PIO_TD1	(1 << (AT91_PIN_PB8 - PIN_BASE) % 32)
-#define AT91_PIO_RD1	(1 << (AT91_PIN_PB9 - PIN_BASE) % 32)
-#define AT91_PIO_RK1	(1 << (AT91_PIN_PB10 - PIN_BASE) % 32)
-#define AT91_PIO_RF1	(1 << (AT91_PIN_PB11 - PIN_BASE) % 32)
-
 static struct clk *pck1_clk;
 static struct clk *pllb_clk;
 
@@ -277,7 +269,6 @@
 static int __init eti_b1_init(void)
 {
 	int ret;
-	u32 ssc_pio_lines;
 	struct at91_ssc_periph *ssc = eti_b1_dai.cpu_dai->private_data;
 
 	if (!request_mem_region(AT91RM9200_BASE_SSC1, SZ_16K, "soc-audio")) {
@@ -311,19 +302,12 @@
 		goto fail_io_unmap;
 	}
 
- 	ssc_pio_lines = AT91_PIO_TF1 | AT91_PIO_TK1 | AT91_PIO_TD1
-			| AT91_PIO_RD1 /* | AT91_PIO_RK1 */ | AT91_PIO_RF1;
-
-	/* Reset all PIO registers and assign lines to peripheral A */
- 	at91_sys_write(AT91_PIOB + PIO_PDR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_ODR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_IFDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_CODR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_IDR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_MDDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_PUDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_ASR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_OWDR, ssc_pio_lines);
+ 	at91_set_A_periph(AT91_PIN_PB6, 0);	/* TF1 */
+ 	at91_set_A_periph(AT91_PIN_PB7, 0);	/* TK1 */
+ 	at91_set_A_periph(AT91_PIN_PB8, 0);	/* TD1 */
+ 	at91_set_A_periph(AT91_PIN_PB9, 0);	/* RD1 */
+/* 	at91_set_A_periph(AT91_PIN_PB10, 0);*/	/* RK1 */ 	
+ 	at91_set_A_periph(AT91_PIN_PB11, 0);	/* RF1 */
 
 	/*
 	 * Set PCK1 parent to PLLB and its rate to 12 Mhz.
